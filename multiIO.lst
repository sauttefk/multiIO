MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ;******************************************************************************
                      00002 ; turn off crossing page boundary message
                      00003         ERRORLEVEL -306, -302
                      00004 
                      00005 #define                 revision        4
                      00006 #define                 device          0x0d
                      00007 #define                 bits89          8
                      00008 
                      00009  ifdef  __DEBUG
                      00010         __CONFIG        0x13e4          ; debugger
                      00011         messg   "Debug mode"
                      00012  else
2007   13C4           00013         __CONFIG        0x13c4          ; w/o debugger
                      00014 ;       __CONFIG        0x03c4          ; w/o debugger
                      00015  endif
                      00016 
                      00017 
                      00018 #include                <p16F946.inc>
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ;  MPASM PIC16F946 processor include
                      00005 ; 
                      00006 ;  (c) Copyright 1999-2011 Microchip Technology, All rights reserved
                      00007 ;==========================================================================
                      00008 
                      01647         LIST
                      00019 
                      00020 #include                <defines.asm>
0000                  00001 DEFINES                 ;{
                      00002 #define                 XTAL_FREQ               .8000000                ; OSC freq in Hz
                      00003 
                      00004 #define                 BAUD_9600               .50
                      00005 #define                 BAUD_19200              .25
                      00006 #define                 BAUD_38400              .12
                      00007 #define                 BAUD_57600              .08
                      00008 
                      00009 #define                 BUFSIZE                 0x20
                      00010                                 IF      (BUFSIZE&(BUFSIZE-1))
                      00011                                         ERROR "BUFSIZE MUST BE A POWER OF 2"
                      00012                                 ENDIF
                      00013 #define                 MSGBUFSIZE              0x10
                      00014                                 IF      (MSGBUFSIZE&(MSGBUFSIZE-1))
                      00015                                         ERROR "MSGBUFSIZE MUST BE A POWER OF 2"
                      00016                                 ENDIF
                      00017 
                      00018 
                      00019 ; caulculates baudrate when BRGH = 1, adjust for rounding errors
                      00020 #define                 CALC_HIGH_BAUD(BaudRate)        (XTAL_FREQ/(16*BaudRate))-.5
                      00021 ; caulculates baudrate when BRGH = 0, adjust for rounding errors
                      00022 #define                 CALC_LOW_BAUD(BaudRate)         (((10*XTAL_FREQ/(64*BaudRate))+5)/10)-1
                      00023 ; caulculates timer1 delay when prescale is 1:8, adjust for rounding errors
                      00024 #define                 CALC_TIMER(TickTime)    (0xFFFF-((TickTime*XTAL_FREQ)/32000))+1
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00025 
                      00026 #define                 prescale_Mode   0
                      00027 #define                 output                  1
                      00028 #define                 input                   2
                      00029 #define                 devID1                  3
                      00030 #define                 delay                   4
                      00031 #define                 devID2                  5
                      00032 
                      00033 #define                 BYTE0           0
                      00034 #define                 BYTE1           1
                      00035 #define                 BYTE2           2
                      00036 #define                 BYTE3           3
                      00037 #define                 BYTE4           4
                      00038 #define                 STATE           5
                      00039 
                      00040 ; modes for parameter eeprom
                      00041 ; mode 0 - 1 exit
                      00042 ; mode 1 - 4 passthrough
                      00043 ; mode 2 - 2 always off
                      00044 ; mode 3 - 2 always on
                      00045 ; mode 4 - 4 toggle light
                      00046 ; mode 5 - 4 light toogle dual outputs
                      00047 ; mode 6 - 5 two stage light (output1: 1st stage output1+2 2nd stage)
                      00048 ; mode 7 - 1 nop
                      00049 ; mode 8 - 5 retriggerable timer
                      00050 ; mode 9 - 5 blinker
                      00051 ; mode a - 1 nop
                      00052 ; mode b - 1 nop
                      00053 ; mode c - 1 nop
                      00054 ; mode d - 6 awning (output1: on/off output2: open/close)
                      00055 ; mode e - 6 blind (output1: on/off output2: up/down
                      00056 ; mode f - 6 window (output1: up output2: down)
                      00057 
                      00058 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00059 
                      00060 
                      00061 ;*******************************************************************************
                      00062 ; message format: 3 bytes (except time and config answer messages)
                      00063                                                  ;+-------+
                      00064                                                  ;| byte0 |
                      00065 #define STARTBYTE       0x00 ;| 0x00  |
                      00066                                                  ;+-------+-------+-------+-------+------+
                      00067                                                  ;| byte1 | byte2 | byte3 | byte4 | done |
                      00068 #define CMDOFF          0x01 ;| 0x01  | ID    |       |       |  ok  | power off all outputs on device
                      00069                                              ;| 0x01  | 0xFF  |       |       |  ok  | power off global
                      00070 #define CMDRESET        0x02 ;| 0x02  | ID    |       |       |  ok  | reset device ID
                      00071                                              ;| 0x02  | 0xFF  |       |       |  ok  | reset devices glo
                            bal
                      00072 #define CMDACK          0x03 ;| 0x03  | ID    |       |       |  ok  | ACK
                      00073 #define CMDID           0x04 ;| 0x04  | ID    |       |       |  ok  | poll for existence device ID
                      00074 
                      00075 #define CMDOWR          0x05 ;| 0x05  | ID    | lbyte | hbyte |  ok  | write outputs on device ID
                      00076 #define CMDIRD          0x06 ;| 0x06  | ID    |       |       |  ok  | read inputs on device ID
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00077 #define CMDORD          0x07 ;| 0x06  | ID    |       |       |  ok  | read outputs on device ID
                      00078 #define CMDIOANS        0x08 ;| 0x07  | ID    | lbyte | hbyte |  ok  | 2 bytes read inputs answer
                      00079 
                      00080 #define CMDTSET         0x09 ;| 0x08  | ID    |       |       |  ok  | write time of device ID
                      00081                                              ;| 0x08  | 0xFF  |       |       |  ok  | write time global
                      00082 #define CMDTGET         0x0A ;| 0x09  | ID    |       |       |  ok  | read time of device ID
                      00083 #define CMDTGACK        0x0B ;| 0x0A  | ID    |       |       |  ok  | 5 bytes read time answer
                      00084 
                      00085 #define CMDCGET         0x0C ;| 0x0B  | ID    |       |       |  ok  | read configuration of device ID
                      00086 #define CMDCGACK        0x0D ;| 0x0C  | ID    |       |       |  ok  | 255 bytes read configuration answ
                            er
                      00087 #define CMDCSET         0x0E ;| 0x0D  | ID    |       |       |  ok  | 256 bytes write configuration of 
                            device ID
                      00088 #define CMDNEEDCFG      0x0F ;| 0x0F  | 0xFF  |       |       |      | need config (after pressing key)
                      00089 
                      00090 #define CMDPEDGE        0x10 ;| 0x1Y  | ID    |       |       |  ok  | positive edge on input Y on devic
                            e ID
                      00091 
                      00092 #define CMDNEDGE        0x20 ;| 0x2Y  | ID    |       |       |  ok  | negative edge on input Y on devic
                            e ID
                      00093 
                      00094 #define CMDSOFF         0x40 ;| 0x4Y  | ID    |       |       |  ok  | blinds up/windows close/lights of
                            f output Y on device ID
                      00095 #define CMDGOFF         0x50 ;| 0x5G  | GG    |       |       | XXXX | blinds up/windows close/lights of
                            f group GGG
                      00096 #define CMDAOFF         0x5F ;| 0x5F  | 0x01  |       |       |  ok  | lights off global (byte2 is bitma
                            sk)
                      00097                                              ;| 0x5F  | 0x02  |       |       |  ok  | blinds up global 
                            (byte2 is bitmask)
                      00098                                              ;| 0x4F  | 0x04  |       |       |  ok  | windows close glo
                            bal (byte2 is bitmask)
                      00099                                              ;| 0x5F  | 0x08  |       |       |  ok  | awning close glob
                            al (byte2 is bitmask)
                      00100 
                      00101 #define CMDSON          0x60 ;| 0x6Y  | ID    |       |       |  ok  | blinds down/windows open/lights o
                            n output Y on device ID
                      00102 #define CMDGON          0x70 ;| 0x7G  | GG    |       |       | XXXX | blinds down/windows open/lights o
                            n group GGG
                      00103 #define CMDAON          0x7F ;| 0x7F  | 0x01  |       |       |  ok  | lights on global (byte2 is bitmas
                            k)
                      00104                                              ;| 0x7F  | 0x02  |       |       |  ok  | blinds down globa
                            l (byte2 is bitmask)
                      00105                                              ;| 0x7F  | 0x04  |       |       |  ok  | windows open glob
                            al (byte2 is bitmask)
                      00106                                              ;| 0x7F  | 0x08  |       |       |  ok  | awning open globa
                            l (byte2 is bitmask)
                      00107 
                      00108 #define CMDOC           0x80 ;| 0x8Y  | ID    |       |       |  ok  | clear output Y on device ID
                      00109 #define CMDOS           0x90 ;| 0x9Y  | ID    |       |       |  ok  | set output Y on device ID
                      00110 #define CMDO            0xA0 ;| 0xAY  | ID    |       |       |  ok  | read output Y on device ID
                      00111 #define CMDI            0xB0 ;| 0xBY  | ID    |       |       |  ok  | read input Y on device ID
                      00112 
                      00113                                                  ; TODO ### blind down inhibit (single)
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00114                                                  ; TODO ### window open inhibit (single)
                      00115 ;}
                      00116 
                      00021 #include                <variables.asm>
0000                  00001 VARIABLES               ;{
                      00002                                 cblock  0x20
  00000020            00003 deviceID:               1
                      00004 
  00000021            00005 iInSampleLo:    1
  00000022            00006 iInSampleHi:    1
  00000023            00007 iInSampleAux:   1
  00000024            00008 iInputLo:               1
  00000025            00009 iInputHi:               1
  00000026            00010 iInputAux:              1
  00000027            00011 iEdgeLo:                1
  00000028            00012 iEdgeHi:                1
  00000029            00013 iEdgeAux:               1
  0000002A            00014 iDebounceLoA:   1
  0000002B            00015 iDebounceHiA:   1
  0000002C            00016 iDebounceAuxA:  1
  0000002D            00017 iDebounceLoB:   1
  0000002E            00018 iDebounceHiB:   1
  0000002F            00019 iDebounceAuxB:  1
                      00020 
  00000030            00021 bitmaskLo:              1
  00000031            00022 bitmaskHi:              1
  00000032            00023 outputLo:               1
  00000033            00024 outputHi:               1
                      00025 
  00000034            00026 rxCount:                1
  00000035            00027 rxByte1:                1
  00000036            00028 rxByte2:                1
  00000037            00029 rxDevID:                1
  00000038            00030 rxInput:                1
                      00031 
  00000039            00032 paramPtr1:              1
  0000003A            00033 paramPtr2:              1
  0000003B            00034 paramPtr3:              1
  0000003C            00035 funcPrescMode:  1
  0000003D            00036 funcOutBits:    1
  0000003E            00037 funcTypeInput:  1
  0000003F            00038 funcDevID1:             1
  00000040            00039 funcDevID2:             1
  00000041            00040 funcDelay:              1
  00000042            00041 funcNumParams:  1
  00000043            00042 funcSemaphore:  1
  00000044            00043 funcUber:               1
                      00044 
  00000045            00045 txPutPtr:               1
  00000046            00046 txGetPtr:               1
  00000047            00047 txNum:                  1
                      00048 
  00000048            00049 rxPutPtr:               1
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000049            00050 rxGetPtr:               1
  0000004A            00051 rxNum:                  1
                      00052 
  0000004B            00053 msgPutPtr:              1
  0000004C            00054 msgGetPtr:              1
  0000004D            00055 msgNum:                 1
                      00056 
  0000004E            00057 msgLo:                  1
  0000004F            00058 msgHi:                  1
  00000050            00059 msgID:                  1
                      00060 
  00000051            00061 cfgRxCnt:               1
  00000052            00062 cfgTxCnt:               1
  00000053            00063 skipRxCnt:              1
                      00064 
  00000054            00065 iCount:                 1
  00000055            00066 iTemp1:                 1
  00000056            00067 iTemp2:                 1
  00000057            00068 iTemp3:                 1
                      00069 
  00000058            00070 eeByte:                 1
                      00071 
  00000059            00072 crc:                    1
                      00073 
  0000005A            00074 iDisplayCount:  1
  0000005B            00075 displayram:             0x0e
                      00076 
                      00077 
  00000069            00078 ramOverFlow             ; don't remove 
                      00079                                 endc
                      00080 
                      00081                                 if ramOverFlow > 70
                      00082                                         error "no more ram"
                      00083                                 endif
                      00084 
                      00085                                 cblock  0x70
  00000070            00086 safedW:                 1
  00000071            00087 safedSTATUS:    1
  00000072            00088 safedPCLATH:    1
  00000073            00089 safedFSR:               1
  00000074            00090 time:                   5
  00000079            00091 tabTemp:                1
  0000007A            00092 iTabTemp:               1
  0000007B            00093 temp1:                  1
  0000007C            00094 temp2:                  1
  0000007D            00095 temp3:                  1
  0000007E            00096 temp4:                  1
  0000007F            00097 temp5:                  1
                      00098                                 endc
                      00099                         
                      00100                                 cblock 0xa0
  000000A0            00101 rxBuf:                  BUFSIZE
  000000C0            00102 txBuf:                  BUFSIZE
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  000000E0            00103 msgBuf:                 MSGBUFSIZE
                      00104 
                      00105                                 endc
                      00106                                 cblock  0xf0    ; clone of 0xf0-0xff
  000000F0            00107 clone70_7f_1:   0x10
                      00108                                 endc
                      00109         
                      00110                                 cblock  0x120
  00000120            00111 functionRam:    0x50
                      00112                                 endc
                      00113         
                      00114                                 cblock  0x170   ; clone of 0x170-0x7f
  00000170            00115 clone70_7f_2:   0x10
                      00116                                 endc
                      00117                                 
                      00118                                 cblock  0x1a0
  000001A0            00119 functionRam2:   0x50
                      00120                                 endc
                      00121                                 
                      00122                                 cblock  0x1f0   ; clone of 0x1f0-0x1ff
  000001F0            00123 clone70_7f_3:   0x10
                      00124                                 endc    ;}
                      00022 #include                <macros.asm>
                      00001 setpclath               macro   PCLATH_34       ;{
                      00002 ;       setpclath 'help' macro for LONG_call
                      00003 ;       sets/clears PCLATH bits 3:4 according to 
                      00004 ;       'variable' PCLATH_34
                      00005                                 if(PCLATH_34&0x10)
                      00006                                         bsf     PCLATH,4        
                      00007                                 else
                      00008                                         bcf     PCLATH,4
                      00009                                 endif
                      00010                                 if(PCLATH_34&0x08)
                      00011                                         bsf     PCLATH,3        
                      00012                                 else
                      00013                                         bcf     PCLATH,3
                      00014                                 endif
                      00015                                 endm    ;}
                      00016 
                      00017 setpclath4              macro   PCLATH_4        ;{
                      00018 ;       setpclath4 'help' macro for LONG/SHORT_call
                      00019 ;       sets/clears PCLATH bit 4 according to 
                      00020 ;       'variable' PCLATH_4
                      00021                                 if(PCLATH_4&0x10)
                      00022                                         bsf     PCLATH,4        
                      00023                                 else
                      00024                                         bcf     PCLATH,4
                      00025                                 endif
                      00026                                 endm    ;}
                      00027 
                      00028 setpclath3              macro   PCLATH_3        ;{
                      00029 ;       setpclath3 'help' macro for LONG/SHORT_call
                      00030 ;       sets/clears PCLATH bit 3 according to 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00031 ;       'variable' PCLATH_3
                      00032                                 if(PCLATH_3&0x08)
                      00033                                         bsf     PCLATH,3        
                      00034                                 else
                      00035                                         bcf     PCLATH,3
                      00036                                 endif
                      00037                                 endm    ;}
                      00038 
                      00039 tabj            macro   
                      00040 ;{
                      00041 ;       TABLE_JUMP Calculates an eventual table boundary crossing  
                      00042 ;       sets up the PCLATH register correctly
                      00043 ;       Offset must be in w-reg, offset 0 jumps to the next instr. 
                      00044                                 movwf   tabTemp                 ; save wanted offset
                      00045                                 movlw   LOW($+8)                ; get low adress ( of first instr. after
                             macro )
                      00046                                 addwf   tabTemp,f               ; add offset
                      00047                                 movlw   HIGH($+6)               ; get highest 5 bits ( of first instr. a
                            fter macro )
                      00048                                 skpnc                                   ; page crossed ? ( 256 byte )
                      00049                                 addlw   0x01                    ; Yes add one to high adress
                      00050                                 movwf   PCLATH                  ; load high adress in latch
                      00051                                 movf    tabTemp,w               ; get computed adress
                      00052                                 movwf   PCL                             ; And jump
                      00053                                 endm    ;}
                      00054                         
                      00055 itabj                   macro   
                      00056 ;{
                      00057 ;       TABLE_JUMP Calculates an eventual table boundary crossing  
                      00058 ;       sets up the PCLATH register correctly
                      00059 ;       Offset must be in w-reg, offset 0 jumps to the next instr. 
                      00060                                 movwf   iTabTemp                ; save wanted offset
                      00061                                 movlw   LOW($+8)                ; get low adress ( of first instr. after
                             macro )
                      00062                                 addwf   iTabTemp,f              ; add offset
                      00063                                 movlw   HIGH($+6)               ; get highest 5 bits ( of first instr. a
                            fter macro )
                      00064                                 skpnc                                   ; page crossed ? ( 256 byte )
                      00065                                 addlw   0x01                    ; Yes add one to high adress
                      00066                                 movwf   PCLATH                  ; load high adress in latch
                      00067                                 movf    iTabTemp,w              ; get computed adress
                      00068                                 movwf   PCL                             ; And jump
                      00069                                 endm    ;}
                      00070                         
                      00071 longcall                macro   LABEL   ;{
                      00072 ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                      00073 ;       so call can cross ANY page boundary, resets PCLATH after call.
                      00074 ;       w-reg is left untouched.
                      00075                         
                      00076                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                      00077 
                      00078 DEST_HIGH               set     (HIGH(LABEL)&0x18)              ; save bits 4:5 of dest adress
                      00079 SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00080 DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                      00081 
                      00082                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                      00083                                         messg   "Call on same page, replace longcall with pcall", LABEL
                      00084                                         nop             ; redundant nops 
                      00085                                         nop
                      00086                                         call    LABEL
                      00087                                         nop
                      00088                                         nop
                      00089                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                      00090                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                      00091                                                 ;messg  "Setting page bits for long page crossing call"
                      00092                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                      00093                                                 call    LABEL           
                      00094                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                      00095                                         else
                      00096                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                      00097                                                 ; i.e. page0<->1 or page2<->3
                      00098                                                 messg   "Call only one page, replace longcall with scall
                            ", LABEL
                      00099                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                      00100                                                         nop     ; redundant nop
                      00101                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                      00102                                                         call    LABEL
                      00103                                                         setpclath4      SOURCE_HIGH
                      00104                                                         nop     ; redundant nop
                      00105                                                 else
                      00106                                                         ; lowest bit only
                      00107                                                         nop     ; redundant nop
                      00108                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                      00109                                                         call    LABEL
                      00110                                                         setpclath3      SOURCE_HIGH
                      00111                                                         nop
                      00112                                                 endif
                      00113                                         endif
                      00114                                 endif
                      00115                                 endm    ;}
                      00116 
                      00117 scall                   macro   LABEL   ;{      
                      00118 ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                      00119 ;       Resets PCLATH after call.
                      00120 ;       w-reg is left untouched.
                      00121                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                      00122 DEST_HIGH               set     (HIGH(LABEL)&0x18)                      ; save bits 4:5 of dest adress
                      00123 SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
                      00124 DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                      00125 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00126                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                      00127                                         messg   "Call on same page, replace scall with pcall", LABEL
                      00128                                         nop             ; redundant nops
                      00129                                         call    LABEL
                      00130                                         nop
                      00131                                 else    ; for safety check so we do not require LONG_call
                      00132                                         if      ((DIFF_HIGH&0x18)==0x18)
                      00133                                                 messg   " WARNING ! Replace scall with longcall", LABEL
                      00134                                         endif
                      00135 
                      00136                                         ;messg  "Setting page bits for short page crossing call"
                      00137                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                      00138                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                      00139                                                 call    LABEL
                      00140                                                 setpclath4      SOURCE_HIGH
                      00141                                         else    ; lowest bit only
                      00142                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                      00143                                                 call    LABEL
                      00144                                                 setpclath3      SOURCE_HIGH
                      00145                                         endif
                      00146                                 endif
                      00147                                 endm    ;}
                      00148 
                      00149 pcall                   macro   LABEL   ;{
                      00150 ;       Pcall page call, code for calling on same page
                      00151 ;       outputs messages if LONG/SHORT call could/must be used
                      00152                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                      00153 DEST_HIGH               set     (HIGH(LABEL)&0x18)                      ; save bits 4:5 of dest adress
                      00154 SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
                      00155 DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                      00156 
                      00157                                 if      (DIFF_HIGH == 0) ; same page, call ok
                      00158                                         call    LABEL
                      00159                                 else    ; for safety check so we do not require LONG_call
                      00160                                         if      ((DIFF_HIGH&0x18)==0x18)
                      00161                                                 messg   " WARNING ! Replace pcall with longcall", LABEL
                      00162                                                 call    LABEL   ; INCORRECT Call !!!
                      00163                                         else
                      00164                                                 messg   " WARNING ! Replace pcall with scall", LABEL
                      00165                                                 call    LABEL
                      00166                                         endif
                      00167                                 endif
                      00168                                 endm    ;}
                      00169 
                      00170 movff                   macro   source, destination ;{
                      00171 ; ---------------------------
                      00172 ; Macro: MOV FileReg to FileReg
                      00173 ; ---------------------------
                      00174                                 movfw   source
                      00175                                 movwf   destination
                      00176                                 endm    ;}
                      00177 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00178 movlf                   macro   literal, destination ;{
                      00179 ; ---------------------------
                      00180 ; Macro: MOV Literal to FileReg
                      00181 ; ---------------------------
                      00182                                 movlw   literal
                      00183                                 movwf   destination
                      00184                                 endm    ;}
                      00185 
                      00186 bittog                  macro   destination, bitno ;{
                      00187 ; ---------------------------
                      00188 ; Macro: Bit-Toggle
                      00189 ; ---------------------------
                      00190                                 movlw   1<<bitno                ; move 1 to bit position
                      00191                                 xorwf   destination
                      00192                                 endm    ;}
                      00193 
                      00194 disableirq              macro   ;{
                      00195 ;       disableirq disable global irq 
                      00196                                 local   STOP_INT
                      00197 STOP_INT                bcf             INTCON,GIE              ; disable global interrupt
                      00198                                 btfsc   INTCON,GIE              ; check if disabled 
                      00199                                 goto    STOP_INT                ; nope, try again
                      00200                                 endm    ;}
                      00201         
                      00202 enableirq               macro   ;{
                      00203                                 bsf             INTCON,GIE              ; enable global interrupt
                      00204                                 endm    ;}
                      00205 
                      00206 tstbnd                  macro   LABEL   ;{
                      00207                                 IF ((HIGH ($)) != (HIGH (LABEL+1)))
                      00208                                         ERROR LABEL CROSSES PAGE BOUNDARY!
                      00209                                 ENDIF
                      00210                                 endm    ;}
                      00211 
                      00212 outputOn                macro   ;{                              ; switch output on
                      00213                                 movfw   bitmaskLo
                      00214                                 iorwf   outputLo,f
                      00215                                 movfw   bitmaskHi
                      00216                                 iorwf   outputHi,f
                      00217                                 endm    ;}
                      00218                                 
                      00219 outputOff               macro   ;{                              ; switch output off
                      00220                                 comf    bitmaskLo,w
                      00221                                 andwf   outputLo,f
                      00222                                 comf    bitmaskHi,w
                      00223                                 andwf   outputHi,f
                      00224                                 endm    ;}
                      00225                                 
                      00226 outputToggle    macro   ;{                              ; toggle output
                      00227                                 movfw   bitmaskLo
                      00228                                 xorwf   outputLo,f
                      00229                                 movfw   bitmaskHi
                      00230                                 xorwf   outputHi,f
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 11


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00231                                 endm    ;}
                      00023 
                      00024 ;**********************************************************************
0000                  00025                                 org     0x000                   ; processor reset vector
0000   0000           00026                                 nop                                             ; required for the ICD 
Message[307]: Setting page bits.
0001   158A 120A 2800 00027                                 lgoto   main                    ; go to initialisation of program
                      00028         
                      00029 ;**************** Interrupt service routine **************************
0004                  00030                                 org             0x004                   ; interrupt vector locaton
                      00031 #include                <interrupt.asm>
0004                  00001 INT                             ;{
0004   00F0           00002                                 movwf   safedW                  ; save W register
0005   0E03           00003                                 swapf   STATUS,w                ; the swapf instruction, unlike the movf
                            , affects NO status bits, which is why it is used here.
0006   0183           00004                                 clrf    STATUS                  ; sets to BANK0
0007   00F1           00005                                 movwf   safedSTATUS             ; save status reg
0008   080A           00006                                 movfw   PCLATH
0009   00F2           00007                                 movwf   safedPCLATH             ; save pclath
000A   018A           00008                                 clrf    PCLATH
000B   0804           00009                                 movfW   FSR
000C   00F3           00010                                 movwf   safedFSR                ; save fsr reg
                      00011 
                      00012 ;                               btfss   INTCON,INTF             ; test for external interrupt
                      00013 ;                               goto    iTestRxIrq              ; nope check next interrupt source
                      00014 ;                               pcall   IRQ_INT_HANDLER ; external irq handler
                      00015 ;                               clrf    STATUS
                      00016 ;                               bcf             INTCON,INTF             ; clear int pin flag
                      00017 
                      00018 iTestRxIrq              pcall   iRxHandler              ; rx irq handler
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iRxHandler)&0x18)                 ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
000D   2189               M                                         call    iRxHandler
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRxHan
                            dler
                          M                                                 call    iRxHandler ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iRxHandle
                            r
                          M                                                 call    iRxHandler
                          M                                         endif
                          M                                 endif
                      00019                                 pcall   iSkipRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 12


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iSkipRx)&0x18)                    ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
000E   2046               M                                         call    iSkipRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iSkipR
                            x
                          M                                                 call    iSkipRx ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iSkipRx
                          M                                                 call    iSkipRx
                          M                                         endif
                          M                                 endif
                      00020 
                      00021         
000F   1E0C           00022 iTestTxIrq              btfss   PIR1,TXIF               ; test for serial transmit interrupt
0010   2814           00023                                 goto    iTestTimer2             ; nope check next interrupt source
                      00024                                 pcall   iTxHandler              ; tx irq handler
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iTxHandler)&0x18)                 ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0011   2174               M                                         call    iTxHandler
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iTxHan
                            dler
                          M                                                 call    iTxHandler ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iTxHandle
                            r
                          M                                                 call    iTxHandler
                          M                                         endif
                          M                                 endif
0012   0183           00025                                 clrf    STATUS
0013   120C           00026                                 bcf             PIR1,TXIF               ; clear tx int flag
                      00027 
0014   1C8C           00028 iTestTimer2             btfss   PIE1,TMR2IE             ; test if timer2 500Hz interrupt is enabled
0015   2835           00029                                 goto    iExit                   ; no, so exit ISR
0016   1283           00030                                 bcf             STATUS,RP0              ; select SFR bank
0017   1C8C           00031                                 btfss   PIR1,TMR2IF             ; test if timer2 rollover occured
0018   2835           00032                                 goto    iExit                   ; no so exit isr
0019   108C           00033                                 bcf             PIR1,TMR2IF             ; clear timer2 H/W flag
                      00034         
001A   1074           00035                                 bcf             time,0                  ; make sure bit 0 is zero       
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 13


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                                            
001B   0AF4           00036                                 incf    time,f
001C   0AF4           00037                                 incf    time,f                  ; simulate 1kHz timebase with 500Hz inte
                            rrupt
001D   1D03 2829      00038                                 bnz             iTimeEnd
001F   0AF5           00039                                 incf    time+1,f
0020   1D03 2829      00040                                 bnz             iTimeEnd
0022   0AF6           00041                                 incf    time+2,f
0023   1D03 2829      00042                                 bnz             iTimeEnd
0025   0AF7           00043                                 incf    time+3,f
0026   1D03 2829      00044                                 bnz             iTimeEnd
0028   0AF8           00045                                 incf    time+4,f
                      00046 
0029   0AD4           00047 iTimeEnd                incf    iCount,f
                      00048                                 pcall   iDisplay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iDisplay)&0x18)                   ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
002A   2054               M                                         call    iDisplay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iDispl
                            ay
                          M                                                 call    iDisplay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iDisplay
                          M                                                 call    iDisplay
                          M                                         endif
                          M                                 endif
                      00049                                 pcall   iHeartBeat
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iHeartBeat)&0x18)                 ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
002B   213A               M                                         call    iHeartBeat
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iHeart
                            Beat
                          M                                                 call    iHeartBeat ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iHeartBea
                            t
                          M                                                 call    iHeartBeat
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 14


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         endif
                          M                                 endif
                      00050                                 pcall   iOutput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iOutput)&0x18)                    ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
002C   20E1               M                                         call    iOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iOutpu
                            t
                          M                                                 call    iOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iOutput
                          M                                                 call    iOutput
                          M                                         endif
                          M                                 endif
                      00051                                         
002D   0854           00052                                 movfw   iCount
002E   3907           00053                                 andlw   0x07
002F   1D03 2835      00054                                 bnz             iExit
                      00055                 
                      00056                                 pcall   iGetInput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iGetInput)&0x18)                  ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0031   209C               M                                         call    iGetInput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iGetIn
                            put
                          M                                                 call    iGetInput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iGetInput
                          M                                                 call    iGetInput
                          M                                         endif
                          M                                 endif
                      00057                                 pcall   iDebounce
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iDebounce)&0x18)                  ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 15


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0032   20B7               M                                         call    iDebounce
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iDebou
                            nce
                          M                                                 call    iDebounce ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iDebounce
                          M                                                 call    iDebounce
                          M                                         endif
                          M                                 endif
                      00058                                 pcall   iQueueMsg
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iQueueMsg)&0x18)                  ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0033   213B               M                                         call    iQueueMsg
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iQueue
                            Msg
                          M                                                 call    iQueueMsg ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iQueueMsg
                          M                                                 call    iQueueMsg
                          M                                         endif
                          M                                 endif
                      00059                                 pcall   iShowState
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iShowState)&0x18)                 ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0034   210C               M                                         call    iShowState
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iShowS
                            tate
                          M                                                 call    iShowState ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iShowStat
                            e
                          M                                                 call    iShowState
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 16


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         endif
                          M                                 endif
                      00060 
                      00061 ;                               movfw   iEdgeAux
                      00062 ;                               andwf   iInputAux,w
                      00063 ;                               bz              iExit
                      00064 ;                               movlw   0x01
                      00065 ;                               xorwf   needCfg,f
                      00066                                 
                      00067 ;                               movlw   0x00
                      00068 ;                               btfsc   needCfg,0
                      00069 ;                               movlw   0x78
                      00070 ;                               movwf   displayram+5
                      00071 ;                               movwf   displayram+7
                      00072 ;                               movwf   displayram+9
                      00073                                 
0035                  00074 iExit
0035   1683 1303      00075                                 banksel TXSTA
0037   1C98           00076                                 btfss   TXSTA,TRMT              ; test for empty transmit shift register
0038   283C           00077                                 goto    iExit1
0039   1283 1303      00078                                 banksel PORTC
003B   1287           00079                                 bcf             PORTC,5                 ; disable RS485 transmitter
                      00080 
003C   0183           00081 iExit1                  clrf    STATUS
003D   0873           00082                                 movf    safedFSR,w              ; get saved fsr reg
003E   0084           00083                                 movwf   FSR                             ; restore       
003F   0872           00084                                 movf    safedPCLATH,w   ; get saved pclath
0040   008A           00085                                 movwf   PCLATH                  ; restore
0041   0E71           00086                                 swapf   safedSTATUS,w   ; get saved status in w 
0042   0083           00087                                 movwf   STATUS                  ; restore status ( and bank )
0043   0EF0           00088                                 swapf   safedW,f                ; reload into self to set status bits
0044   0E70           00089                                 swapf   safedW,w                ; and restore
0045   0009           00090                                 retfie                                  ; return from interrupt
                      00091 ;}
                      00092 
                      00093 
0046                  00094 iSkipRx                 ;{
0046   1283 1303      00095                                 banksel skipRxCnt
0048   08D3           00096                                 tstf    skipRxCnt               ; check if we are still skipping a confi
                            g frame
0049   1903           00097                                 skpnz
004A   0008           00098                                 return
                      00099 
004B   084A           00100                                 movfw   rxNum                   ; check if there is a character in the r
                            ingbuffer
004C   1903           00101                                 skpnz
004D   0008           00102                                 return
                      00103                                 
004E   0AC9           00104                                 incf    rxGetPtr,f              ; increment read pointer
004F   301F           00105                                 movlw   (BUFSIZE)-1             ; BUFSIZE must be to the power of 2
0050   05C9           00106                                 andwf   rxGetPtr,f              ; mask read pointer to get easy wrap aro
                            und
0051   03CA           00107                                 decf    rxNum,f                 ; decrement number of bytes in ringbuffe
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 17


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            r
0052   03D3           00108                                 decf    skipRxCnt,f             ; decrent skip rx counter
0053   2846           00109                                 goto    iSkipRx                 ;}
                      00110 
                      00111 
0054                  00112 iDisplay                ;{
                      00113  if     revision >= 3
0054   1283 1303      00114                                 banksel PORTC
0056   03DA           00115                                 decf    iDisplayCount,f
0057   1D03 285D      00116                                 bnz             iDisplay1
                      00117 
                      00118  if revision >= 4
0059   1706           00119                                 bsf             PORTB,6                 ; reset frame counter
005A   1306           00120                                 bcf             PORTB,6
                      00121  else
                      00122                                 bsf             PORTA,7                 ; reset frame counter
                      00123                                 bcf             PORTA,7
                      00124  endif
                      00125 
005B   3008           00126                                 movlw   0x08
005C   00DA           00127                                 movwf   iDisplayCount   ; reset frame counter
005D   1003           00128 iDisplay1               clrc
005E   0D5A           00129                                 rlf             iDisplayCount,w
005F   3E58           00130                                 addlw   displayram-3
0060   0084           00131                                 movwf   FSR
0061   3003           00132                                 movlw   0x03
0062   0500           00133                                 andwf   INDF,w
0063   00D5           00134                                 movwf   iTemp1
0064   0ED5           00135                                 swapf   iTemp1,f
0065   1683 1703      00136                                 banksel PORTG
0067   30CF           00137                                 movlw   0xcf
0068   0509           00138                                 andwf   PORTG,w
0069   1283 1303      00139                                 banksel iTemp1
006B   04D5           00140                                 iorwf   iTemp1,f                ; col0-1 prepared
                      00141                                 
006C   30FC           00142                                 movlw   0xfc
006D   0500           00143                                 andwf   INDF,w
006E   00D6           00144                                 movwf   iTemp2
006F   1003           00145                                 clrc
0070   0CD6           00146                                 rrf             iTemp2,f
0071   0CD6           00147                                 rrf             iTemp2,f
0072   30C0           00148                                 movlw   0xc0
0073   0506           00149                                 andwf   PORTB,w
0074   04D6           00150                                 iorwf   iTemp2,f                ; col2-7 prepared
                      00151         
0075   0384           00152                                 decf    FSR,f                   ; upper byte of display row
0076   3003           00153                                 movlw   0x03
0077   0500           00154                                 andwf   INDF,w
0078   00D7           00155                                 movwf   iTemp3
0079   0ED7           00156                                 swapf   iTemp3,f
007A   30CF           00157                                 movlw   0xcf
007B   0505           00158                                 andwf   PORTA,w
007C   04D7           00159                                 iorwf   iTemp3,f                ; col8-9 prepared
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 18


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00160         
007D   0855           00161                                 movfw   iTemp1
007E   1683 1703      00162                                 banksel PORTG
0080   0089           00163                                 movwf   PORTG
0081   1283 1303      00164                                 banksel iTemp2
0083   0856           00165                                 movfw   iTemp2
0084   0086           00166                                 movwf   PORTB
0085   0857           00167                                 movfw   iTemp3
0086   0085           00168                                 movwf   PORTA
                      00169 
0087   1607           00170                                 bsf             PORTC,4                 ; increment counter
0088   1207           00171                                 bcf             PORTC,4
                      00172                                 
0089   085A           00173                                 movfw   iDisplayCount
008A   3A01           00174                                 xorlw   0x01
008B   1D03 289B      00175                                 bnz             iDisplay2
                      00176 
008D   0C75           00177                                 rrf             time+1,w
008E   00D5           00178                                 movwf   iTemp1
008F   0C74           00179                                 rrf             time,w
0090   00D6           00180                                 movwf   iTemp2
0091   0CD5           00181                                 rrf             iTemp1,f
0092   0C56           00182                                 rrf             iTemp2,w
0093   39FC           00183                                 andlw   0xfc
0094   1903 289B      00184                                 bz              iDisplay2
0096   3C50           00185                                 sublw   0x50
0097   1903 289B      00186                                 bz              iDisplay2
                      00187                                 
0099   1607           00188                                 bsf             PORTC,4                 ; increment counter
009A   1207           00189                                 bcf             PORTC,4
                      00190                                 
009B                  00191 iDisplay2
                      00192  endif                  
009B   0008           00193                                 return  ;}
                      00194 
009C                  00195 iGetInput               ;{
                      00196  if     revision >= 3
                      00197 ; get input of port1
009C   1283 1303      00198                                 banksel iInSampleLo
009E   0808           00199                                 movfw   PORTD
009F   00A1           00200                                 movwf   iInSampleLo
                      00201 
                      00202 ; get input of port 1 low nibble
00A0   1683 1703      00203                                 banksel PORTF
00A2   0E08           00204                                 swapf   PORTF,w
00A3   1283 1303      00205                                 banksel iInSampleHi
00A5   39F0           00206                                 andlw   0xf0
00A6   00A2           00207                                 movwf   iInSampleHi
                      00208         
                      00209 ; get input of port 2 high nibble
00A7   1683 1703      00210                                 banksel PORTG
00A9   0809           00211                                 movfw   PORTG
00AA   1283 1303      00212                                 banksel iInSampleHi
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 19


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00AC   390F           00213                                 andlw   0x0f
00AD   04A2           00214                                 iorwf   iInSampleHi,f
                      00215 ; get input of aux port
00AE   1283 1303      00216                                 banksel PORTB
00B0   3000           00217                                 movlw   0x00
00B1   1F86           00218                                 btfss   PORTB,7
00B2   3001           00219                                 movlw   0x01
00B3   1283 1303      00220                                 banksel iInSampleAux
00B5   00A3           00221                                 movwf   iInSampleAux
                      00222                                 
                      00223  else   ; revision 2
                      00224 ; get input of port1 low nibble
                      00225                                 banksel iInSampleLo
                      00226                                 clrf    iInSampleLo
                      00227                                 movfw   PORTD
                      00228                                 andlw   0xf0
                      00229                                 movwf   iInSampleLo
                      00230 
                      00231 ; get input of port 1 high nibble
                      00232                                 banksel PORTG
                      00233                                 movfw   PORTG
                      00234                                 banksel iInSampleLo
                      00235                                 andlw   0x0f
                      00236                                 iorwf   iInSampleLo,f
                      00237                                 swapf   iInSampleLo,f   ; swap to nibbles into the right place
                      00238                                 comf    iInSampleLo,f   ; inverted logic
                      00239 
                      00240 ; get input of port 2 high nibble
                      00241                                 clrf    iInSampleHi
                      00242                                 movfw   PORTB
                      00243                                 andlw   0x0f
                      00244                                 movwf   iInSampleHi
                      00245                                 swapf   iInSampleHi,f
                      00246 
                      00247 ; get input of port 2 low nibble
                      00248                                 banksel PORTF
                      00249                                 movfw   PORTF
                      00250                                 banksel iInSampleHi
                      00251                                 andlw   0x0f
                      00252                                 iorwf   iInSampleHi,f
                      00253                                 comf    iInSampleHi,f   ; inverted logic
                      00254  endif
00B6   0008           00255                                 return  ;}
                      00256 
00B7                  00257 iDebounce               ;{
                      00258 ; debounces the input 1 by waiting 4 cycles before assuming an input has changed
                      00259 ; using a vertical counter http://www.dattalo.com/technical/software/pic/iDebounce.html
                      00260 
00B7   1283 1303      00261                                 banksel iDebounceLoA
00B9   082D           00262                                 movfw   iDebounceLoB    ; Increment the vertical counter
00BA   06AA           00263                                 xorwf   iDebounceLoA,f
00BB   09AD           00264                                 comf    iDebounceLoB,f
                      00265                 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 20


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00BC   0821           00266                                 movfw   iInSampleLo             ; See if any changes occurred
00BD   0624           00267                                 xorwf   iInputLo,w
                      00268                 
00BE   05AD           00269                                 andwf   iDebounceLoB,f  ; Reset the counter if no change has occurred
00BF   05AA           00270                                 andwf   iDebounceLoA,f
                      00271 
                      00272 ;If there is a pending change and the count has
                      00273 ;rolled over to 0, then the change has been filtered
00C0   3AFF           00274                                 xorlw   0xff                    ; Invert the changes
00C1   042A           00275                                 iorwf   iDebounceLoA,w  ; If count is 0, both A and B
00C2   042D           00276                                 iorwf   iDebounceLoB,w  ; bits are 0
                      00277 
                      00278 ;Any bit in W that is clear at this point means that the input
                      00279 ;has changed and the count has rolled over.
                      00280 
00C3   3AFF           00281                                 xorlw   0xff                    ; Now W holds the state of inputs that h
                            ave just been filtered to a new state. Update the changes:
00C4   06A4           00282                                 xorwf   iInputLo,f
00C5   00A7           00283                                 movwf   iEdgeLo                 ; detected edges (state changes)
                      00284                 
00C6   082E           00285                                 movfw   iDebounceHiB    ; Increment the vertical counter
00C7   06AB           00286                                 xorwf   iDebounceHiA,f
00C8   09AE           00287                                 comf    iDebounceHiB,f
                      00288                 
00C9   0822           00289                                 movfw   iInSampleHi             ; See if any changes occurred
00CA   0625           00290                                 xorwf   iInputHi,w
                      00291                 
00CB   05AE           00292                                 andwf   iDebounceHiB,f  ; Reset the counter if no change has occurred
00CC   05AB           00293                                 andwf   iDebounceHiA,f
                      00294 
                      00295 ;If there is a pending change and the count has
                      00296 ;rolled over to 0, then the change has been filtered
00CD   3AFF           00297                                 xorlw   0xff                    ; Invert the changes
00CE   042B           00298                                 iorwf   iDebounceHiA,w  ; If count is 0, both A and B
00CF   042E           00299                                 iorwf   iDebounceHiB,w  ; bits are 0
                      00300 
                      00301 ;Any bit in W that is clear at this point means that the input
                      00302 ;has changed and the count has rolled over.
                      00303 
00D0   3AFF           00304                                 xorlw   0xff                    ; Now W holds the state of inputs that h
                            ave just been filtered to a new state. Update the changes:
00D1   06A5           00305                                 xorwf   iInputHi,f      
00D2   00A8           00306                                 movwf   iEdgeHi                 ; detected edges (state changes)
                      00307                 
00D3   082F           00308                                 movfw   iDebounceAuxB   ; Increment the vertical counter
00D4   06AC           00309                                 xorwf   iDebounceAuxA,f
00D5   09AF           00310                                 comf    iDebounceAuxB,f
                      00311                 
00D6   0823           00312                                 movfw   iInSampleAux    ; See if any changes occurred
00D7   0626           00313                                 xorwf   iInputAux,w
                      00314                 
00D8   05AF           00315                                 andwf   iDebounceAuxB,f ; Reset the counter if no change has occurred
00D9   05AC           00316                                 andwf   iDebounceAuxA,f
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 21


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00317 
                      00318 ;If there is a pending change and the count has
                      00319 ;rolled over to 0, then the change has been filtered
00DA   3AFF           00320                                 xorlw   0xff                    ; Invert the changes
00DB   042C           00321                                 iorwf   iDebounceAuxA,w ; If count is 0, both A and B
00DC   042F           00322                                 iorwf   iDebounceAuxB,w ; bits are 0
                      00323 
                      00324 ;Any bit in W that is clear at this point means that the input
                      00325 ;has changed and the counter has rolled over.
                      00326 
00DD   3AFF           00327                                 xorlw   0xff                    ; now W holds the state of inputs that h
                            ave just been filtered to a new state. Update the changes:
00DE   06A6           00328                                 xorwf   iInputAux,f     
00DF   00A9           00329                                 movwf   iEdgeAux                ; detected edges (state changes)
                      00330                 
00E0   0008           00331                                 return  ;}
                      00332         
00E1                  00333 iOutput                 ;{
00E1   1283 1303      00334                                 banksel PORTC
00E3   0807           00335                                 movfw   PORTC
00E4   39F0           00336                                 andlw   0xf0                    ; keep other OUTPUT pins' status
00E5   00D5           00337                                 movwf   iTemp1
00E6   0832           00338                                 movfw   outputLo                ; get lower part of OUTPUT
00E7   215A           00339                                 call    iReverseNibble
00E8   0455           00340                                 iorwf   iTemp1,w
00E9   0087           00341                                 movwf   PORTC
                      00342                                 
00EA   1683 1703      00343                                 banksel PORTF
00EC   0808           00344                                 movfw   PORTF
00ED   390F           00345                                 andlw   0x0f                    ; keep other OUTPUT pins' status
00EE   1283 1303      00346                                 banksel iTemp1
00F0   00D5           00347                                 movwf   iTemp1
00F1   0E32           00348                                 swapf   outputLo,w              ; get upper part of OUTPUT
00F2   215A           00349                                 call    iReverseNibble
00F3   0ED5           00350                                 swapf   iTemp1,f
00F4   04D5           00351                                 iorwf   iTemp1,f
00F5   0E55           00352                                 swapf   iTemp1,w
00F6   1683 1703      00353                                 banksel PORTF
00F8   0088           00354                                 movwf   PORTF
                      00355                 
00F9   1283 1303      00356                                 banksel PORTE
00FB   0809           00357                                 movfw   PORTE
00FC   390F           00358                                 andlw   0x0f
00FD   00D5           00359                                 movwf   iTemp1
00FE   0833           00360                                 movfw   outputHi                ; get lower part of OUTPUT
00FF   215A           00361                                 call    iReverseNibble
0100   0ED5           00362                                 swapf   iTemp1,f
0101   04D5           00363                                 iorwf   iTemp1,f
0102   0E55           00364                                 swapf   iTemp1,w
0103   0089           00365                                 movwf   PORTE
                      00366                 
0104   0805           00367                                 movfw   PORTA
0105   39F0           00368                                 andlw   0xf0
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 22


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0106   00D5           00369                                 movwf   iTemp1
0107   0E33           00370                                 swapf   outputHi,w              ; get upper part of OUTPUT
0108   215A           00371                                 call    iReverseNibble
0109   0455           00372                                 iorwf   iTemp1,w
010A   0085           00373                                 movwf   PORTA
                      00374                 
010B   0008           00375                                 return  ;}
                      00376                         
010C                  00377 iShowState              ;{
                      00378  if     revision >= 3
010C   1003           00379                                 clrc
010D   01E5           00380                                 clrf    displayram+0x0a
010E   01E6           00381                                 clrf    displayram+0x0b
010F   0824           00382                                 movfw   iInputLo
                      00383                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0110   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
0111   00E6           00384                                 movwf   displayram+0x0b
0112   0EE6           00385                                 swapf   displayram+0x0b,f
0113   0E24           00386                                 swapf   iInputLo,w
                      00387                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0114   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 23


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
0115   04E6           00388                                 iorwf   displayram+0x0b,f       
0116   0DE6           00389                                 rlf             displayram+0x0b,f
0117   0DE5           00390                                 rlf             displayram+0x0a,f
0118   0DE6           00391                                 rlf             displayram+0x0b,f
0119   0DE5           00392                                 rlf             displayram+0x0a,f
                      00393         
011A   01E7           00394                                 clrf    displayram+0x0c
011B   01E8           00395                                 clrf    displayram+0x0d
011C   0825           00396                                 movfw   iInputHi
                      00397                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
011D   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
011E   00E8           00398                                 movwf   displayram+0x0d
011F   0EE8           00399                                 swapf   displayram+0x0d,f
0120   0E25           00400                                 swapf   iInputHi,w
                      00401                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0121   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 24


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
0122   04E8           00402                                 iorwf   displayram+0x0d,f       
                      00403                                 
0123   1003           00404                                 clrc
0124   01DB           00405                                 clrf    displayram+0x00
0125   01DC           00406                                 clrf    displayram+0x01
0126   0832           00407                                 movfw   outputLo
                      00408                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0127   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
0128   00DC           00409                                 movwf   displayram+0x01
0129   0EDC           00410                                 swapf   displayram+0x01,f
012A   0E32           00411                                 swapf   outputLo,w
                      00412                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
012B   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
                          M                                         else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 25


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
012C   04DC           00413                                 iorwf   displayram+0x01,f       
012D   0DDC           00414                                 rlf             displayram+0x01,f
012E   0DDB           00415                                 rlf             displayram+0x00,f
012F   0DDC           00416                                 rlf             displayram+0x01,f
0130   0DDB           00417                                 rlf             displayram+0x00,f
                      00418         
0131   01DD           00419                                 clrf    displayram+0x02
0132   0833           00420                                 movfw   outputHi
                      00421                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0133   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
0134   00DE           00422                                 movwf   displayram+0x03
0135   0EDE           00423                                 swapf   displayram+0x03,f
0136   0E33           00424                                 swapf   outputHi,w
                      00425                                 pcall   iReverseNibble
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000000                M DEST_HIGH               set     (HIGH(iReverseNibble)&0x18)             ; save bits 4:5 of dest adress
  00000000                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0137   215A               M                                         call    iReverseNibble
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", iRever
                            seNibble
                          M                                                 call    iReverseNibble ; INCORRECT Call !!!
                          M                                         else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 26


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with scall", iReverseN
                            ibble
                          M                                                 call    iReverseNibble
                          M                                         endif
                          M                                 endif
0138   04DE           00426                                 iorwf   displayram+0x03,f       
                      00427         
                      00428 ;                               bcf             displayram+0x07,4
                      00429 ;                               bcf             displayram+0x07,5
                      00430 ;                               rrf             TIME+1,w
                      00431 ;                               movwf   iTemp1
                      00432 ;                               rrf             TIME,w
                      00433 ;                               movwf   iTemp2
                      00434 ;                               rrf             iTemp1,f
                      00435 ;                               rrf             iTemp2,f
                      00436 ;                               swapf   iTemp2,w
                      00437 ;                               andlw   0x0f
                      00438 ;                               bnz             iShowState1
                      00439 ;                               bsf             displayram+0x07,4
                      00440 ;                               bsf             displayram+0x07,5
                      00441 ;iShowState1            sublw   0x05
                      00442 ;                               bnz             iShowState2
                      00443 ;                               bsf             displayram+0x07,4
                      00444 ;                               bsf             displayram+0x07,5
                      00445  endif
0139                  00446 iShowState2;            movlw   0x00
                      00447 ;                               btfsc   iInputAux,0
                      00448 ;                               movlw   0xff
                      00449 ;                               movwf   displayram+0x04
                      00450 ;                               movwf   displayram+0x05
                      00451 ;                               movfw   RXPUTPTR                        ;xx
                      00452 ;                               movwf   displayram+0x05         ;xx
                      00453 ;                               movfw   RXGETPTR                        ;xx
                      00454 ;                               movwf   displayram+0x09         ;xx
                      00455 ;                               movfw   RXNUM                           ;xx
                      00456 ;                               movwf   displayram+0x07         ;xx
0139   0008           00457                                 return  ;}
                      00458 
                      00459 
013A                  00460 iHeartBeat              ;{
                      00461  if     revision >= 3
013A   0008           00462                                 return
                      00463  else
                      00464                                 banksel PORTB
                      00465                                 movwf   PORTB
                      00466                                 andlw   0xcf
                      00467                                 movfw   iTemp3
                      00468                                 pcall   HEARTCODE
                      00469                                 iorwf   iTemp3,w
                      00470                                 movwf   PORTB
                      00471                                 return
                      00472         
                      00473 HEARTCODE
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 27


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00474                                 rrf             time+1,w
                      00475                                 movwf   iTemp1
                      00476                                 rrf             time,w
                      00477                                 movwf   iTemp2
                      00478                                 rrf             iTemp1,f
                      00479                                 rrf             iTemp2,f
                      00480                                 swapf   iTemp2,w
                      00481                                 andlw   0x0f
                      00482                                 itabj
                      00483                                 retlw   0x10
                      00484                                 retlw   0x00
                      00485                                 retlw   0x00
                      00486                                 retlw   0x00
                      00487                                 retlw   0x00
                      00488                                 retlw   0x20
                      00489                                 retlw   0x00
                      00490                                 retlw   0x00
                      00491                                 retlw   0x00
                      00492                                 retlw   0x00
                      00493                                 retlw   0x00
                      00494                                 retlw   0x00
                      00495                                 retlw   0x00
                      00496                                 retlw   0x00
                      00497                                 retlw   0x00
                      00498                                 retlw   0x00
                      00499  endif                  ;}
                      00500  
                      00501   
013B                  00502 iQueueMsg               ;{
013B   1283 1303      00503                                 banksel iEdgeLo
013D   0827           00504                                 movfw   iEdgeLo                 ; test for any changes
013E   0428           00505                                 iorwf   iEdgeHi,w
013F   1903           00506                                 skpnz                                   
0140   0008           00507                                 return                                  ; deflect when no change occurre
                            d
                      00508                                 
0141   084D           00509                                 movfw   msgNum                  
0142   3A10           00510                                 xorlw   MSGBUFSIZE              ; check if there is free space in the ri
                            ngbuffer
0143   1903           00511                                 skpnz   
0144   0008           00512                                 return                                  ; discard if buffer full
                      00513                                 
0145   084B           00514                                 movfw   msgPutPtr               ; current write pointer
0146   3EE0           00515                                 addlw   LOW(msgBuf)             ; base adress of tx buffer
0147   0084           00516                                 movwf   FSR                             ; set FSR to current write posit
                            ion
0148   1383           00517                                 bankisel        msgBuf
                      00518                                 movff   iInputLo,INDF   ; store into ringbuffer
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
0149   0824               M                                 movfw   iInputLo
014A   0080               M                                 movwf   INDF
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 28


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

014B   0A84           00519                                 incf    FSR,f
                      00520                                 movff   iInputHi,INDF   ; store into ringbuffer
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
014C   0825               M                                 movfw   iInputHi
014D   0080               M                                 movwf   INDF
014E   0A84           00521                                 incf    FSR,f
                      00522                                 movff   iEdgeLo,INDF    ; store into ringbuffer
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
014F   0827               M                                 movfw   iEdgeLo
0150   0080               M                                 movwf   INDF
0151   0A84           00523                                 incf    FSR,f
                      00524                                 movff   iEdgeHi,INDF    ; store into ringbuffer
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
0152   0828               M                                 movfw   iEdgeHi
0153   0080               M                                 movwf   INDF
0154   3004           00525                                 movlw   0x04
0155   07CD           00526                                 addwf   msgNum,f                ; increment number of bytes in ringbuffe
                            r
0156   07CB           00527                                 addwf   msgPutPtr,f             ; increment write pointer by 4
0157   300F           00528                                 movlw   (MSGBUFSIZE)-1  ; MSGBUFSIZE must be a power of 2
0158   05CB           00529                                 andwf   msgPutPtr,f             ; mask write pointer to get easy wrap ar
                            ound
0159   0008           00530                                 return  ;}
                      00531                                 
015A                  00532 iReverseNibble  ;{
015A   390F           00533                                 andlw   0x0f
                      00534                                 itabj
                          M ;{
                          M ;       TABLE_JUMP Calculates an eventual table boundary crossing  
                          M ;       sets up the PCLATH register correctly
                          M ;       Offset must be in w-reg, offset 0 jumps to the next instr. 
015B   00FA               M                                 movwf   iTabTemp                ; save wanted offset
015C   3064               M                                 movlw   LOW($+8)                ; get low adress ( of first instr. after
                             macro )
015D   07FA               M                                 addwf   iTabTemp,f              ; add offset
015E   3001               M                                 movlw   HIGH($+6)               ; get highest 5 bits ( of first instr. a
                            fter macro )
015F   1803               M                                 skpnc                                   ; page crossed ? ( 256 byte )
0160   3E01               M                                 addlw   0x01                    ; Yes add one to high adress
0161   008A               M                                 movwf   PCLATH                  ; load high adress in latch
0162   087A               M                                 movf    iTabTemp,w              ; get computed adress
0163   0082               M                                 movwf   PCL                             ; And jump
0164   3400           00535                                 retlw   0x00            ; 0x00
0165   3408           00536                                 retlw   0x08            ; 0x01
0166   3404           00537                                 retlw   0x04            ; 0x02
0167   340C           00538                                 retlw   0x0c            ; 0x03
0168   3402           00539                                 retlw   0x02            ; 0x04
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 29


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0169   340A           00540                                 retlw   0x0a            ; 0x05
016A   3406           00541                                 retlw   0x06            ; 0x06
016B   340E           00542                                 retlw   0x0e            ; 0x07
016C   3401           00543                                 retlw   0x01            ; 0x08
016D   3409           00544                                 retlw   0x09            ; 0x09
016E   3405           00545                                 retlw   0x05            ; 0x0a
016F   340D           00546                                 retlw   0x0d            ; 0x0b
0170   3403           00547                                 retlw   0x03            ; 0x0c
0171   340B           00548                                 retlw   0x0b            ; 0x0d
0172   3407           00549                                 retlw   0x07            ; 0x0e
0173   340F           00550                                 retlw   0x0f            ; 0x0f
                      00551 ;}
                      00552 
0174                  00553 iTxHandler              ;{
                      00554 ; ===============================================================
                      00555 ;  iTxHandler - handles the transmission of bytes on serial com 
                      00556 ;  called on transmitter and cyclic interrupt.
                      00557 ;  recovers byte from ringbuffer
                      00558 ; ===============================================================
0174   1283 1303      00559                                 banksel txNum
0176   08C7           00560                                 tstf    txNum                   ; check if there is a character in the r
                            ingbuffer
0177   1903 2985      00561                                 bz              iTxHandler1
                      00562                                 
0179   0846           00563                                 movfw   txGetPtr                ; current read pointer
017A   3EC0           00564                                 addlw   LOW(txBuf)              ; base adress of tx buffer
017B   0084           00565                                 movwf   FSR                             ; set FSR to current read positi
                            on
017C   1383           00566                                 bankisel        txBuf
017D   0800           00567                                 movfw   INDF                    ; store get char from ringbuffer
017E   1687           00568                                 bsf             PORTC,5                 ; enable RS485 transmitter
017F   0099           00569                                 movwf   TXREG                   ; send char
0180   0AC6           00570                                 incf    txGetPtr,f              ; increment read pointer
0181   301F           00571                                 movlw   (BUFSIZE)-1             ; BUFSIZE must be to the power of 2
0182   05C6           00572                                 andwf   txGetPtr,f              ; mask read pointer to get easy wrap aro
                            und
0183   03C7           00573                                 decf    txNum,f                 ; increment number of bytes in ringbuffe
                            r
0184   0008           00574                                 return
                      00575                                 
0185   308C           00576 iTxHandler1             movlw   PIE1                    ; get adress for tx irq enable
0186   0084           00577                                 movwf   FSR                             ; setup fsr
0187   1200           00578                                 bcf             INDF,TXIE               ; and disable tx irq
0188   0008           00579                                 return  ;}
                      00580 
                      00581 
0189                  00582 iRxHandler      ;{
0189   1E8C           00583                                 btfss   PIR1,RCIF               ; test for serial receive interrupt
018A   0008           00584                                 return
                      00585 
018B   1283 1303      00586                                 banksel RCSTA
018D   1C98           00587                                 btfss   RCSTA,OERR              ; test for overrun error
018E   2991           00588                                 goto    rxCheckFraming  ; when overrun, uart will stop receving the cont
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 30


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            inous 
                      00589                                                                                 ; recevive bit must then
                             be reset
018F   1218           00590                                 bcf             RCSTA,CREN              ; clear continous receive bit
0190   1618           00591                                 bsf             RCSTA,CREN              ; and set it again
                      00592 
0191                  00593 rxCheckFraming
0191   1918           00594                                 btfsc   RCSTA,FERR              ; check from framing errors
0192   29A2           00595                                 goto    rxDiscardByte   ; framing error do not store this byte
                      00596                                                                                 ; read rx reg and discar
                            d byte
0193                  00597 rxCheckBuffer
0193   084A           00598                                 movfw   rxNum
0194   3EE1           00599                                 addlw   -BUFSIZE+1              ; check if there is free space in the ri
                            ngbuffer        
0195   1903 29A2      00600                                 bz              rxBufferFull
                      00601 
0197   0848           00602                                 movfw   rxPutPtr                ; current write pointer
0198   3EA0           00603                                 addlw   LOW(rxBuf)              ; base adress of tx buffer
0199   0084           00604                                 movwf   FSR                             ; set FSR to current write posit
                            ion
019A   1383           00605                                 bankisel        rxBuf
                      00606                                 movff   RCREG,INDF              ; store char into ringbuffer
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
019B   081A               M                                 movfw   RCREG
019C   0080               M                                 movwf   INDF
019D   0ACA           00607                                 incf    rxNum,f                 ; increment number of bytes in ringbuffe
                            r
019E   0AC8           00608                                 incf    rxPutPtr,f              ; increment write pointer
019F   301F           00609                                 movlw   (BUFSIZE)-1             ; BUFSIZE must be to the power of 2
01A0   05C8           00610                                 andwf   rxPutPtr,f              ; mask write pointer to get easy wrap ar
                            ound
01A1   0008           00611                                 return
                      00612                         
01A2                  00613 rxBufferFull                                                    ; no room for more bytes, set overrun fl
                            ag
                      00614 ;                               bsf             _BufferOverrun
01A2                  00615 rxDiscardByte                                                   ; optional an error flag could be set to
                             indicate comm error.
01A2   089A           00616                                 tstf    RCREG                   ; read byte and discard
01A3   0008           00617                                 return  ;}
                      00032 #include                <iutils.asm>
                      00033                                 ;{
0800                  00034                                 org             0x0800                  ; second page
0800                  00035 main
0800   0183           00036                                 clrf    STATUS                  ; ensure we are at bank0        
0801   018B           00037                                 clrf    INTCON                  ; ensure int reg is clear  
0802   018C           00038                                 clrf    PIR1                    ; clear periphial irqs
0803   018D           00039                                 clrf    PIR2                    ; dito
                      00040                         
                      00041                                 ; make sure all individual irqs are disabled
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 31


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0804   308C           00042                                 movlw   PIE1                    ; get adress for peripheral irq enable
0805   0084           00043                                 movwf   FSR                             ; setup fsr
0806   0180           00044                                 clrf    INDF                    ; and clear irq enable flags
                      00045                 
0807   308D           00046                                 movlw   PIE2                    ; get adress for second peripheral irq e
                            nable
0808   0084           00047                                 movwf   FSR                             ; setup fsr
0809   0180           00048                                 clrf    INDF                    ; and clear irq enable flags
                      00049                 
080A   1683 1303      00050                                 banksel OSCCON
080C   3071           00051                                 movlw   0x71                    ; speedup to 8 MHz
080D   008F           00052                                 movwf   OSCCON
                      00053                                 
                      00054                                 scall   initPorts
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(initPorts)&0x18)                  ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", initPorts
                          M                                         nop             ; redundant nops
                          M                                         call    initPorts
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", initPo
                            rts
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_25DEST_HIGH&0x10)
080E   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
080F   2000               M                                                 call    initPorts
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_25SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 32


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0810   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    initPorts
                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
                      00055                                 scall   clearRam
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(clearRam)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", clearRam
                          M                                         nop             ; redundant nops
                          M                                         call    clearRam
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", clearR
                            am
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_28DEST_HIGH&0x10)
0811   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
0812   2045               M                                                 call    clearRam
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_28SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0813   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    clearRam
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 33


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
                      00056                                 scall   initParams
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(initParams)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", initParam
                            s
                          M                                         nop             ; redundant nops
                          M                                         call    initParams
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", initPa
                            rams
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_31DEST_HIGH&0x10)
0814   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
0815   20AE               M                                                 call    initParams
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_31SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0816   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    initParams
                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
                      00057                                 scall   initTimer0
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 34


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(initTimer0)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", initTimer
                            0
                          M                                         nop             ; redundant nops
                          M                                         call    initTimer0
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", initTi
                            mer0
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_34DEST_HIGH&0x10)
0817   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
0818   2080               M                                                 call    initTimer0
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_34SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0819   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    initTimer0
                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
                      00058 ;                               scall   initTimer1
                      00059                                 scall   initTimer2
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 35


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(initTimer2)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", initTimer
                            2
                          M                                         nop             ; redundant nops
                          M                                         call    initTimer2
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", initTi
                            mer2
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_37DEST_HIGH&0x10)
081A   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
081B   2097               M                                                 call    initTimer2
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_37SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
081C   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    initTimer2
                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
                      00060                                 scall   initUart
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(initUart)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 36


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", initUart
                          M                                         nop             ; redundant nops
                          M                                         call    initUart
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", initUa
                            rt
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_40DEST_HIGH&0x10)
081D   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
081E   206F               M                                                 call    initUart
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_40SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
081F   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    initUart
                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
                      00061                                 scall   initPlvd
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(initPlvd)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", initPlvd
                          M                                         nop             ; redundant nops
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 37


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         call    initPlvd
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", initPl
                            vd
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_43DEST_HIGH&0x10)
0820   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
0821   20A8               M                                                 call    initPlvd
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_43SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0822   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    initPlvd
                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
                      00062                                 enableirq
0823   178B               M                                 bsf             INTCON,GIE              ; enable global interrupt
                      00063 
0824   1283 1303      00064                                 banksel funcUber
0826   1744           00065                                 bsf             funcUber,6              ; call function dispatcher in se
                            rvice mode
                      00066                                 pcall   dispatch
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(dispatch)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0827   2124               M                                         call    dispatch
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 38


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with longcall", dispat
                            ch
                          M                                                 call    dispatch ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", dispatch
                          M                                                 call    dispatch
                          M                                         endif
                          M                                 endif
                      00067 
0828                  00068 parseRx 
                      00069 ;                               banksel PIR2
                      00070 ;                               btfsc   PIR2,LVDIF              ; detect low voltage 
                      00071 ;                               goto    powerDown
                      00072 
0828   0852           00073                                 movfw   cfgTxCnt                ; check if we are still sending a config
                             frame
0829   1903 283B      00074                                 bz              parseRx0
                      00075 
082B   0847           00076                                 movfw   txNum           
082C   3A20           00077                                 xorlw   BUFSIZE                 ; check if there is free space in the ri
                            ngbuffer
082D   1903 283B      00078                                 bz              parseRx0                ; wait for free space
                      00079                                 
082F   0852           00080                                 movfw   cfgTxCnt
                      00081                                 longcall        eeRead          ; read config eeprom
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_48DEST_HIGH&0x10)
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 39


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0830   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_48DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
0831   118A               M                                         bcf     PCLATH,3
                          M                                 endif
0832   200E               M                                                 call    eeRead          
                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_48SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0833   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_48SOURCE_HIGH&0x08)
0834   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
0835   1283 1303      00082                                 banksel cfgTxCnt
                      00083                                 pcall   putTx                   ; send config
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 40


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0837   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0838   1283 1303      00084                                 banksel cfgTxCnt
083A   0AD2           00085                                 incf    cfgTxCnt,f              ; increment config transmit counter
                      00086 
083B   0853           00087 parseRx0                movfw   skipRxCnt               ; check if we are still skipping a config frame
083C   1D03 2828      00088                                 bnz             parseRx                 ; don't read other commands
                      00089 
083E   0834           00090                                 movfw   rxCount
083F   3A00           00091                                 xorlw   0x00
0840   1D03 2849      00092                                 bnz             parseRx1
                      00093 
                      00094                                 pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0842   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0843   1903 28BE      00095                                 bz              parseRxX
                      00096 
0845   3A00           00097                                 xorlw   STARTBYTE               ; check if byte0 == 0
0846   1903           00098                                 skpnz
0847   0AB4           00099                                 incf    rxCount,f
0848   0834           00100                                 movfw   rxCount
                      00101 
0849   3A01           00102 parseRx1                xorlw   0x01
084A   1D03 2855      00103                                 bnz             parseRx2
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 41


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00104 
                      00105                                 pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
084C   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
084D   1903 28BE      00106                                 bz              parseRxX
                      00107 
084F   00B5           00108                                 movwf   rxByte1                 ; store byte1
0850   08B5           00109                                 tstf    rxByte1
0851   1903 28BD      00110                                 bz              parseRxE
0853   0AB4           00111                                 incf    rxCount,f
0854   0834           00112                                 movfw   rxCount
                      00113 
                      00114 parseRx2                pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0855   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0856   1903 28BE      00115                                 bz              parseRxX
                      00116 
0858   00B6           00117                                 movwf   rxByte2                 ; store byte2
                      00118 
0859   0835           00119                                 movfw   rxByte1
085A   39F0           00120                                 andlw   0xf0
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 42


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

085B   3A10           00121                                 xorlw   CMDPEDGE                ; check for positive edge on input (0x1Y
                            )
085C   1903 2861      00122                                 bz              parseRx3                ; positive edge detected
085E   3A30           00123                                 xorlw   CMDPEDGE|CMDNEDGE       ; check for negative edge on input (0x2Y
                            )
085F   1D03 2869      00124                                 bnz             parseRx4                ; no negative edge detected
                      00125 
0861   0835           00126 parseRx3                movfw   rxByte1                 ; edge detected
0862   00B8           00127                                 movwf   rxInput
0863   0836           00128                                 movfw   rxByte2
0864   00B7           00129                                 movwf   rxDevID
0865   01C3           00130                                 clrf    funcSemaphore
                      00131 ;                               clrf    funcService
0866   1344           00132                                 bcf             funcUber,6              ; set message dispatcher to non 
                            service mode
                      00133                                 pcall   dispatch
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(dispatch)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0867   2124               M                                         call    dispatch
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", dispat
                            ch
                          M                                                 call    dispatch ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", dispatch
                          M                                                 call    dispatch
                          M                                         endif
                          M                                 endif
0868   28BD           00134                                 goto    parseRxE
                      00135                                                                                 ; neither positive nor n
                            egative edge
0869   0835           00136 parseRx4                movfw   rxByte1
086A   3A01           00137                                 xorlw   CMDOFF                  ; check for power off command
086B   1903 2D9D      00138                                 bz              fPowerOff
                      00139 
086D   0835           00140                                 movfw   rxByte1
086E   3A02           00141                                 xorlw   CMDRESET                ; check for reset command
086F   1903 2DAB      00142                                 bz              fReset
                      00143 
0871   0835           00144                                 movfw   rxByte1
0872   3A04           00145                                 xorlw   CMDID                   ; check for poll command
0873   1903 2DB5      00146                                 bz              fPoll
                      00147 
0875   0835           00148                                 movfw   rxByte1
0876   3A09           00149                                 xorlw   CMDTSET                 ; check for write time
0877   1903 2E1D      00150                                 bz              fWrTime
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 43


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00151 
0879   0835           00152                                 movfw   rxByte1
087A   3A0A           00153                                 xorlw   CMDTGET                 ; check for read time command
087B   1903 2E08      00154                                 bz              fRdTime
                      00155 
087D   0835           00156                                 movfw   rxByte1
087E   3A0B           00157                                 xorlw   CMDTGACK                ; check for read time answer
087F   1D03 2884      00158                                 bnz             parseRx5
0881   3005           00159                                 movlw   0x05
0882   00D3           00160                                 movwf   skipRxCnt               ; 5 bytes to skip
0883   28BD           00161                                 goto    parseRxE
                      00162 
0884   0835           00163 parseRx5                movfw   rxByte1
0885   3A0C           00164                                 xorlw   CMDCGET                 ; check for read config command
0886   1903 2E3D      00165                                 bz              fRdConfig
                      00166 
0888   0835           00167                                 movfw   rxByte1
0889   3A0E           00168                                 xorlw   CMDCSET                 ; check for write config command
088A   1903 2E4A      00169                                 bz              fWrConfig
                      00170 
088C   0835           00171                                 movfw   rxByte1
088D   3A05           00172                                 xorlw   CMDOWR                  ; check for write outputs command
088E   1903 2E94      00173                                 bz              fWrOutputs
                      00174 
0890   0835           00175                                 movfw   rxByte1
0891   3A06           00176                                 xorlw   CMDIRD                  ; check for read inputs command
0892   1903 2EC7      00177                                 bz              fRdInputs
                      00178 
0894   0835           00179                                 movfw   rxByte1
0895   3A07           00180                                 xorlw   CMDORD                  ; check for read outputs command
0896   1903 2EF5      00181                                 bz              fRdOutputs
                      00182 
0898   0835           00183                                 movfw   rxByte1
0899   3A08           00184                                 xorlw   CMDIOANS                ; check for read inputs/outputs answer
089A   1D03 289F      00185                                 bnz             parseRx6
089C   3002           00186                                 movlw   0x02
089D   00D3           00187                                 movwf   skipRxCnt               ; 2 bytes to skip
089E   28BD           00188                                 goto    parseRxE
                      00189 
089F   0835           00190 parseRx6                movfw   rxByte1
08A0   39F0           00191                                 andlw   0xf0
08A1   3AB0           00192                                 xorlw   CMDI                    ; read input Y on device ID
08A2   1903 2EA8      00193                                 bz              fRdInput
                      00194 
08A4   0835           00195                                 movfw   rxByte1
08A5   39F0           00196                                 andlw   0xf0
08A6   3AA0           00197                                 xorlw   CMDO                    ; read output Y on device ID
08A7   1903 2ED6      00198                                 bz              fRdOutput
                      00199 
08A9   0835           00200                                 movfw   rxByte1
08AA   39F0           00201                                 andlw   0xf0
08AB   3A80           00202                                 xorlw   CMDOC                   ; clear output Y on device ID
08AC   1903 2E7C      00203                                 bz              fCOutput
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 44


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00204 
08AE   0835           00205                                 movfw   rxByte1
08AF   39F0           00206                                 andlw   0xf0
08B0   3A90           00207                                 xorlw   CMDOS                   ; set output Y on device ID
08B1   1903 2E88      00208                                 bz              fSOutput
                      00209 
08B3   0835           00210                                 movfw   rxByte1
08B4   39E0           00211                                 andlw   0xe0
08B5   3A40           00212                                 xorlw   CMDSOFF                 ; check for blinds up/windows close/ligh
                            ts off command
08B6   1903 2DC0      00213                                 bz              fOff
                      00214 
08B8   0835           00215                                 movfw   rxByte1
08B9   39E0           00216                                 andlw   0xe0
08BA   3A60           00217                                 xorlw   CMDSON                  ; check for blinds down/windows open/lig
                            hts on command
08BB   1903 2DE4      00218                                 bz              fOn
                      00219                                 
08BD   01B4           00220 parseRxE                clrf    rxCount
08BE                  00221 parseRxX
08BE   1283 1303      00222                                 banksel funcUber
08C0   1744           00223                                 bsf             funcUber,6              ; call function dispatcher in se
                            rvice mode
                      00224                                 pcall   dispatch
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(dispatch)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
08C1   2124               M                                         call    dispatch
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", dispat
                            ch
                          M                                                 call    dispatch ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", dispatch
                          M                                                 call    dispatch
                          M                                         endif
                          M                                 endif
                      00225                                 
08C2                  00226 mainLoop1
08C2   1283 1303      00227                                 banksel msgNum
08C4   08CD           00228                                 tstf    msgNum                  ; check if there are messages in the rin
                            gbuffer queue
08C5   1903 2918      00229                                 bz              mainLoop2               ; queue is empty
                      00230                                 
08C7   084C           00231                                 movfw   msgGetPtr               ; current queue read pointer
08C8   3EE0           00232                                 addlw   LOW(msgBuf)             ; base adress of message buffer queue
08C9   1383           00233                                 bankisel        msgBuf          
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 45


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

08CA   0084           00234                                 movwf   FSR                             ; set FSR to current queue read 
                            position
                      00235                                 movff   INDF,msgLo              ; get 
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
08CB   0800               M                                 movfw   INDF
08CC   00CE               M                                 movwf   msgLo
08CD   0A84           00236                                 incf    FSR,F
                      00237                                 movff   INDF,msgHi
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
08CE   0800               M                                 movfw   INDF
08CF   00CF               M                                 movwf   msgHi
08D0   0A84           00238                                 incf    FSR,F
08D1   0800           00239                                 movfw   INDF
08D2   05CE           00240                                 andwf   msgLo,F
08D3   0A84           00241                                 incf    FSR,F
08D4   0800           00242                                 movfw   INDF
08D5   05CF           00243                                 andwf   msgHi,F
08D6   044E           00244                                 iorwf   msgLo,W
08D7   1903 28EC      00245                                 bz              genMessage2
                      00246                                 
08D9   30FF           00247                                 movlw   0xff
08DA   00D0           00248                                 movwf   msgID                   ; initialise bit counter
                      00249 
08DB   0AD0           00250 genMessage1             incf    msgID,F
08DC   0850           00251                                 movfw   msgID
08DD   3A10           00252                                 xorlw   0x10
08DE   1903 28EC      00253                                 bz              genMessage2             ; exit if all 16 bits checked
08E0   0CCF           00254                                 rrf             msgHi,F
08E1   0CCE           00255                                 rrf             msgLo,F
08E2   1C03 28DB      00256                                 bnc             genMessage1             ; no change in this bit continue
                             with next
                      00257 
08E4   3000           00258                                 movlw   0x00
                      00259                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
08E5   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 46


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
08E6   0850           00260                                 movfw   msgID
08E7   3810           00261                                 iorlw   0x10                    ; positive edge
                      00262                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
08E8   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
08E9   0820           00263                                 movfw   deviceID
                      00264                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
08EA   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
08EB   28DB           00265                                 goto    genMessage1
                      00266 
08EC   084C           00267 genMessage2             movfw   msgGetPtr               ; current read pointer
08ED   3EE0           00268                                 addlw   LOW(msgBuf)             ; base adress of message buffer
08EE   0084           00269                                 movwf   FSR                             ; set FSR to current read positi
                            on
08EF   0800           00270                                 movfw   INDF
08F0   3AFF           00271                                 xorlw   0xff
08F1   00CE           00272                                 movwf   msgLo
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 47


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

08F2   0A84           00273                                 incf    FSR,F
08F3   0800           00274                                 movfw   INDF
08F4   3AFF           00275                                 xorlw   0xff
08F5   00CF           00276                                 movwf   msgHi
08F6   0A84           00277                                 incf    FSR,F
08F7   0800           00278                                 movfw   INDF
08F8   05CE           00279                                 andwf   msgLo,F
08F9   0A84           00280                                 incf    FSR,F
08FA   0800           00281                                 movfw   INDF
08FB   05CF           00282                                 andwf   msgHi,F
08FC   044E           00283                                 iorwf   msgLo,W
08FD   1903 2912      00284                                 bz              genMessage4
                      00285                                 
08FF   30FF           00286                                 movlw   0xff
0900   00D0           00287                                 movwf   msgID                   ; initialise bit counter
                      00288 
0901   0AD0           00289 genMessage3             incf    msgID,F
0902   0850           00290                                 movfw   msgID
0903   3A10           00291                                 xorlw   0x10
0904   1903 2912      00292                                 bz              genMessage4             ; exit if all 16 bits checked
0906   0CCF           00293                                 rrf             msgHi,F
0907   0CCE           00294                                 rrf             msgLo,F
0908   1C03 2901      00295                                 bnc             genMessage3             ; no change in this bit continue
                             with next
                      00296 
090A   3000           00297                                 movlw   0x00
                      00298                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
090B   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
090C   0850           00299                                 movfw   msgID
090D   3820           00300                                 iorlw   0x20                    ; negative edge
                      00301                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 48


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
090E   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
090F   0820           00302                                 movfw   deviceID
                      00303                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0910   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0911   2901           00304                                 goto    genMessage3
                      00305 
0912   3004           00306 genMessage4             movlw   0x04
0913   07CC           00307                                 addwf   msgGetPtr,F             ; increment write pointer by 4
0914   300F           00308                                 movlw   (MSGBUFSIZE)-1  ; MSGBUFSIZE must be a power of 2
0915   05CC           00309                                 andwf   msgGetPtr,F             ; mask write pointer to get easy wrap ar
                            ound
0916   30FC           00310                                 movlw   -0x04
0917   07CD           00311                                 addwf   msgNum,F                ; decrement number of bytes in ringbuffe
                            r
                      00312                                 
0918   2828           00313 mainLoop2               goto    parseRx                         
                      00314 
                      00315 
                      00316 powerDown               disableirq
                          M ;       disableirq disable global irq 
  0000                    M                                 local   STOP_INT
0919   138B               M STOP_INT                bcf             INTCON,GIE              ; disable global interrupt
091A   1B8B               M                                 btfsc   INTCON,GIE              ; check if disabled 
091B   2919               M                                 goto    STOP_INT                ; nope, try again
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 49


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

091C   110D           00317                                 bcf             PIR2,LVDIF              ; clear low voltage detection bi
                            t
                      00318                                 pcall   safeOutput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(safeOutput)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
091D   27D0               M                                         call    safeOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", safeOu
                            tput
                          M                                                 call    safeOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", safeOutpu
                            t
                          M                                                 call    safeOutput
                          M                                         endif
                          M                                 endif
091E   1283 1703      00319                                 banksel WDTCON
0920   3013           00320                                 movlw   0x13
0921   0085           00321                                 movwf   WDTCON
                      00322                                 enableirq
0922   178B               M                                 bsf             INTCON,GIE              ; enable global interrupt
0923   2828           00323 endless                 goto    parseRx                 ;}
                      00324 
                      00325 
                      00326 #include                <dispatch.asm>
0924                  00001 dispatch
                      00002 ; iterates through parameter table and checks for matching deviceIDs and inputs
0924   1283 1303      00003                                 banksel paramPtr1
0926   3003           00004                                 movlw   actionbase              ; initialise variables
0927   00B9           00005                                 movwf   paramPtr1
0928   3020           00006                                 movlw   low(functionRam)
0929   00BA           00007                                 movwf   paramPtr2
092A   01BE           00008                                 clrf    funcTypeInput
092B   01BF           00009                                 clrf    funcDevID1
092C   01C0           00010                                 clrf    funcDevID2
                      00011 
092D   1B44           00012                                 btfsc   funcUber,6              ; test if in service mode
092E   01B8           00013                                 clrf    rxInput                 ; clear if in service mode
                      00014 
                      00015                                                                                 ; loop start
092F   3000           00016 dispatchLoop    movlw   prescale_Mode
0930   0739           00017                                 addwf   paramPtr1,w
                      00018                                 longcall        eeRead
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 50


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_68DEST_HIGH&0x10)
0931   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_68DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
0932   118A               M                                         bcf     PCLATH,3
                          M                                 endif
0933   200E               M                                                 call    eeRead          
                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_68SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0934   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_68SOURCE_HIGH&0x08)
0935   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 51


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
0936   1283 1303      00019                                 banksel funcPrescMode
0938   00BC           00020                                 movwf   funcPrescMode   ; function mode (low nibble), delay prescaler (h
                            igh nibble)
0939   1903           00021                                 skpnz
093A   0008           00022                                 return                                  ; exit if mode is zero (regular 
                            exit)
                      00023 
                      00024                                 pcall   numParameter    ; number of eeprom parameters
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(numParameter)&0x18)               ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
093B   21C7               M                                         call    numParameter
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", numPar
                            ameter
                          M                                                 call    numParameter ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", numParame
                            ter
                          M                                                 call    numParameter
                          M                                         endif
                          M                                 endif
093C   00FB           00025                                 movwf   temp1
                      00026 
093D   12C4           00027                                 bcf             funcUber,5              ; clear second input matched sem
                            aphore
                      00028                                 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 52


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

093E   3001           00029                                 movlw   output
093F   0739           00030                                 addwf   paramPtr1,w
                      00031                                 longcall        eeRead
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_72DEST_HIGH&0x10)
0940   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_72DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
0941   118A               M                                         bcf     PCLATH,3
                          M                                 endif
0942   200E               M                                                 call    eeRead          
                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_72SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0943   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_72SOURCE_HIGH&0x08)
0944   158A               M                                         bsf     PCLATH,3        
                          M                                 else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 53


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
0945   1283 1303      00032                                 banksel funcOutBits
0947   00BD           00033                                 movwf   funcOutBits             ; output byte (lower nibble output 1, up
                            per nibble output 2)
0948   390F           00034                                 andlw   0x0f                    ; get pointer to parameter ram of output
                             1
0949   00BA           00035                                 movwf   paramPtr2
094A   0DBA           00036                                 rlf             paramPtr2,f
094B   07BA           00037                                 addwf   paramPtr2,f
094C   0DBA           00038                                 rlf             paramPtr2,f
094D   3020           00039                                 movlw   low(functionRam)
094E   07BA           00040                                 addwf   paramPtr2,f
094F   083A           00041                                 movfw   paramPtr2
0950   3E92           00042                                 addlw   -0x6e
0951   1C03 2955      00043                                 bnc             dispatchLoop1
0953   3032           00044                                 movlw   0x32    
0954   07BA           00045                                 addwf   paramPtr2,f
                      00046                                 
0955   0E3D           00047 dispatchLoop1   swapf   funcOutBits,w   ; get pointer to parameter ram of output 2
0956   390F           00048                                 andlw   0x0f
0957   00BB           00049                                 movwf   paramPtr3
0958   0DBB           00050                                 rlf             paramPtr3,f
0959   07BB           00051                                 addwf   paramPtr3,f
095A   0DBB           00052                                 rlf             paramPtr3,f
095B   3020           00053                                 movlw   low(functionRam)
095C   07BB           00054                                 addwf   paramPtr3,f
095D   083B           00055                                 movfw   paramPtr3
095E   3E92           00056                                 addlw   -0x6e
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 54


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

095F   1C03 2963      00057                                 bnc             dispatchLoop2
0961   3032           00058                                 movlw   0x32    
0962   07BB           00059                                 addwf   paramPtr3,f
                      00060 
0963   087B           00061 dispatchLoop2   movfw   temp1                   ; number of eeprom parameters
0964   3A02           00062                                 xorlw   0x02
0965   1903 29A9      00063                                 bz              dispatchLoop5   ; already got 2 parameters
                      00064 
0967   1B44           00065                                 btfsc   funcUber,6              ; test if in service mode
0968   299B           00066                                 goto    dispatchLoop4   ; we are in service mode => no device id paramet
                            ers nedded
                      00067 
0969   3003           00068                                 movlw   devID1
096A   0739           00069                                 addwf   paramPtr1,w
                      00070                                 longcall        eeRead
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_75DEST_HIGH&0x10)
096B   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_75DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
096C   118A               M                                         bcf     PCLATH,3
                          M                                 endif
096D   200E               M                                                 call    eeRead          
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 55


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_75SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
096E   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_75SOURCE_HIGH&0x08)
096F   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
0970   1283 1303      00071                                 banksel funcDevID1
0972   00BF           00072                                 movwf   funcDevID1              ; device ID 1
0973   0637           00073                                 xorwf   rxDevID,w
0974   1D03 2984      00074                                 bnz             dispatchLoop3
                      00075 
0976   3002           00076                                 movlw   input
0977   0739           00077                                 addwf   paramPtr1,w
                      00078                                 longcall        eeRead
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 56


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_78DEST_HIGH&0x10)
0978   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_78DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
0979   118A               M                                         bcf     PCLATH,3
                          M                                 endif
097A   200E               M                                                 call    eeRead          
                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_78SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
097B   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_78SOURCE_HIGH&0x08)
097C   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 57


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
097D   1283 1303      00079                                 banksel funcTypeInput
097F   00BE           00080                                 movwf   funcTypeInput   ; input port1 (low nibble), input port2 (high ni
                            bble)
0980   0638           00081                                 xorwf   rxInput,w
0981   390F           00082                                 andlw   0x0f
0982   1903 299B      00083                                 bz              dispatchLoop4
                      00084                                 
0984   087B           00085 dispatchLoop3   movfw   temp1                   ; number of eeprom parameters
0985   3A06           00086                                 xorlw   0x06
0986   1D03 29C4      00087                                 bnz             dispatchCont    ; no device ID2 parameter needed
                      00088                                 
0988   3005           00089                                 movlw   devID2
0989   0739           00090                                 addwf   paramPtr1,w
                      00091                                 longcall        eeRead
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 58


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_81DEST_HIGH&0x10)
098A   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_81DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
098B   118A               M                                         bcf     PCLATH,3
                          M                                 endif
098C   200E               M                                                 call    eeRead          
                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_81SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
098D   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_81SOURCE_HIGH&0x08)
098E   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 59


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

098F   1283 1303      00092                                 banksel funcDevID2
0991   00C0           00093                                 movwf   funcDevID2              ; device ID 2
0992   0637           00094                                 xorwf   rxDevID,w
0993   1D03 29C4      00095                                 bnz             dispatchCont
                      00096 
0995   0E3E           00097                                 swapf   funcTypeInput,w ; input port1 (low nibble), input port2 (high ni
                            bble)
0996   0638           00098                                 xorwf   rxInput,w
0997   390F           00099                                 andlw   0x0f
0998   1D03 29C4      00100                                 bnz             dispatchCont
                      00101 
099A   16C4           00102                                 bsf             funcUber,5              ; set second input matched semap
                            hore
                      00103                                 
099B   087B           00104 dispatchLoop4   movfw   temp1
099C   3EFB           00105                                 addlw   -0x05
099D   1C03 29A9      00106                                 bnc             dispatchLoop5   ; less than 5 parameters needed
                      00107 
099F   3004           00108                                 movlw   delay
09A0   0739           00109                                 addwf   paramPtr1,w
                      00110                                 longcall        eeRead
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_84DEST_HIGH&0x10)
09A1   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 60


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 if(_84DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
09A2   118A               M                                         bcf     PCLATH,3
                          M                                 endif
09A3   200E               M                                                 call    eeRead          
                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_84SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
09A4   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_84SOURCE_HIGH&0x08)
09A5   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
09A6   1283 1303      00111                                 banksel funcDelay
09A8   00C1           00112                                 movwf   funcDelay               ; delay (value is prescaled)
                      00113 
09A9   083C           00114 dispatchLoop5   movfw   funcPrescMode
09AA   390F           00115                                 andlw   0x0f
                      00116                                 tabj
                          M ;{
                          M ;       TABLE_JUMP Calculates an eventual table boundary crossing  
                          M ;       sets up the PCLATH register correctly
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 61


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       Offset must be in w-reg, offset 0 jumps to the next instr. 
09AB   00F9               M                                 movwf   tabTemp                 ; save wanted offset
09AC   30B4               M                                 movlw   LOW($+8)                ; get low adress ( of first instr. after
                             macro )
09AD   07F9               M                                 addwf   tabTemp,f               ; add offset
09AE   3009               M                                 movlw   HIGH($+6)               ; get highest 5 bits ( of first instr. a
                            fter macro )
09AF   1803               M                                 skpnc                                   ; page crossed ? ( 256 byte )
09B0   3E01               M                                 addlw   0x01                    ; Yes add one to high adress
09B1   008A               M                                 movwf   PCLATH                  ; load high adress in latch
09B2   0879               M                                 movf    tabTemp,w               ; get computed adress
09B3   0082               M                                 movwf   PCL                             ; And jump
09B4   0008           00117                                 return                                  ; mode 0 - exit
09B5   2A06           00118                                 goto    fPassThrough    ; mode 1 - passthrough
09B6   29F8           00119                                 goto    fAlwaysOff              ; mode 2 - always off
09B7   29FF           00120                                 goto    fAlwaysOn               ; mode 3 - always on
09B8   2A18           00121                                 goto    fToggle                 ; mode 4 - toggle light
09B9   2A52           00122                                 goto    fToggleDual             ; mode 5 - light toogle dual outputs
09BA   2AB9           00123                                 goto    fTwoStage               ; mode 6 - two stage light (output1: 1st
                             stage output2 2nd stage)
09BB   0008           00124                                 return                                  ; mode 7 - nop
09BC   2B2A           00125                                 goto    fTimerR                 ; mode 8 - retriggerable timer
09BD   2B55           00126                                 goto    fBlinker                ; mode 9 - blinker
09BE   0008           00127                                 return                                  ; mode a - nop
09BF   0008           00128                                 return                                  ; mode b - nop
09C0   0008           00129                                 return                                  ; mode c - nop
09C1   2B90           00130                                 goto    fAwning                 ; mode d - awning (output1: on/off outpu
                            t2: open/close)
09C2   2C05           00131                                 goto    fBlind                  ; mode e - blind (output1: on/off output
                            2: up/down)
09C3   2CB8           00132                                 goto    fWindow                 ; mode f - window (output1: down output2
                            : close)
                      00133 
                      00134 dispatchCont    pcall   numParameter
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(numParameter)&0x18)               ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
09C4   21C7               M                                         call    numParameter
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", numPar
                            ameter
                          M                                                 call    numParameter ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", numParame
                            ter
                          M                                                 call    numParameter
                          M                                         endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 62


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 endif
09C5   07B9           00135                                 addwf   paramPtr1,f
09C6   292F           00136                                 goto    dispatchLoop
                      00137                                 
09C7   01FC           00138 numParameter    clrf    temp2
09C8   083C           00139                                 movfw   funcPrescMode
09C9   39F0           00140                                 andlw   0xf0
09CA   1D03           00141                                 skpz    
09CB   167C           00142                                 bsf             temp2,4
09CC   083C           00143                                 movfw   funcPrescMode
09CD   390F           00144                                 andlw   0x0f
09CE   047C           00145                                 iorwf   temp2,w
                      00146                                 tabj
                          M ;{
                          M ;       TABLE_JUMP Calculates an eventual table boundary crossing  
                          M ;       sets up the PCLATH register correctly
                          M ;       Offset must be in w-reg, offset 0 jumps to the next instr. 
09CF   00F9               M                                 movwf   tabTemp                 ; save wanted offset
09D0   30D8               M                                 movlw   LOW($+8)                ; get low adress ( of first instr. after
                             macro )
09D1   07F9               M                                 addwf   tabTemp,f               ; add offset
09D2   3009               M                                 movlw   HIGH($+6)               ; get highest 5 bits ( of first instr. a
                            fter macro )
09D3   1803               M                                 skpnc                                   ; page crossed ? ( 256 byte )
09D4   3E01               M                                 addlw   0x01                    ; Yes add one to high adress
09D5   008A               M                                 movwf   PCLATH                  ; load high adress in latch
09D6   0879               M                                 movf    tabTemp,w               ; get computed adress
09D7   0082               M                                 movwf   PCL                             ; And jump
                      00147                                 ;prescale not set
09D8   3400           00148                                 retlw   0x00                    ; mode 0 - exit
09D9   3404           00149                                 retlw   0x04                    ; mode 1 - passthrough
09DA   3402           00150                                 retlw   0x02                    ; mode 2 - always off
09DB   3402           00151                                 retlw   0x02                    ; mode 3 - always on
09DC   3404           00152                                 retlw   0x04                    ; mode 4 - toggle light
09DD   3404           00153                                 retlw   0x04                    ; mode 5 - light toogle dual outputs
09DE   3404           00154                                 retlw   0x04                    ; mode 6 - two stage light (output1: 1st
                             stage output2 2nd stage)
09DF   3400           00155                                 retlw   0x00                    ; mode 7 - nop
09E0   3405           00156                                 retlw   0x05                    ; mode 8 - retriggerable timer
09E1   3406           00157                                 retlw   0x06                    ; mode 9 - blinker
09E2   3400           00158                                 retlw   0x00                    ; mode a - nop
09E3   3400           00159                                 retlw   0x00                    ; mode b - nop
09E4   3400           00160                                 retlw   0x00                    ; mode c - nop
09E5   3406           00161                                 retlw   0x06                    ; mode d - awning (output1: on/off outpu
                            t2: open/close)
09E6   3406           00162                                 retlw   0x06                    ; mode e - blind (output1: on/off output
                            2: up/down)
09E7   3406           00163                                 retlw   0x06                    ; mode f - window (output1: down output2
                            : close)
                      00164                                 ;prescale set
09E8   3400           00165                                 retlw   0x00                    ; mode 0+ - exit
09E9   3404           00166                                 retlw   0x04                    ; mode 1+ - passthrough
09EA   3402           00167                                 retlw   0x02                    ; mode 2+ - always off
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 63


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

09EB   3402           00168                                 retlw   0x02                    ; mode 3+ - always on
09EC   3405           00169                                 retlw   0x05                    ; mode 4+ - toggle light
09ED   3405           00170                                 retlw   0x05                    ; mode 5+ - light toogle dual outputs
09EE   3405           00171                                 retlw   0x05                    ; mode 6+ - two stage light (output1: 1s
                            t stage output2 2nd stage)
09EF   3400           00172                                 retlw   0x00                    ; mode 7+ - nop
09F0   3405           00173                                 retlw   0x05                    ; mode 8+ - retriggerable timer
09F1   3406           00174                                 retlw   0x06                    ; mode 9+ - blinker
09F2   3400           00175                                 retlw   0x00                    ; mode a+ - nop
09F3   3400           00176                                 retlw   0x00                    ; mode b+ - nop
09F4   3400           00177                                 retlw   0x00                    ; mode c+ - nop
09F5   3406           00178                                 retlw   0x06                    ; mode d+ - awning (output1: on/off outp
                            ut2: open/close)
09F6   3406           00179                                 retlw   0x06                    ; mode e+ - blind (output1: on/off outpu
                            t2: up/down)
09F7   3406           00180                                 retlw   0x06                    ; mode f+ - window (output1: down output
                            2: close)
                      00327 #include                <parserx.asm>
                      00328 #include                <functions.asm>
09F8                  00001 fAlwaysOff              ;{
                      00002 ; keeps an output pin always off
                      00003 ; in:   funcOutBits
                      00004 ; out:  outputLo | outputHi
                      00005 ; mod:  bitmaskLo
                      00006 ; mod:  bitmaskHi
09F8   083D           00007                                 movfw   funcOutBits             ; get output bit
                      00008                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
09F9   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00009                                 outputOff                               ; switch output off
09FA   0930               M                                 comf    bitmaskLo,w
09FB   05B2               M                                 andwf   outputLo,f
09FC   0931               M                                 comf    bitmaskHi,w
09FD   05B3               M                                 andwf   outputHi,f
09FE   29C4           00010                                 goto    dispatchCont    ;}
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 64


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00011 
09FF                  00012 fAlwaysOn               ;{
                      00013 ; keeps an output pin always off
                      00014 ; in:   funcOutBits
                      00015 ; out:  outputLo | outputHi
                      00016 ; mod:  bitmaskLo
                      00017 ; mod:  bitmaskHi
09FF   083D           00018                                 movfw   funcOutBits             ; get output bit
                      00019                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A00   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00020                                 outputOn                                ; switch output on
0A01   0830               M                                 movfw   bitmaskLo
0A02   04B2               M                                 iorwf   outputLo,f
0A03   0831               M                                 movfw   bitmaskHi
0A04   04B3               M                                 iorwf   outputHi,f
0A05   29C4           00021                                 goto    dispatchCont    ;}
                      00022 
0A06                  00023 fPassThrough    ;{
                      00024 ; a single output pin follows the state of the corresponding input
                      00025 ; in:   rxInput
                      00026 ; in:   funcOutBits
                      00027 ; out:  outputLo | outputHi
                      00028 ; mod:  bitmaskLo
                      00029 ; mod:  bitmaskHi
0A06   1A38           00030                                 btfsc   rxInput,4               ; check for pressed key (positive edge)
0A07   2A11           00031                                 goto    fPassThrough1
                      00032                                 
0A08   1EB8           00033                                 btfss   rxInput,5               ; check for released key (negative edge)
0A09   29C4           00034                                 goto    dispatchCont
                      00035                                 
0A0A   083D           00036                                 movfw   funcOutBits             ; get output bit
                      00037                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 65


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A0B   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00038                                 outputOff
0A0C   0930               M                                 comf    bitmaskLo,w
0A0D   05B2               M                                 andwf   outputLo,f
0A0E   0931               M                                 comf    bitmaskHi,w
0A0F   05B3               M                                 andwf   outputHi,f
0A10   29C4           00039                                 goto    dispatchCont
                      00040 
0A11   083D           00041 fPassThrough1   movfw   funcOutBits             ; get output bit
                      00042                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A12   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00043                                 outputOn
0A13   0830               M                                 movfw   bitmaskLo
0A14   04B2               M                                 iorwf   outputLo,f
0A15   0831               M                                 movfw   bitmaskHi
0A16   04B3               M                                 iorwf   outputHi,f
0A17   29C4           00044                                 goto    dispatchCont    ;}
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 66


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00045 
0A18                  00046 fToggle                 ;{
                      00047 ; toggles a single output pin when the corresponding key is pressed
                      00048 ; in:   rxInput
                      00049 ; in:   funcOutBits
                      00050 ; out:  outputLo | outputHi
                      00051 ; mod:  bitmaskLo
                      00052 ; mod:  bitmaskHi
0A18   1783           00053                                 bankisel        functionRam
                      00054                                 
0A19   1E44           00055                                 btfss   funcUber,4              ; need to check the output bit?
0A1A   2A23           00056                                 goto    fToggleS1               ; no
                      00057                                 
0A1B   0844           00058                                 movfw   funcUber
0A1C   063D           00059                                 xorwf   funcOutBits,w
0A1D   390F           00060                                 andlw   0x0f
0A1E   1D03 29C4      00061                                 bnz             dispatchCont    ; not the output bit we searched for
                      00062 
0A20   1BC4           00063                                 btfsc   funcUber,7              ; test for on/off mode
0A21   2A36           00064                                 goto    fToggleS3               ; lights on
0A22   2A49           00065                                 goto    fToggleS5               ; lights off
                      00066 
0A23   1843           00067 fToggleS1               btfsc   funcSemaphore,0 ; check for lights on
0A24   2A36           00068                                 goto    fToggleS3               ; light on
                      00069 
0A25   18C3           00070                                 btfsc   funcSemaphore,1 ; check for lights off
0A26   2A49           00071                                 goto    fToggleS5               ; light off
                      00072 
0A27   1E38           00073 fToggleS2               btfss   rxInput,4               ; check for pressed key (positive edge)
0A28   2A3D           00074                                 goto    fToggleS4               ; continue if no positive edge
                      00075                                 
0A29   0A3A           00076                                 incf    paramPtr2,w
                      00077                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A2A   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
                      00078 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 67


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0A2B   083D           00079                                 movfw   funcOutBits             ; check for output status
                      00080                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A2C   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00081                                 pcall   checkOutput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(checkOutput)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A2D   274E               M                                         call    checkOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", checkO
                            utput
                          M                                                 call    checkOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", checkOutp
                            ut
                          M                                                 call    checkOutput
                          M                                         endif
                          M                                 endif
0A2E   1D03 2A49      00082                                 bnz             fToggleS5               ; output is currently on => turn
                             output off
                      00083 
0A30   083C           00084                                 movfw   funcPrescMode
0A31   39F0           00085                                 andlw   0xf0
0A32   1903 2A36      00086                                 bz              fToggleS3               ; no timer mode
                      00087 
0A34   0A3A           00088                                 incf    paramPtr2,w
                      00089                                 pcall   genDelay                ; set delay after which we turn of the o
                            utput
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 68


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A35   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
                      00090 
0A36   083D           00091 fToggleS3               movfw   funcOutBits
                      00092                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A37   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00093                                 outputOn                                ; switch output on
0A38   0830               M                                 movfw   bitmaskLo
0A39   04B2               M                                 iorwf   outputLo,f
0A3A   0831               M                                 movfw   bitmaskHi
0A3B   04B3               M                                 iorwf   outputHi,f
                      00094 
0A3C   29C4           00095                                 goto    dispatchCont
                      00096 
0A3D   0A3A           00097 fToggleS4               incf    paramPtr2,w
                      00098                                 pcall   compareTime             ; on-time already elapsed
                          M ;       Pcall page call, code for calling on same page
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 69


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A3E   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0A3F   1803 29C4      00099                                 bc              dispatchCont    ; no
                      00100                                 
0A41   0A3A           00101                                 incf    paramPtr2,w
                      00102                                 pcall   chkDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(chkDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A42   2762               M                                         call    chkDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", chkDel
                            ay
                          M                                                 call    chkDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", chkDelay
                          M                                                 call    chkDelay
                          M                                         endif
                          M                                 endif
0A43   1903 29C4      00103                                 bz              dispatchCont    ; continue if delay timer alreay cleared
                      00104 
0A45   083A           00105                                 movfw   paramPtr2
0A46   0084           00106                                 movwf   FSR
0A47   1B80           00107                                 btfsc   INDF,7                  ; test twoStage status if key is still p
                            ressed
0A48   29C4           00108                                 goto    dispatchCont    ; there is also a twoStageToggle running
                      00109                                 
0A49   0A3A           00110 fToggleS5               incf    paramPtr2,w
                      00111                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 70


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A4A   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
                      00112 
0A4B   083D           00113                                 movfw   funcOutBits
                      00114                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A4C   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00115                                 outputOff                               ; switch output off
0A4D   0930               M                                 comf    bitmaskLo,w
0A4E   05B2               M                                 andwf   outputLo,f
0A4F   0931               M                                 comf    bitmaskHi,w
0A50   05B3               M                                 andwf   outputHi,f
                      00116 
0A51   29C4           00117                                 goto    dispatchCont    ;}
                      00118 
                      00119 
0A52                  00120 fToggleDual             ;{
                      00121 ; toggles two output pins when the corresponding key is pressed (output 1 is master)
                      00122 ; in:   rxInput
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 71


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00123 ; in:   funcOutBits (lower and upper nibble)
                      00124 ; out:  outputLo &/| outputHi
                      00125 ; mod:  bitmaskLo
                      00126 ; mod:  bitmaskHi
0A52   1783           00127                                 bankisel        functionRam
                      00128 
0A53   1E44           00129                                 btfss   funcUber,4              ; need to check the output bit?
0A54   2A62           00130                                 goto    fToggleDual0    ; no
                      00131                                 
0A55   083D           00132                                 movfw   funcOutBits
0A56   0644           00133                                 xorwf   funcUber,w
0A57   390F           00134                                 andlw   0x0f
0A58   1903 2A5F      00135                                 bz              fToggleDualA    ; one of our output bits we searched for
                      00136 
0A5A   0E3D           00137                                 swapf   funcOutBits,w
0A5B   0644           00138                                 xorwf   funcUber,w
0A5C   390F           00139                                 andlw   0x0f
0A5D   1D03 29C4      00140                                 bnz             dispatchCont    ; not the output bit we searched for
                      00141                                 
0A5F   1BC4           00142 fToggleDualA    btfsc   funcUber,7              ; test for on/off mode
0A60   2A8B           00143                                 goto    fToggleDual3    ; lights on
0A61   2A76           00144                                 goto    fToggleDual1    ; lights off
                      00145 
0A62   1843           00146 fToggleDual0    btfsc   funcSemaphore,0 ; check for lights on
0A63   2A8B           00147                                 goto    fToggleDual3
                      00148 
0A64   18C3           00149                                 btfsc   funcSemaphore,1 ; check for lights off
0A65   2A76           00150                                 goto    fToggleDual1
                      00151 
0A66   1E38           00152                                 btfss   rxInput,4               ; check for pressed key (positive edge)
0A67   2A98           00153                                 goto    fToggleDual4
                      00154                                 
0A68   0A3A           00155                                 incf    paramPtr2,w
                      00156                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A69   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 72


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0A6A   0A3B           00157                                 incf    paramPtr3,w
                      00158                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A6B   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
                      00159 
0A6C   0E3D           00160                                 swapf   funcOutBits,w
                      00161                                 pcall   genBitmask              ; generate bitmask for output2
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A6D   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00162                                 pcall   checkOutput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(checkOutput)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 73


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0A6E   274E               M                                         call    checkOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", checkO
                            utput
                          M                                                 call    checkOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", checkOutp
                            ut
                          M                                                 call    checkOutput
                          M                                         endif
                          M                                 endif
0A6F   1903 2A83      00163                                 bz              fToggleDual2    ; output2 clear
0A71   083D           00164                                 movfw   funcOutBits
                      00165                                 pcall   genBitmask              ; generate bitmask for output1
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A72   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00166                                 pcall   checkOutput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(checkOutput)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A73   274E               M                                         call    checkOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", checkO
                            utput
                          M                                                 call    checkOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", checkOutp
                            ut
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 74


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    checkOutput
                          M                                         endif
                          M                                 endif
0A74   1903 2A83      00167                                 bz              fToggleDual2    ; output1 clear
0A76   083D           00168 fToggleDual1    movfw   funcOutBits
                      00169                                 pcall   genBitmask              ; generate bitmask for output1
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A77   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00170                                 outputOff
0A78   0930               M                                 comf    bitmaskLo,w
0A79   05B2               M                                 andwf   outputLo,f
0A7A   0931               M                                 comf    bitmaskHi,w
0A7B   05B3               M                                 andwf   outputHi,f
0A7C   0E3D           00171                                 swapf   funcOutBits,w
                      00172                                 pcall   genBitmask              ; generate bitmask for output2
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A7D   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 75


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00173                                 outputOff
0A7E   0930               M                                 comf    bitmaskLo,w
0A7F   05B2               M                                 andwf   outputLo,f
0A80   0931               M                                 comf    bitmaskHi,w
0A81   05B3               M                                 andwf   outputHi,f
0A82   29C4           00174                                 goto    dispatchCont
                      00175 
0A83   083C           00176 fToggleDual2    movfw   funcPrescMode
0A84   39F0           00177                                 andlw   0xf0
0A85   1903 2A8B      00178                                 bz              fToggleDual3
                      00179 
0A87   0A3A           00180                                 incf    paramPtr2,w
                      00181                                 pcall   genDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A88   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0A89   0A3B           00182                                 incf    paramPtr3,w
                      00183                                 pcall   genDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A8A   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 76


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00184 
0A8B   083D           00185 fToggleDual3    movfw   funcOutBits
                      00186                                 pcall   genBitmask              ; generate bitmask for output1
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A8C   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00187                                 outputOn
0A8D   0830               M                                 movfw   bitmaskLo
0A8E   04B2               M                                 iorwf   outputLo,f
0A8F   0831               M                                 movfw   bitmaskHi
0A90   04B3               M                                 iorwf   outputHi,f
0A91   0E3D           00188                                 swapf   funcOutBits,w
                      00189                                 pcall   genBitmask              ; generate bitmask for output2
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A92   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00190                                 outputOn
0A93   0830               M                                 movfw   bitmaskLo
0A94   04B2               M                                 iorwf   outputLo,f
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 77


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0A95   0831               M                                 movfw   bitmaskHi
0A96   04B3               M                                 iorwf   outputHi,f
0A97   29C4           00191                                 goto    dispatchCont
                      00192 
0A98   0A3A           00193 fToggleDual4    incf    paramPtr2,w
                      00194                                 pcall   compareTime             ; time already elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A99   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0A9A   1803 2AA8      00195                                 bc              fToggleDual5    ; no
                      00196                                 
0A9C   0A3A           00197                                 incf    paramPtr2,w
                      00198                                 pcall   chkDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(chkDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0A9D   2762               M                                         call    chkDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", chkDel
                            ay
                          M                                                 call    chkDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", chkDelay
                          M                                                 call    chkDelay
                          M                                         endif
                          M                                 endif
0A9E   1903 2AA8      00199                                 bz              fToggleDual5    ; continue if delay timer alreay cleared
                      00200 
0AA0   0A3A           00201                                 incf    paramPtr2,w
                      00202                                 pcall   clrDelay                ; clear delay timer
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 78


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AA1   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
                      00203 
0AA2   083D           00204                                 movfw   funcOutBits
                      00205                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AA3   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00206                                 outputOff                               ; switch output off
0AA4   0930               M                                 comf    bitmaskLo,w
0AA5   05B2               M                                 andwf   outputLo,f
0AA6   0931               M                                 comf    bitmaskHi,w
0AA7   05B3               M                                 andwf   outputHi,f
                      00207 
0AA8   0A3B           00208 fToggleDual5    incf    paramPtr3,w
                      00209                                 pcall   compareTime             ; time already elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 79


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AA9   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0AAA   1803 29C4      00210                                 bc              dispatchCont    ; no
                      00211                                 
0AAC   0A3B           00212                                 incf    paramPtr3,w
                      00213                                 pcall   chkDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(chkDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AAD   2762               M                                         call    chkDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", chkDel
                            ay
                          M                                                 call    chkDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", chkDelay
                          M                                                 call    chkDelay
                          M                                         endif
                          M                                 endif
0AAE   1903 29C4      00214                                 bz              dispatchCont    ; continue if delay timer alreay cleared
                      00215 
0AB0   0A3B           00216                                 incf    paramPtr3,w
                      00217                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AB1   2755               M                                         call    clrDelay
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 80


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
                      00218 
0AB2   0E3D           00219                                 swapf   funcOutBits,w
                      00220                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AB3   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00221                                 outputOff                               ; switch output off
0AB4   0930               M                                 comf    bitmaskLo,w
0AB5   05B2               M                                 andwf   outputLo,f
0AB6   0931               M                                 comf    bitmaskHi,w
0AB7   05B3               M                                 andwf   outputHi,f
                      00222 
0AB8   29C4           00223                                 goto    dispatchCont    ;}
                      00224 
                      00225                                 
0AB9                  00226 fTwoStage               ;{
                      00227 ; toggles first output on short keypress, when the first output toggles on and the 
                      00228 ; key is held for a longer time the second output turns on
                      00229 ; in:   rxInput
                      00230 ; in:   funcOutBits (lower and upper nibble)
                      00231 ; out:  outputLo &/| outputHi
                      00232 ; mod:  bitmaskLo
                      00233 ; mod:  bitmaskHi
0AB9   1783           00234                                 bankisel        functionRam
0ABA   1E44           00235                                 btfss   funcUber,4              ; need to check the output bit?
0ABB   2AC9           00236                                 goto    fTwoStage2              ; no
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 81


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00237                                 
0ABC   083D           00238                                 movfw   funcOutBits
0ABD   0644           00239                                 xorwf   funcUber,w
0ABE   390F           00240                                 andlw   0x0f
0ABF   1903 2AC6      00241                                 bz              fTwoStage1              ; one of our output bits we sear
                            ched for
                      00242 
0AC1   0E3D           00243                                 swapf   funcOutBits,w
0AC2   0644           00244                                 xorwf   funcUber,w
0AC3   390F           00245                                 andlw   0x0f
0AC4   1D03 29C4      00246                                 bnz             dispatchCont    ; not the output bit we searched for
                      00247                                 
0AC6   1BC4           00248 fTwoStage1              btfsc   funcUber,7              ; test for on/off mode
0AC7   2B0C           00249                                 goto    fTwoStage6              ; lights on
0AC8   2B1B           00250                                 goto    fTwoStage7              ; lights off
                      00251 
0AC9   1843           00252 fTwoStage2              btfsc   funcSemaphore,0 ; check for lights on
0ACA   2B0C           00253                                 goto    fTwoStage6
                      00254 
0ACB   18C3           00255                                 btfsc   funcSemaphore,1 ; check for lights off
0ACC   2B1B           00256                                 goto    fTwoStage7
                      00257 
0ACD   1A38           00258                                 btfsc   rxInput,4               ; check for pressed key (positive edge)
0ACE   2AD7           00259                                 goto    fTwoStage3
                      00260 
0ACF   1EB8           00261                                 btfss   rxInput,5               ; check for released key (negative edge)
0AD0   2AF3           00262                                 goto    fTwoStage5
                      00263 
0AD1   083A           00264                                 movfw   paramPtr2
0AD2   0084           00265                                 movwf   FSR
0AD3   1380           00266                                 bcf             INDF,7                  ; clear flag 'positive edge rece
                            ived' on twoStage status
0AD4   0A3A           00267                                 incf    paramPtr2,w
                      00268                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AD5   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 82


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0AD6   29C4           00269                                 goto    dispatchCont    
                      00270 
0AD7   083D           00271 fTwoStage3              movfw   funcOutBits
                      00272                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AD8   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00273                                 pcall   checkOutput             ; check if output already set
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(checkOutput)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AD9   274E               M                                         call    checkOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", checkO
                            utput
                          M                                                 call    checkOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", checkOutp
                            ut
                          M                                                 call    checkOutput
                          M                                         endif
                          M                                 endif
0ADA   1D03 2AE8      00274                                 bnz             fTwoStage4
                      00275 
                      00276                                 outputOn                                ; switch output 1 on (gang 1)
0ADC   0830               M                                 movfw   bitmaskLo
0ADD   04B2               M                                 iorwf   outputLo,f
0ADE   0831               M                                 movfw   bitmaskHi
0ADF   04B3               M                                 iorwf   outputHi,f
0AE0   083A           00277                                 movfw   paramPtr2
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 83


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0AE1   0084           00278                                 movwf   FSR
0AE2   1780           00279                                 bsf             INDF,7                  ; set flag 'positive edge receiv
                            ed' on twoStage status
0AE3   3001           00280                                 movlw   0x01                    ; we use only the prescaler for this del
                            ay
0AE4   00C1           00281                                 movwf   funcDelay
0AE5   0A3A           00282                                 incf    paramPtr2,w
                      00283                                 pcall   genDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AE6   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0AE7   29C4           00284                                 goto    dispatchCont    
                      00285 
                      00286 fTwoStage4              outputOff                               ; switch output 1 off
0AE8   0930               M                                 comf    bitmaskLo,w
0AE9   05B2               M                                 andwf   outputLo,f
0AEA   0931               M                                 comf    bitmaskHi,w
0AEB   05B3               M                                 andwf   outputHi,f
0AEC   0E3D           00287                                 swapf   funcOutBits,w
                      00288                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AED   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 84


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00289                                 outputOff                               ; switch output 2 off
0AEE   0930               M                                 comf    bitmaskLo,w
0AEF   05B2               M                                 andwf   outputLo,f
0AF0   0931               M                                 comf    bitmaskHi,w
0AF1   05B3               M                                 andwf   outputHi,f
0AF2   29C4           00290                                 goto    dispatchCont    
                      00291 
0AF3   083A           00292 fTwoStage5              movfw   paramPtr2
0AF4   0084           00293                                 movwf   FSR
0AF5   1F80           00294                                 btfss   INDF,7                  ; test twoStage status if key is still p
                            ressed
0AF6   29C4           00295                                 goto    dispatchCont
                      00296 
0AF7   0A3A           00297                                 incf    paramPtr2,w
                      00298                                 pcall   compareTime
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AF8   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0AF9   1803 29C4      00299                                 bc              dispatchCont
                      00300         
0AFB   083A           00301                                 movfw   paramPtr2
0AFC   0084           00302                                 movwf   FSR
0AFD   1380           00303                                 bcf             INDF,7                  ; clear flag 'positive edge rece
                            ived' on twoStage status
0AFE   0A3A           00304                                 incf    paramPtr2,w
                      00305                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 85


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0AFF   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
                      00306 
0B00   083D           00307                                 movfw   funcOutBits             ; check if output 1 is already set
                      00308                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B01   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00309                                 pcall   checkOutput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(checkOutput)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B02   274E               M                                         call    checkOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", checkO
                            utput
                          M                                                 call    checkOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", checkOutp
                            ut
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 86


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    checkOutput
                          M                                         endif
                          M                                 endif
0B03   1903 29C4      00310                                 bz              dispatchCont    ; no
                      00311 
0B05   0E3D           00312                                 swapf   funcOutBits,w
                      00313                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B06   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00314                                 outputOn                                ; switch output 2 on (gang 2)
0B07   0830               M                                 movfw   bitmaskLo
0B08   04B2               M                                 iorwf   outputLo,f
0B09   0831               M                                 movfw   bitmaskHi
0B0A   04B3               M                                 iorwf   outputHi,f
0B0B   29C4           00315                                 goto    dispatchCont
                      00316                                 
0B0C   083D           00317 fTwoStage6              movfw   funcOutBits
                      00318                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B0D   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 87


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00319                                 outputOn                                ; switch output 1 on
0B0E   0830               M                                 movfw   bitmaskLo
0B0F   04B2               M                                 iorwf   outputLo,f
0B10   0831               M                                 movfw   bitmaskHi
0B11   04B3               M                                 iorwf   outputHi,f
0B12   0E3D           00320                                 swapf   funcOutBits,w
                      00321                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B13   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00322                                 outputOn                                ; switch output 2 on
0B14   0830               M                                 movfw   bitmaskLo
0B15   04B2               M                                 iorwf   outputLo,f
0B16   0831               M                                 movfw   bitmaskHi
0B17   04B3               M                                 iorwf   outputHi,f
0B18   0A3A           00323                                 incf    paramPtr2,w
                      00324                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B19   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 88


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
0B1A   29C4           00325                                 goto    dispatchCont    
                      00326 
0B1B   083D           00327 fTwoStage7              movfw   funcOutBits
                      00328                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B1C   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00329                                 outputOff                               ; switch output 1 off
0B1D   0930               M                                 comf    bitmaskLo,w
0B1E   05B2               M                                 andwf   outputLo,f
0B1F   0931               M                                 comf    bitmaskHi,w
0B20   05B3               M                                 andwf   outputHi,f
0B21   0E3D           00330                                 swapf   funcOutBits,w
                      00331                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B22   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 89


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 endif
                      00332                                 outputOff                               ; switch output 2 off
0B23   0930               M                                 comf    bitmaskLo,w
0B24   05B2               M                                 andwf   outputLo,f
0B25   0931               M                                 comf    bitmaskHi,w
0B26   05B3               M                                 andwf   outputHi,f
0B27   0A3A           00333                                 incf    paramPtr2,w
                      00334                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B28   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
0B29   29C4           00335                                 goto    dispatchCont    ;}
                      00336 
                      00337 
0B2A                  00338 fTimerR                 ;{
                      00339 ; retriggerable timer
                      00340 ; ouptut is turned on until delay time has elapsed
                      00341 ; in:   rxDevID
                      00342 ; in:   rxInput
                      00343 ; in:   funcOutBits lower nibble
                      00344 ; out:  outputLo &/| outputHi
                      00345 ; mod:  bitmaskLo
                      00346 ; mod:  bitmaskHi                       
0B2A   1783           00347                                 bankisel        functionRam
0B2B   1E44           00348                                 btfss   funcUber,4              ; need to check the output bit?
0B2C   2B35           00349                                 goto    fTimerRa                ; no
                      00350                                 
0B2D   0844           00351                                 movfw   funcUber
0B2E   063D           00352                                 xorwf   funcOutBits,w
0B2F   390F           00353                                 andlw   0x0f
0B30   1D03 29C4      00354                                 bnz             dispatchCont    ; not the output bit we searched for
                      00355 
0B32   1BC4           00356                                 btfsc   funcUber,7              ; test for on/off mode
0B33   2B4C           00357                                 goto    fTimerR1                ; lights on
0B34   2B43           00358                                 goto    fTimerR0                ; lights off
                      00359 
0B35   1843           00360 fTimerRa                btfsc   funcSemaphore,0 ; check for lights on
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 90


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0B36   2B4C           00361                                 goto    fTimerR1
                      00362 
0B37   18C3           00363                                 btfsc   funcSemaphore,1 ; check for lights off
0B38   2B43           00364                                 goto    fTimerR0
                      00365 
0B39   1A38           00366                                 btfsc   rxInput,4               ; check for pressed key (positive edge)
0B3A   2B4C           00367                                 goto    fTimerR1
                      00368 
0B3B   0A3A           00369                                 incf    paramPtr2,w
                      00370                                 pcall   compareTime             ; time already elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B3C   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0B3D   1803 29C4      00371                                 bc              dispatchCont    ; no
                      00372 
0B3F   0A3A           00373                                 incf    paramPtr2,w
                      00374                                 pcall   chkDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(chkDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B40   2762               M                                         call    chkDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", chkDel
                            ay
                          M                                                 call    chkDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", chkDelay
                          M                                                 call    chkDelay
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 91


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0B41   1903 29C4      00375                                 bz              dispatchCont    ; continue if delay timer alreay cleared
                      00376 
0B43   083D           00377 fTimerR0                movfw   funcOutBits
                      00378                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B44   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00379                                 outputOff                               ; switch output off
0B45   0930               M                                 comf    bitmaskLo,w
0B46   05B2               M                                 andwf   outputLo,f
0B47   0931               M                                 comf    bitmaskHi,w
0B48   05B3               M                                 andwf   outputHi,f
                      00380 
0B49   0A3A           00381                                 incf    paramPtr2,w
                      00382                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B4A   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
0B4B   29C4           00383                                 goto    dispatchCont
                      00384 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 92


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0B4C   0A3A           00385 fTimerR1                incf    paramPtr2,w
                      00386                                 pcall   genDelay
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B4D   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
                      00387 
0B4E   083D           00388                                 movfw   funcOutBits
                      00389                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B4F   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00390                                 outputOn                                ; switch output on
0B50   0830               M                                 movfw   bitmaskLo
0B51   04B2               M                                 iorwf   outputLo,f
0B52   0831               M                                 movfw   bitmaskHi
0B53   04B3               M                                 iorwf   outputHi,f
                      00391 
0B54   29C4           00392                                 goto    dispatchCont    ;}
                      00393 
0B55                  00394 fBlinker                        ;{
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 93


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00395 ; blinker
                      00396 ; toggles output with configurable frequency and duty cycle
                      00397 ; in:   rxDevID
                      00398 ; in:   rxInput
                      00399 ; in:   funcOutBits lower nibble
                      00400 ; out:  outputLo &/| outputHi
                      00401 ; mod:  bitmaskLo
                      00402 ; mod:  bitmaskHi                       
                      00403 
                      00404 ; 6.0ms cycle
                      00405 ; 0.5ms low
                      00406 ; 5.5ms high
                      00407 
0B55   1783           00408                                 bankisel        functionRam
0B56   083A           00409                                 movfw   paramPtr2
0B57   0084           00410                                 movwf   FSR
                      00411 
0B58   1E38           00412                                 btfss   rxInput,4               ; check for pressed key (positive edge)
0B59   2B5C           00413                                 goto    fBlinker1
0B5A   1400           00414                                 bsf             INDF,0
0B5B   2B72           00415                                 goto    fBlinker3
                      00416 
0B5C   1EB8           00417 fBlinker1:              btfss   rxInput,5               ; check for released key (negative edge)
0B5D   2B68           00418                                 goto    fBlinker2
0B5E   0180           00419                                 clrf    INDF
                      00420 
0B5F   0A3A           00421                                 incf    paramPtr2,w
                      00422                                 pcall   clrDelay                ; clear delay timer
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(clrDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B60   2755               M                                         call    clrDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", clrDel
                            ay
                          M                                                 call    clrDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", clrDelay
                          M                                                 call    clrDelay
                          M                                         endif
                          M                                 endif
                      00423 
0B61   083D           00424                                 movfw   funcOutBits
                      00425                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 94


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B62   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00426                                 outputOff                               ; switch output off
0B63   0930               M                                 comf    bitmaskLo,w
0B64   05B2               M                                 andwf   outputLo,f
0B65   0931               M                                 comf    bitmaskHi,w
0B66   05B3               M                                 andwf   outputHi,f
0B67   29C4           00427                                 goto    dispatchCont
                      00428 
0B68   1C00           00429 fBlinker2:              btfss   INDF,0
0B69   29C4           00430                                 goto    dispatchCont
                      00431 
0B6A   0A3A           00432                                 incf    paramPtr2,w
                      00433                                 pcall   compareTime             ; time already elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B6B   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0B6C   1803 29C4      00434                                 bc              dispatchCont    ; no
                      00435 
0B6E   083A           00436                                 movfw   paramPtr2
0B6F   0084           00437                                 movwf   FSR
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 95


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0B70   1880           00438                                 btfsc   INDF,1
0B71   2B7C           00439                                 goto    fBlinker4
                      00440 
0B72   1480           00441 fBlinker3:              bsf             INDF,1
                      00442 
0B73   0A3A           00443                                 incf    paramPtr2,w
                      00444                                 pcall   genDelayF               ; set up delay T1
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelayF)&0x18)                  ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B74   276E               M                                         call    genDelayF
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ayF
                          M                                                 call    genDelayF ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelayF
                          M                                                 call    genDelayF
                          M                                         endif
                          M                                 endif
                      00445 
0B75   083D           00446                                 movfw   funcOutBits
                      00447                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B76   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00448                                 outputOn                                ; switch output on
0B77   0830               M                                 movfw   bitmaskLo
0B78   04B2               M                                 iorwf   outputLo,f
0B79   0831               M                                 movfw   bitmaskHi
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 96


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0B7A   04B3               M                                 iorwf   outputHi,f
                      00449 
0B7B   29C4           00450                                 goto    dispatchCont
                      00451 
0B7C   1080           00452 fBlinker4:              bcf             INDF,1
                      00453 
0B7D   3005           00454                                 movlw   devID2                  ; we use funcDevID2 as T2 low phase
0B7E   0739           00455                                 addwf   paramPtr1,w
                      00456                                 longcall        eeRead
                          M ;       LONG_call long call, sets the page bits 4:5 of PCLATH
                          M ;       so call can cross ANY page boundary, resets PCLATH after call.
                          M ;       w-reg is left untouched.
                          M                         
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
                          M 
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)             ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                  ; --- || ---  source adress
  00000018                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace longcall with pcall", eeRead
                          M                                         nop             ; redundant nops 
                          M                                         nop
                          M                                         call    eeRead
                          M                                         nop
                          M                                         nop
                          M                                 else    ; test if both bits must be set ? i.e. page0<->page3 or page2<->
                            page3
                          M                                         if      (DIFF_HIGH == 0x18) ; difference in BOTH bits, delta 2 p
                            ages
                          M                                                 ;messg  "Setting page bits for long page crossing call"
                          M                                                 setpclath       DEST_HIGH   ; set both bits in PCLATH
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_174DEST_HIGH&0x10)
0B7F   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_174DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
0B80   118A               M                                         bcf     PCLATH,3
                          M                                 endif
0B81   200E               M                                                 call    eeRead          
                          M                                                 setpclath       SOURCE_HIGH ; reset both bits in pclath 
                          M ;       setpclath 'help' macro for LONG_call
                          M ;       sets/clears PCLATH bits 3:4 according to 
                          M ;       'variable' PCLATH_34
                          M                                 if(_174SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 97


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 else
0B82   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                 if(_174SOURCE_HIGH&0x08)
0B83   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         else
                          M                                                 ; if we end up here then one bsf/bcf is enough, i.e. del
                            ta 1 page
                          M                                                 ; i.e. page0<->1 or page2<->3
                          M                                                 messg   "Call only one page, replace longcall with scall
                            ", eeRead
                          M                                                 if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath4      DEST_HIGH ; set high(4) bit of P
                            CLATH
                          M                                                         call    eeRead
                          M                                                         setpclath4      SOURCE_HIGH
                          M                                                         nop     ; redundant nop
                          M                                                 else
                          M                                                         ; lowest bit only
                          M                                                         nop     ; redundant nop
                          M                                                         setpclath3      DEST_HIGH ; set low(3) bit of PC
                            LATH
                          M                                                         call    eeRead
                          M                                                         setpclath3      SOURCE_HIGH
                          M                                                         nop
                          M                                                 endif
                          M                                         endif
                          M                                 endif
0B84   1283 1303      00457                                 banksel funcDelay
0B86   00C1           00458                                 movwf   funcDelay
0B87   0A3A           00459                                 incf    paramPtr2,w
                      00460                                 pcall   genDelayF               ; set up delay T2
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelayF)&0x18)                  ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B88   276E               M                                         call    genDelayF
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ayF
                          M                                                 call    genDelayF ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelayF
                          M                                                 call    genDelayF
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 98


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         endif
                          M                                 endif
                      00461                                 
0B89   083D           00462                                 movfw   funcOutBits
                      00463                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0B8A   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00464                                 outputOff                               ; switch output off
0B8B   0930               M                                 comf    bitmaskLo,w
0B8C   05B2               M                                 andwf   outputLo,f
0B8D   0931               M                                 comf    bitmaskHi,w
0B8E   05B3               M                                 andwf   outputHi,f
                      00465 
0B8F   29C4           00466                                 goto    dispatchCont    ;}
                      00467 
                      00468 
0B90                  00469 fAwning                 ;{
                      00470 ;        +-----+  T3        T3  +-----+      
                      00471 ;        |     |------+  +------|     |      
                      00472 ;  +---->| S01 |  O+  |  |  C+  | S11 |<----+
                      00473 ;  |     |full |----->|  |<-----|full |     |
                      00474 ;  |     |close|  C+  |  |  O+  |open |     |
                      00475 ;  |     |     |----->|  |<-----|     |     |
                      00476 ;  |     +-----+      |  |      +-----+     |
                      00477 ;  |                  v  v                  |
                      00478 ;  |              +----------+              |
                      00479 ;  |              |    S02   |              |
                      00480 ;  |              |protection|              |
                      00481 ;  |              | interval |              |
                      00482 ;  |              +----------+              |
                      00483 ;  |                    |                   |
                      00484 ;  |                    | T4                |
                      00485 ;  |                    v                   |
                      00486 ;  |                +------+                |
                      00487 ;  |            C+  | S00  |  O+            |
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 99


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00488 ;  +----------------| stop |----------------+
                      00489 ;                   |      |
                      00490 ;                   +------+
                      00491 
                      00492 
0B90   1783           00493                                 bankisel        functionRam
0B91   1E44           00494                                 btfss   funcUber,4              ; need to check the output bit?
0B92   2BA0           00495                                 goto    fAwningA                ; no
                      00496 
0B93   083D           00497                                 movfw   funcOutBits
0B94   0644           00498                                 xorwf   funcUber,w
0B95   390F           00499                                 andlw   0x0f
0B96   1903 2B9D      00500                                 bz              fAwningB                ; one of our output bits we sear
                            ched for
                      00501 
0B98   0E3D           00502                                 swapf   funcOutBits,w
0B99   0644           00503                                 xorwf   funcUber,w
0B9A   390F           00504                                 andlw   0x0f
0B9B   1D03 29C4      00505                                 bnz             dispatchCont    ; not the output bit we searched for
                      00506 
0B9D   1BC4           00507 fAwningB                btfsc   funcUber,7              ; test for open/close mode
0B9E   2BFE           00508                                 goto    fAwningO                ; open awning
0B9F   2BF7           00509                                 goto    fAwningC                ; close awning
                      00510 
0BA0   1B43           00511 fAwningA                btfsc   funcSemaphore,6 ; check for awning closing
0BA1   2BF7           00512                                 goto    fAwningC
                      00513 
0BA2   1BC3           00514                                 btfsc   funcSemaphore,7 ; check for awning opening
0BA3   2BFE           00515                                 goto    fAwningO
                      00516 
0BA4   083A           00517                                 movfw   paramPtr2
0BA5   0084           00518                                 movwf   FSR
0BA6   0880           00519                                 tstf    INDF                    ; test for state 00
0BA7   1903 2BB2      00520                                 bz              fAwningS00
                      00521 
0BA9   3001           00522                                 movlw   0x01
0BAA   0600           00523                                 xorwf   INDF,w                  ; test for state 01
0BAB   1903 2BCC      00524                                 bz              fAwningS01
                      00525 
0BAD   3002           00526                                 movlw   0x02
0BAE   0600           00527                                 xorwf   INDF,w                  ; test for state 02
0BAF   1903 2BEB      00528                                 bz              fAwningS02
                      00529 
0BB1   2BD2           00530                                 goto    fAwningStop             ; nothing matched; set state 00
                      00531 
0BB2   1E38           00532 fAwningS00              btfss   rxInput,4               ; check for pressed key (positive edge)
0BB3   29C4           00533                                 goto    dispatchCont
                      00534 
0BB4   3001           00535                                 movlw   0x01                    ; next state S01
0BB5   0080           00536                                 movwf   INDF
                      00537 
0BB6   0E3D           00538                                 swapf   funcOutBits,w   ; generate bitmask for close/open (upper nibble)
                      00539                                 pcall   genBitmask
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 100


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BB7   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
0BB8   1AC4           00540                                 btfsc   funcUber,5              ; test if second input key (close) match
                            ed
0BB9   2BBF           00541                                 goto    fAwningS00a             ; no, we are opening
                      00542                                 outputOff                               ; switch close/open off (close)
0BBA   0930               M                                 comf    bitmaskLo,w
0BBB   05B2               M                                 andwf   outputLo,f
0BBC   0931               M                                 comf    bitmaskHi,w
0BBD   05B3               M                                 andwf   outputHi,f
0BBE   2BC3           00543                                 goto    fAwningS00b
                      00544 fAwningS00a             outputOn                                ; switch close/open on (open)
0BBF   0830               M                                 movfw   bitmaskLo
0BC0   04B2               M                                 iorwf   outputLo,f
0BC1   0831               M                                 movfw   bitmaskHi
0BC2   04B3               M                                 iorwf   outputHi,f
0BC3   083D           00545 fAwningS00b             movfw   funcOutBits
                      00546                                 pcall   genBitmask              ; generate bitmask for power (lower nibb
                            le)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BC4   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 101


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00547                                 outputOn                                ; switch power on
0BC5   0830               M                                 movfw   bitmaskLo
0BC6   04B2               M                                 iorwf   outputLo,f
0BC7   0831               M                                 movfw   bitmaskHi
0BC8   04B3               M                                 iorwf   outputHi,f
                      00548 
0BC9   0A3A           00549                                 incf    paramPtr2,w
                      00550                                 pcall   genDelay                ; set up delay T3
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BCA   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0BCB   29C4           00551                                 goto    dispatchCont
                      00552 
0BCC   1A38           00553 fAwningS01              btfsc   rxInput,4               ; check for pressed key (positive edge)
0BCD   2BD2           00554                                 goto    fAwningStop
                      00555 
0BCE   0A3A           00556                                 incf    paramPtr2,w
                      00557                                 pcall   compareTime             ; check if delay T3 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BCF   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 102


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0BD0   1803 29C4      00558                                 bc              dispatchCont    ; not yet
                      00559 
0BD2   083A           00560 fAwningStop             movfw   paramPtr2
0BD3   0084           00561                                 movwf   FSR
0BD4   3002           00562                                 movlw   0x02                    ; next state S02 (protection interval)
0BD5   0080           00563                                 movwf   INDF
                      00564 
0BD6   083D           00565                                 movfw   funcOutBits
                      00566                                 pcall   genBitmask              ; generate bitmask for power (lower nibb
                            le)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BD7   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00567                                 outputOff                               ; switch power off
0BD8   0930               M                                 comf    bitmaskLo,w
0BD9   05B2               M                                 andwf   outputLo,f
0BDA   0931               M                                 comf    bitmaskHi,w
0BDB   05B3               M                                 andwf   outputHi,f
0BDC   0E3D           00568                                 swapf   funcOutBits,w   ; generate bitmask for close/open (upper nibble)
                      00569                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BDD   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 103


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00570                                 outputOff                               ; switch close/open off (close)
0BDE   0930               M                                 comf    bitmaskLo,w
0BDF   05B2               M                                 andwf   outputLo,f
0BE0   0931               M                                 comf    bitmaskHi,w
0BE1   05B3               M                                 andwf   outputHi,f
                      00571 
0BE2   083C           00572                                 movfw   funcPrescMode   ; set up prescaler
0BE3   390F           00573                                 andlw   0x0f
0BE4   3810           00574                                 iorlw   0x10
0BE5   00BC           00575                                 movwf   funcPrescMode
0BE6   3005           00576                                 movlw   0x05                    ; set up delay
0BE7   00C1           00577                                 movwf   funcDelay
0BE8   0A3A           00578                                 incf    paramPtr2,w
                      00579                                 pcall   genDelay                ; set up delay T4
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BE9   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0BEA   29C4           00580                                 goto    dispatchCont
                      00581 
0BEB   1A38           00582 fAwningS02              btfsc   rxInput,4               ; check for pressed key (positive edge)
0BEC   2BD2           00583                                 goto    fAwningStop
0BED   1AB8           00584                                 btfsc   rxInput,5               ; check for released key (negative edge)
0BEE   2BD2           00585                                 goto    fAwningStop
                      00586 
0BEF   0A3A           00587                                 incf    paramPtr2,w
                      00588                                 pcall   compareTime             ; check if delay T4 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 104


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BF0   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0BF1   1803 29C4      00589                                 bc              dispatchCont    ; not yet
                      00590 
0BF3   083A           00591                                 movfw   paramPtr2
0BF4   0084           00592                                 movwf   FSR
0BF5   0180           00593                                 clrf    INDF                    ; next state is S00 (idle)
0BF6   29C4           00594                                 goto    dispatchCont
                      00595 
0BF7   0E3D           00596 fAwningC                swapf   funcOutBits,w   ; generate bitmask for close/open (upper nibble)
                      00597                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BF8   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00598                                 outputOff                               ; switch close/open off (close)
0BF9   0930               M                                 comf    bitmaskLo,w
0BFA   05B2               M                                 andwf   outputLo,f
0BFB   0931               M                                 comf    bitmaskHi,w
0BFC   05B3               M                                 andwf   outputHi,f
0BFD   2BC3           00599                                 goto    fAwningS00b
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 105


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00600 
0BFE   0E3D           00601 fAwningO                swapf   funcOutBits,w   ; generate bitmask for close/open (upper nibble)
                      00602                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0BFF   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00603                                 outputOn                                ; switch close/open on (open)
0C00   0830               M                                 movfw   bitmaskLo
0C01   04B2               M                                 iorwf   outputLo,f
0C02   0831               M                                 movfw   bitmaskHi
0C03   04B3               M                                 iorwf   outputHi,f
0C04   2BC3           00604                                 goto    fAwningS00b             ;}
                      00605 
                      00606 
0C05                  00607 fBlind                  ;{
                      00608 ;        +-----+  U-        D-  +-----+
                      00609 ;        | S01 |------+  +------| S11 |
                      00610 ;  +---->|short|  D+  |  |  U+  |short|<----+
                      00611 ;  |     | up  |----->|  |<-----|down |     |
                      00612 ;  |     +-----+      |  |      +-----+     |
                      00613 ;  |        |         |  |         |        |
                      00614 ;  |        | T1      |  |      T1 |        |
                      00615 ;  |        v         |  |         v        |
                      00616 ;  |     +-----+  U-  |  |  D-  +-----+     |
                      00617 ;  |     | S02 |----->|  |<-----| S12 |     |
                      00618 ;  |     |short|  D+  |  |  U+  |short|     |
                      00619 ;  |     |stop |----->|  |<-----|stop |     |
                      00620 ;  |     +-----+      |  |      +-----+     |
                      00621 ;  |        |         |  |         |        |
                      00622 ;  |        | T2      |  |      T2 |        |
                      00623 ;  |        v         |  |         v        |
                      00624 ;  |     +-----+  T3  |  |  T3  +-----+     |
                      00625 ;  |     | S03 |----->|  |<-----| S13 |     |
                      00626 ;  |     |full |  D+  |  |  U+  |full |     |
                      00627 ;  |     | up  |----->|  |<-----|down |     |
                      00628 ;  |     +-----+      |  |      +-----+     |
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 106


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00629 ;  |                  v  v                  |
                      00630 ;  |              +----------+              |
                      00631 ;  |              |    S04   |              |
                      00632 ;  |              |protection|              |
                      00633 ;  |              | interval |              |
                      00634 ;  |              +----------+              |
                      00635 ;  |                    |                   |
                      00636 ;  |                    | T4                |
                      00637 ;  |                    v                   |
                      00638 ;  |                +------+                |
                      00639 ;  |            U+  | S00  |  D+            |
                      00640 ;  +----------------| stop |----------------+
                      00641 ;                   |      |
                      00642 ;                   +------+
                      00643 
0C05   1783           00644                                 bankisel        functionRam
0C06   1E44           00645                                 btfss   funcUber,4              ; need to check the output bit?
0C07   2C15           00646                                 goto    fBlindA                 ; no
                      00647                                 
0C08   083D           00648                                 movfw   funcOutBits
0C09   0644           00649                                 xorwf   funcUber,w
0C0A   390F           00650                                 andlw   0x0f
0C0B   1903 2C12      00651                                 bz              fBlindB                 ; one of our output bits we sear
                            ched for
                      00652 
0C0D   0E3D           00653                                 swapf   funcOutBits,w
0C0E   0644           00654                                 xorwf   funcUber,w
0C0F   390F           00655                                 andlw   0x0f
0C10   1D03 29C4      00656                                 bnz             dispatchCont    ; not the output bit we searched for
                      00657                                 
0C12   1BC4           00658 fBlindB                 btfsc   funcUber,7              ; test for down/up mode
0C13   2CB1           00659                                 goto    fBlindD                 ; blinds down
0C14   2CAA           00660                                 goto    fBlindU                 ; blinds up
                      00661 
0C15   1943           00662 fBlindA                 btfsc   funcSemaphore,2 ; check for blinds up
0C16   2CAA           00663                                 goto    fBlindU
                      00664 
0C17   19C3           00665                                 btfsc   funcSemaphore,3 ; check for blinds down
0C18   2CB1           00666                                 goto    fBlindD
                      00667 
0C19   083A           00668                                 movfw   paramPtr2
0C1A   0084           00669                                 movwf   FSR
0C1B   0880           00670                                 tstf    INDF                    ; test for state 00
0C1C   1903 2C2F      00671                                 bz              fBlindS00
                      00672                                 
0C1E   3001           00673                                 movlw   0x01
0C1F   0600           00674                                 xorwf   INDF,w                  ; test for state 01
0C20   1903 2C4F      00675                                 bz              fBlindS01
                      00676                                 
0C22   3002           00677                                 movlw   0x02
0C23   0600           00678                                 xorwf   INDF,w                  ; test for state 02
0C24   1903 2C6A      00679                                 bz              fBlindS02
                      00680                                 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 107


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0C26   3003           00681                                 movlw   0x03
0C27   0600           00682                                 xorwf   INDF,w                  ; test for state 03
0C28   1903 2C7F      00683                                 bz              fBlindS03
                      00684                                 
0C2A   3004           00685                                 movlw   0x04
0C2B   0600           00686                                 xorwf   INDF,w                  ; test for state 04
0C2C   1903 2C9E      00687                                 bz              fBlindS04
                      00688                                 
0C2E   2C85           00689                                 goto    fBlindStop              ; nothing matched; set state 00
                      00690                                 
0C2F   1E38           00691 fBlindS00               btfss   rxInput,4               ; check for pressed key (positive edge)
0C30   29C4           00692                                 goto    dispatchCont
                      00693                                 
0C31   3001           00694                                 movlw   0x01                    ; next state S01
0C32   0080           00695                                 movwf   INDF
                      00696 
0C33   0E3D           00697                                 swapf   funcOutBits,w   ; generate bitmask for up/down (upper nibble)
                      00698                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C34   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
0C35   1AC4           00699                                 btfsc   funcUber,5              ; test if second input key (up) matched
0C36   2C3C           00700                                 goto    fBlindS00a              ; no, we move down
                      00701                                 outputOff                               ; switch up/down off (up)
0C37   0930               M                                 comf    bitmaskLo,w
0C38   05B2               M                                 andwf   outputLo,f
0C39   0931               M                                 comf    bitmaskHi,w
0C3A   05B3               M                                 andwf   outputHi,f
0C3B   2C40           00702                                 goto    fBlindS00b
                      00703 fBlindS00a              outputOn                                ; switch up/down on (down)
0C3C   0830               M                                 movfw   bitmaskLo
0C3D   04B2               M                                 iorwf   outputLo,f
0C3E   0831               M                                 movfw   bitmaskHi
0C3F   04B3               M                                 iorwf   outputHi,f
0C40   083D           00704 fBlindS00b              movfw   funcOutBits
                      00705                                 pcall   genBitmask              ; generate bitmask for power (lower nibb
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 108


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            le)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C41   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00706                                 outputOn                                ; switch power on
0C42   0830               M                                 movfw   bitmaskLo
0C43   04B2               M                                 iorwf   outputLo,f
0C44   0831               M                                 movfw   bitmaskHi
0C45   04B3               M                                 iorwf   outputHi,f
                      00707 
0C46   083C           00708                                 movfw   funcPrescMode   ; set up prescaler
0C47   390F           00709                                 andlw   0x0f
0C48   3870           00710                                 iorlw   0x70
0C49   00BC           00711                                 movwf   funcPrescMode
0C4A   3001           00712                                 movlw   0x01                    ; set up delay
0C4B   00C1           00713                                 movwf   funcDelay
0C4C   0A3A           00714                                 incf    paramPtr2,w
                      00715                                 pcall   genDelay                ; set up delay T1
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C4D   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 109


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 endif
0C4E   29C4           00716                                 goto    dispatchCont
                      00717 
0C4F   1A38           00718 fBlindS01               btfsc   rxInput,4               ; check for pressed key (positive edge)
0C50   2C85           00719                                 goto    fBlindStop
0C51   1AB8           00720                                 btfsc   rxInput,5               ; check for released key (negative edge)
0C52   2C85           00721                                 goto    fBlindStop
                      00722 
0C53   0A3A           00723                                 incf    paramPtr2,w
                      00724                                 pcall   compareTime             ; check if delay T1 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C54   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0C55   1803 29C4      00725                                 bc              dispatchCont    ; not yet
                      00726                 
0C57   083A           00727 fBlindS01a              movfw   paramPtr2
0C58   0084           00728                                 movwf   FSR
0C59   3002           00729                                 movlw   0x02                    ; next state S02
0C5A   0080           00730                                 movwf   INDF
                      00731                                 
0C5B   083D           00732                                 movfw   funcOutBits
                      00733                                 pcall   genBitmask              ; generate bitmask for power (lower nibb
                            le)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C5C   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 110


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00734                                 outputOff                               ; switch power off
0C5D   0930               M                                 comf    bitmaskLo,w
0C5E   05B2               M                                 andwf   outputLo,f
0C5F   0931               M                                 comf    bitmaskHi,w
0C60   05B3               M                                 andwf   outputHi,f
                      00735 
0C61   083C           00736                                 movfw   funcPrescMode   ; set up prescaler
0C62   390F           00737                                 andlw   0x0f
0C63   3850           00738                                 iorlw   0x50
0C64   00BC           00739                                 movwf   funcPrescMode
0C65   3001           00740                                 movlw   0x01                    ; set up delay
0C66   00C1           00741                                 movwf   funcDelay
0C67   0A3A           00742                                 incf    paramPtr2,w
                      00743                                 pcall   genDelay                ; set up delay T2
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C68   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0C69   29C4           00744                                 goto    dispatchCont
                      00745 
0C6A   1A38           00746 fBlindS02               btfsc   rxInput,4               ; check for pressed key (positive edge)
0C6B   2C85           00747                                 goto    fBlindStop
0C6C   1AB8           00748                                 btfsc   rxInput,5               ; check for released key (negative edge)
0C6D   2C85           00749                                 goto    fBlindStop
                      00750 
0C6E   0A3A           00751                                 incf    paramPtr2,w
                      00752                                 pcall   compareTime             ; check if delay T2 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 111


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C6F   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0C70   1803 29C4      00753                                 bc              dispatchCont    ; not yet
                      00754                 
0C72   083A           00755 fBlindS02a              movfw   paramPtr2
0C73   0084           00756                                 movwf   FSR
0C74   3003           00757                                 movlw   0x03                    ; next state S03
0C75   0080           00758                                 movwf   INDF
                      00759                                 
0C76   083D           00760                                 movfw   funcOutBits
                      00761                                 pcall   genBitmask              ; generate bitmask for power (lower nibb
                            le)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C77   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00762                                 outputOn                                ; switch power on
0C78   0830               M                                 movfw   bitmaskLo
0C79   04B2               M                                 iorwf   outputLo,f
0C7A   0831               M                                 movfw   bitmaskHi
0C7B   04B3               M                                 iorwf   outputHi,f
                      00763 
0C7C   0A3A           00764                                 incf    paramPtr2,w
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 112


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00765                                 pcall   genDelay                ; set up delay T3
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C7D   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0C7E   29C4           00766                                 goto    dispatchCont
                      00767 
0C7F   1A38           00768 fBlindS03               btfsc   rxInput,4               ; check for pressed key (positive edge)
0C80   2C85           00769                                 goto    fBlindStop
                      00770 
0C81   0A3A           00771                                 incf    paramPtr2,w
                      00772                                 pcall   compareTime             ; check if delay T3 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C82   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0C83   1803 29C4      00773                                 bc              dispatchCont    ; not yet
                      00774                 
0C85   083A           00775 fBlindStop              movfw   paramPtr2
0C86   0084           00776                                 movwf   FSR
0C87   3004           00777                                 movlw   0x04                    ; next state S04 (protection interval)
0C88   0080           00778                                 movwf   INDF
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 113


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00779                                 
0C89   083D           00780                                 movfw   funcOutBits
                      00781                                 pcall   genBitmask              ; generate bitmask for power (lower nibb
                            le)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C8A   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00782                                 outputOff                               ; switch power off
0C8B   0930               M                                 comf    bitmaskLo,w
0C8C   05B2               M                                 andwf   outputLo,f
0C8D   0931               M                                 comf    bitmaskHi,w
0C8E   05B3               M                                 andwf   outputHi,f
0C8F   0E3D           00783                                 swapf   funcOutBits,w   ; generate bitmask for up/down (upper nibble)
                      00784                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C90   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00785                                 outputOff                               ; switch up/down off (up)
0C91   0930               M                                 comf    bitmaskLo,w
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 114


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0C92   05B2               M                                 andwf   outputLo,f
0C93   0931               M                                 comf    bitmaskHi,w
0C94   05B3               M                                 andwf   outputHi,f
                      00786 
0C95   083C           00787                                 movfw   funcPrescMode   ; set up prescaler
0C96   390F           00788                                 andlw   0x0f
0C97   3810           00789                                 iorlw   0x10
0C98   00BC           00790                                 movwf   funcPrescMode
0C99   3005           00791                                 movlw   0x05                    ; set up delay
0C9A   00C1           00792                                 movwf   funcDelay
0C9B   0A3A           00793                                 incf    paramPtr2,w
                      00794                                 pcall   genDelay                ; set up delay T4
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0C9C   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0C9D   29C4           00795                                 goto    dispatchCont
                      00796 
0C9E   1A38           00797 fBlindS04               btfsc   rxInput,4               ; check for pressed key (positive edge)
0C9F   2C85           00798                                 goto    fBlindStop
0CA0   1AB8           00799                                 btfsc   rxInput,5               ; check for released key (negative edge)
0CA1   2C85           00800                                 goto    fBlindStop
                      00801 
0CA2   0A3A           00802                                 incf    paramPtr2,w
                      00803                                 pcall   compareTime             ; check if delay T4 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0CA3   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 115


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0CA4   1803 29C4      00804                                 bc              dispatchCont    ; not yet
                      00805 
0CA6   083A           00806                                 movfw   paramPtr2
0CA7   0084           00807                                 movwf   FSR
0CA8   0180           00808                                 clrf    INDF                    ; next state is S00 (idle)
0CA9   29C4           00809                                 goto    dispatchCont
                      00810 
0CAA   0E3D           00811 fBlindU                 swapf   funcOutBits,w   ; generate bitmask for up/down (upper nibble)
                      00812                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0CAB   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00813                                 outputOff                               ; switch up/down off (up)
0CAC   0930               M                                 comf    bitmaskLo,w
0CAD   05B2               M                                 andwf   outputLo,f
0CAE   0931               M                                 comf    bitmaskHi,w
0CAF   05B3               M                                 andwf   outputHi,f
0CB0   2C57           00814                                 goto    fBlindS01a
                      00815 
0CB1   0E3D           00816 fBlindD                 swapf   funcOutBits,w   ; generate bitmask for up/down (upper nibble)
                      00817                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 116


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0CB2   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00818                                 outputOn                                ; switch up/down on (down)
0CB3   0830               M                                 movfw   bitmaskLo
0CB4   04B2               M                                 iorwf   outputLo,f
0CB5   0831               M                                 movfw   bitmaskHi
0CB6   04B3               M                                 iorwf   outputHi,f
0CB7   2C57           00819                                 goto    fBlindS01a              ;}
                      00820                                 
                      00821 
0CB8                  00822 fWindow                 ;{
                      00823 ;        +-----+  U-        D-  +-----+
                      00824 ;        | S01 |------+  +------| S11 |
                      00825 ;  +---->|short|  D+  |  |  U+  |short|<----+
                      00826 ;  |     | up  |----->|  |<-----|down |     |
                      00827 ;  |     +-----+      |  |      +-----+     |
                      00828 ;  |        |         |  |         |        |
                      00829 ;  |        | T1      |  |      T1 |        |
                      00830 ;  |        v         |  |         v        |
                      00831 ;  |     +-----+  U-  |  |  D-  +-----+     |
                      00832 ;  |     | S02 |----->|  |<-----| S12 |     |
                      00833 ;  |     |short|  D+  |  |  U+  |short|     |
                      00834 ;  |     |stop |----->|  |<-----|stop |     |
                      00835 ;  |     +-----+      |  |      +-----+     |
                      00836 ;  |        |         |  |         |        |
                      00837 ;  |        | T2      |  |      T2 |        |
                      00838 ;  |        v         |  |         v        |
                      00839 ;  |     +-----+  T3  |  |  T3  +-----+     |
                      00840 ;  |     | S03 |----->|  |<-----| S13 |     |
                      00841 ;  |     |full |  D+  |  |  U+  |full |     |
                      00842 ;  |     | up  |----->|  |<-----|down |     |
                      00843 ;  |     +-----+      |  |      +-----+     |
                      00844 ;  |                  v  v                  |
                      00845 ;  |              +----------+              |
                      00846 ;  |              |    S04   |              |
                      00847 ;  |              |protection|              |
                      00848 ;  |              | interval |              |
                      00849 ;  |              +----------+              |
                      00850 ;  |                    |                   |
                      00851 ;  |                    | T4                |
                      00852 ;  |                    v                   |
                      00853 ;  |                +------+                |
                      00854 ;  |            U+  | S00  |  D+            |
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 117


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00855 ;  +----------------| stop |----------------+
                      00856 ;                   |      |
                      00857 ;                   +------+
                      00858 
0CB8   1783           00859                                 bankisel        functionRam
0CB9   1E44           00860                                 btfss   funcUber,4              ; need to check the output bit?
0CBA   2CC8           00861                                 goto    fWindowA                ; no
                      00862                                 
0CBB   083D           00863                                 movfw   funcOutBits
0CBC   0644           00864                                 xorwf   funcUber,w
0CBD   390F           00865                                 andlw   0x0f
0CBE   1903 2CC5      00866                                 bz              fWindowB                ; one of our output bits we sear
                            ched for
                      00867 
0CC0   0E3D           00868                                 swapf   funcOutBits,w
0CC1   0644           00869                                 xorwf   funcUber,w
0CC2   390F           00870                                 andlw   0x0f
0CC3   1D03 29C4      00871                                 bnz             dispatchCont    ; not the output bit we searched for
                      00872                                 
0CC5   1BC4           00873 fWindowB                btfsc   funcUber,7              ; test for open/close mode
0CC6   2D37           00874                                 goto    fWindowO                ; windows open
0CC7   2D1A           00875                                 goto    fWindowC                ; windows close
                      00876 
0CC8   1A43           00877 fWindowA                btfsc   funcSemaphore,4 ; check for window close
0CC9   2D1A           00878                                 goto    fWindowC
                      00879 
0CCA   1AC3           00880                                 btfsc   funcSemaphore,5 ; check for windows open
0CCB   2D37           00881                                 goto    fWindowO
                      00882 
0CCC   083A           00883                                 movfw   paramPtr2
0CCD   0084           00884                                 movwf   FSR
0CCE   0880           00885                                 tstf    INDF                    ; test for state 00
0CCF   1903 2CEA      00886                                 bz              fWindowS00
                      00887                                 
0CD1   3001           00888                                 movlw   0x01
0CD2   0600           00889                                 xorwf   INDF,w                  ; test for state 01
0CD3   1903 2D12      00890                                 bz              fWindowS01
                      00891                                 
0CD5   3011           00892                                 movlw   0x11
0CD6   0600           00893                                 xorwf   INDF,w                  ; test for state 11
0CD7   1903 2D2F      00894                                 bz              fWindowS11
                      00895                                 
0CD9   3002           00896                                 movlw   0x02
0CDA   0600           00897                                 xorwf   INDF,w                  ; test for state 02
0CDB   1903 2D4C      00898                                 bz              fWindowS02
                      00899                                 
0CDD   3012           00900                                 movlw   0x12
0CDE   0600           00901                                 xorwf   INDF,w                  ; test for state 12
0CDF   1903 2D61      00902                                 bz              fWindowS12
                      00903                                 
0CE1   3003           00904                                 movlw   0x03
0CE2   0600           00905                                 xorwf   INDF,w                  ; test for state 03
0CE3   1903 2D76      00906                                 bz              fWindowS03
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 118


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00907                                 
0CE5   3004           00908                                 movlw   0x04
0CE6   0600           00909                                 xorwf   INDF,w                  ; test for state 04
0CE7   1903 2D91      00910                                 bz              fWindowS04
                      00911                                 
0CE9   2D7C           00912                                 goto    fWindowStop             ; nothing matched; set state 00
                      00913                                 
0CEA   1E38           00914 fWindowS00              btfss   rxInput,4               ; check for pressed key (positive edge)
0CEB   29C4           00915                                 goto    dispatchCont
                      00916                                 
0CEC   3004           00917                                 movlw   0x04                    ; we use only the prescaler for this del
                            ay
0CED   00C1           00918                                 movwf   funcDelay
0CEE   0A3A           00919                                 incf    paramPtr2,w
                      00920                                 pcall   genDelay                ; set up delay T1
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0CEF   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
                      00921 
0CF0   083A           00922                                 movfw   paramPtr2
0CF1   0084           00923                                 movwf   FSR
                      00924 
0CF2   1EC4           00925                                 btfss   funcUber,5              ; test if second input key (close) match
                            ed
0CF3   2D03           00926                                 goto    fWindowS00a             ; no, we are opening
                      00927 
0CF4   083D           00928                                 movfw   funcOutBits
                      00929                                 pcall   genBitmask              ; generate bitmask open (lower nibble)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0CF5   2730               M                                         call    genBitmask
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 119


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00930                                 outputOff                               ; switch open off
0CF6   0930               M                                 comf    bitmaskLo,w
0CF7   05B2               M                                 andwf   outputLo,f
0CF8   0931               M                                 comf    bitmaskHi,w
0CF9   05B3               M                                 andwf   outputHi,f
0CFA   0E3D           00931                                 swapf   funcOutBits,w   ; generate bitmask close (upper nibble)
                      00932                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0CFB   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00933                                 outputOn                                ; switch close on
0CFC   0830               M                                 movfw   bitmaskLo
0CFD   04B2               M                                 iorwf   outputLo,f
0CFE   0831               M                                 movfw   bitmaskHi
0CFF   04B3               M                                 iorwf   outputHi,f
                      00934 
0D00   3001           00935                                 movlw   0x01                    ; next state S01
0D01   0080           00936                                 movwf   INDF
0D02   29C4           00937                                 goto    dispatchCont
                      00938 
0D03   083D           00939 fWindowS00a             movfw   funcOutBits
                      00940                                 pcall   genBitmask              ; generate bitmask open (lower nibble)
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 120


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D04   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00941                                 outputOn                                ; switch open on
0D05   0830               M                                 movfw   bitmaskLo
0D06   04B2               M                                 iorwf   outputLo,f
0D07   0831               M                                 movfw   bitmaskHi
0D08   04B3               M                                 iorwf   outputHi,f
0D09   0E3D           00942                                 swapf   funcOutBits,w   ; generate bitmask close (upper nibble)
                      00943                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D0A   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00944                                 outputOff                               ; switch close off
0D0B   0930               M                                 comf    bitmaskLo,w
0D0C   05B2               M                                 andwf   outputLo,f
0D0D   0931               M                                 comf    bitmaskHi,w
0D0E   05B3               M                                 andwf   outputHi,f
                      00945 
0D0F   3011           00946                                 movlw   0x11                    ; next state S11
0D10   0080           00947                                 movwf   INDF
0D11   29C4           00948                                 goto    dispatchCont
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 121


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00949 
0D12   1A38           00950 fWindowS01              btfsc   rxInput,4               ; check for pressed key (positive edge)
0D13   2D7C           00951                                 goto    fWindowStop
0D14   1AB8           00952                                 btfsc   rxInput,5               ; check for released key (negative edge)
0D15   2D7C           00953                                 goto    fWindowStop
                      00954 
0D16   0A3A           00955                                 incf    paramPtr2,w
                      00956                                 pcall   compareTime             ; check if delay T1 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D17   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0D18   1803 29C4      00957                                 bc              dispatchCont    ; not yet
                      00958                 
0D1A   083A           00959 fWindowC                movfw   paramPtr2
0D1B   0084           00960                                 movwf   FSR
0D1C   3002           00961                                 movlw   0x02                    ; next state S02
0D1D   0080           00962                                 movwf   INDF
                      00963                                 
0D1E   083D           00964                                 movfw   funcOutBits             ; generate bitmask open (lower nibble)
                      00965                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D1F   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 122


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00966                                 outputOff                               ; switch open off
0D20   0930               M                                 comf    bitmaskLo,w
0D21   05B2               M                                 andwf   outputLo,f
0D22   0931               M                                 comf    bitmaskHi,w
0D23   05B3               M                                 andwf   outputHi,f
                      00967 
0D24   0E3D           00968                                 swapf   funcOutBits,w   ; generate bitmask close (upper nibble)
                      00969                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D25   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00970                                 outputOff                               ; switch close off
0D26   0930               M                                 comf    bitmaskLo,w
0D27   05B2               M                                 andwf   outputLo,f
0D28   0931               M                                 comf    bitmaskHi,w
0D29   05B3               M                                 andwf   outputHi,f
                      00971 
0D2A   3001           00972                                 movlw   0x01                    ; we use only the prescaler for this del
                            ay
0D2B   00C1           00973                                 movwf   funcDelay
0D2C   0A3A           00974                                 incf    paramPtr2,w
                      00975                                 pcall   genDelay                ; set up delay T2
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D2D   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 123


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0D2E   29C4           00976                                 goto    dispatchCont
                      00977 
0D2F   1A38           00978 fWindowS11              btfsc   rxInput,4               ; check for pressed key (positive edge)
0D30   2D7C           00979                                 goto    fWindowStop
0D31   1AB8           00980                                 btfsc   rxInput,5               ; check for released key (negative edge)
0D32   2D7C           00981                                 goto    fWindowStop
                      00982 
0D33   0A3A           00983                                 incf    paramPtr2,w
                      00984                                 pcall   compareTime             ; check if delay T1 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D34   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0D35   1803 29C4      00985                                 bc              dispatchCont    ; not yet
                      00986                 
0D37   083A           00987 fWindowO                movfw   paramPtr2
0D38   0084           00988                                 movwf   FSR
0D39   3012           00989                                 movlw   0x12                    ; next state S12
0D3A   0080           00990                                 movwf   INDF
                      00991                                 
0D3B   083D           00992                                 movfw   funcOutBits             ; generate bitmask open (lower nibble)
                      00993                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 124


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D3C   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00994                                 outputOff                               ; switch open off
0D3D   0930               M                                 comf    bitmaskLo,w
0D3E   05B2               M                                 andwf   outputLo,f
0D3F   0931               M                                 comf    bitmaskHi,w
0D40   05B3               M                                 andwf   outputHi,f
                      00995 
0D41   0E3D           00996                                 swapf   funcOutBits,w   ; generate bitmask close (upper nibble)
                      00997                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D42   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00998                                 outputOff                               ; switch close off
0D43   0930               M                                 comf    bitmaskLo,w
0D44   05B2               M                                 andwf   outputLo,f
0D45   0931               M                                 comf    bitmaskHi,w
0D46   05B3               M                                 andwf   outputHi,f
                      00999 
0D47   3001           01000                                 movlw   0x01                    ; we use only the prescaler for this del
                            ay
0D48   00C1           01001                                 movwf   funcDelay
0D49   0A3A           01002                                 incf    paramPtr2,w
                      01003                                 pcall   genDelay                ; set up delay T2
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 125


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D4A   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0D4B   29C4           01004                                 goto    dispatchCont
                      01005 
0D4C   1A38           01006 fWindowS02              btfsc   rxInput,4               ; check for pressed key (positive edge)
0D4D   2D7C           01007                                 goto    fWindowStop
0D4E   1AB8           01008                                 btfsc   rxInput,5               ; check for released key (negative edge)
0D4F   2D7C           01009                                 goto    fWindowStop
                      01010 
0D50   0A3A           01011                                 incf    paramPtr2,w
                      01012                                 pcall   compareTime             ; check if delay T2 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D51   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0D52   1803 29C4      01013                                 bc              dispatchCont    ; not yet
                      01014                 
0D54   083A           01015                                 movfw   paramPtr2
0D55   0084           01016                                 movwf   FSR
0D56   3003           01017                                 movlw   0x03                    ; next state S03
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 126


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0D57   0080           01018                                 movwf   INDF
                      01019                                 
0D58   0E3D           01020                                 swapf   funcOutBits,w   ; generate bitmask close (upper nibble)
                      01021                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D59   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      01022                                 outputOn                                ; switch close on
0D5A   0830               M                                 movfw   bitmaskLo
0D5B   04B2               M                                 iorwf   outputLo,f
0D5C   0831               M                                 movfw   bitmaskHi
0D5D   04B3               M                                 iorwf   outputHi,f
                      01023 
0D5E   0A3A           01024                                 incf    paramPtr2,w
                      01025                                 pcall   genDelay                ; set up delay T3
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D5F   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0D60   29C4           01026                                 goto    dispatchCont
                      01027 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 127


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0D61   1A38           01028 fWindowS12              btfsc   rxInput,4               ; check for pressed key (positive edge)
0D62   2D7C           01029                                 goto    fWindowStop
0D63   1AB8           01030                                 btfsc   rxInput,5               ; check for released key (negative edge)
0D64   2D7C           01031                                 goto    fWindowStop
                      01032 
0D65   0A3A           01033                                 incf    paramPtr2,w
                      01034                                 pcall   compareTime             ; check if delay T2 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D66   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0D67   1803 29C4      01035                                 bc              dispatchCont    ; not yet
                      01036                 
0D69   083A           01037                                 movfw   paramPtr2
0D6A   0084           01038                                 movwf   FSR
0D6B   3003           01039                                 movlw   0x03                    ; next state S03
0D6C   0080           01040                                 movwf   INDF
                      01041                                 
0D6D   083D           01042                                 movfw   funcOutBits             ; generate bitmask open (lower nibble)
                      01043                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D6E   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 128


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      01044                                 outputOn                                ; switch open on
0D6F   0830               M                                 movfw   bitmaskLo
0D70   04B2               M                                 iorwf   outputLo,f
0D71   0831               M                                 movfw   bitmaskHi
0D72   04B3               M                                 iorwf   outputHi,f
                      01045 
0D73   0A3A           01046                                 incf    paramPtr2,w
                      01047                                 pcall   genDelay                ; set up delay T3
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D74   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0D75   29C4           01048                                 goto    dispatchCont
                      01049 
0D76   1A38           01050 fWindowS03              btfsc   rxInput,4               ; check for pressed key (positive edge)
0D77   2D7C           01051                                 goto    fWindowStop
                      01052 
0D78   0A3A           01053                                 incf    paramPtr2,w
                      01054                                 pcall   compareTime             ; check if delay T3 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D79   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 129


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0D7A   1803 29C4      01055                                 bc              dispatchCont    ; not yet
                      01056                 
0D7C   083A           01057 fWindowStop             movfw   paramPtr2
0D7D   0084           01058                                 movwf   FSR
0D7E   3004           01059                                 movlw   0x04                    ; next state S04 (protection interval)
0D7F   0080           01060                                 movwf   INDF
                      01061                                 
0D80   083D           01062                                 movfw   funcOutBits
                      01063                                 pcall   genBitmask              ; generate bitmask for open
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D81   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      01064                                 outputOff                               ; switch open off
0D82   0930               M                                 comf    bitmaskLo,w
0D83   05B2               M                                 andwf   outputLo,f
0D84   0931               M                                 comf    bitmaskHi,w
0D85   05B3               M                                 andwf   outputHi,f
0D86   0E3D           01065                                 swapf   funcOutBits,w   ; generate bitmask for close
                      01066                                 pcall   genBitmask
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D87   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 130


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      01067                                 outputOff                               ; switch close off
0D88   0930               M                                 comf    bitmaskLo,w
0D89   05B2               M                                 andwf   outputLo,f
0D8A   0931               M                                 comf    bitmaskHi,w
0D8B   05B3               M                                 andwf   outputHi,f
                      01068 
0D8C   3001           01069                                 movlw   0x01                    ; we use only the prescaler for this del
                            ay
0D8D   00C1           01070                                 movwf   funcDelay
0D8E   0A3A           01071                                 incf    paramPtr2,w
                      01072                                 pcall   genDelay                ; set up delay T4
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genDelay)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D8F   2775               M                                         call    genDelay
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genDel
                            ay
                          M                                                 call    genDelay ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genDelay
                          M                                                 call    genDelay
                          M                                         endif
                          M                                 endif
0D90   29C4           01073                                 goto    dispatchCont
                      01074 
0D91   1A38           01075 fWindowS04              btfsc   rxInput,4               ; check for pressed key (positive edge)
0D92   2D7C           01076                                 goto    fWindowStop
0D93   1AB8           01077                                 btfsc   rxInput,5               ; check for released key (negative edge)
0D94   2D7C           01078                                 goto    fWindowStop
                      01079 
0D95   0A3A           01080                                 incf    paramPtr2,w
                      01081                                 pcall   compareTime             ; check if delay T4 has elapsed
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(compareTime)&0x18)                ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 131


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0D96   27A8               M                                         call    compareTime
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", compar
                            eTime
                          M                                                 call    compareTime ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", compareTi
                            me
                          M                                                 call    compareTime
                          M                                         endif
                          M                                 endif
0D97   1803 29C4      01082                                 bc              dispatchCont    ; not yet
                      01083 
0D99   083A           01084                                 movfw   paramPtr2
0D9A   0084           01085                                 movwf   FSR
0D9B   0180           01086                                 clrf    INDF                    ; next state is S00 (idle)
0D9C   29C4           01087                                 goto    dispatchCont    ;}
                      00329 #include                <uberfunctions.asm>
0D9D                  00001 fPowerOff               ;{
                      00002 ; turns off all outputs (except alwaysOn)
0D9D   0836           00003                                 movfw   rxByte2
0D9E   3AFF           00004                                 xorlw   0xff                    ; global power off
0D9F   1903 2DA5      00005                                 bz              fPowerOff1
0DA1   0836           00006                                 movfw   rxByte2
0DA2   0620           00007                                 xorwf   deviceID,w              ; only this device
0DA3   1D03           00008                                 skpz
0DA4   28BD           00009                                 goto    parseRxE
                      00010 
0DA5   01B2           00011 fPowerOff1              clrf    outputLo
0DA6   01B3           00012                                 clrf    outputHi
                      00013                                 scall   clearRam2
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000018                M DEST_HIGH               set     (HIGH(clearRam2)&0x18)                  ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000010                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", clearRam2
                          M                                         nop             ; redundant nops
                          M                                         call    clearRam2
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", clearR
                            am2
                          M                                         endif
                          M 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 132


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_258DEST_HIGH&0x10)
0DA7   160A               M                                         bsf     PCLATH,4        
                          M                                 else
                          M                                         bcf     PCLATH,4
                          M                                 endif
0DA8   2058               M                                                 call    clearRam2
                          M                                                 setpclath4      SOURCE_HIGH
                          M ;       setpclath4 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 4 according to 
                          M ;       'variable' PCLATH_4
                          M                                 if(_258SOURCE_HIGH&0x10)
                          M                                         bsf     PCLATH,4        
                          M                                 else
0DA9   120A               M                                         bcf     PCLATH,4
                          M                                 endif
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M                                                 call    clearRam2
                          M                                                 setpclath3      SOURCE_HIGH
                          M                                         endif
                          M                                 endif
0DAA   28BD           00014                                 goto    parseRxE
                      00015                                 ;}
                      00016                                 
0DAB                  00017 fReset                  ;{
0DAB   0836           00018                                 movfw   rxByte2
0DAC   3AFF           00019                                 xorlw   0xff                    ; global reset
0DAD   1903 2DB3      00020                                 bz              fReset1
0DAF   0836           00021                                 movfw   rxByte2
0DB0   0620           00022                                 xorwf   deviceID,w              ; only this device
0DB1   1D03           00023                                 skpz
0DB2   28BD           00024                                 goto    parseRxE
                      00025                                 
                      00026 fReset1                 pcall   safeOutput
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(safeOutput)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0DB3   27D0               M                                         call    safeOutput
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", safeOu
                            tput
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 133


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    safeOutput ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", safeOutpu
                            t
                          M                                                 call    safeOutput
                          M                                         endif
                          M                                 endif
0DB4   2800           00027                                 goto    0x0000
                      00028                                 ;}
                      00029                                 
0DB5                  00030 fPoll                   ;{
                      00031 ; return ACK if we are polled
0DB5   0836           00032                                 movfw   rxByte2
0DB6   0620           00033                                 xorwf   deviceID,w              ; our deviceID
0DB7   1D03 28BD      00034                                 bnz             parseRxE                ; no
                      00035         
0DB9   3000           00036                                 movlw   STARTBYTE               ; startByte
                      00037                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0DBA   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0DBB   3003           00038                                 movlw   CMDACK                  ; send ACK
                      00039                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0DBC   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 134


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0DBD   0820           00040                                 movfw   deviceID                ; our deviceID
                      00041                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0DBE   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
                      00042 
0DBF   28BD           00043                                 goto    parseRxE
                      00044                                 ;}
                      00045 
0DC0                  00046 fOff                    ;{
0DC0   0835           00047                                 movfw   rxByte1
0DC1   39F0           00048                                 andlw   0xf0
0DC2   3A40           00049                                 xorlw   CMDSOFF                 ; dedicated output on our device
0DC3   1D03 2DCE      00050                                 bnz             fOff1
0DC5   0836           00051                                 movfw   rxByte2
0DC6   0620           00052                                 xorwf   deviceID,w              ; only this device
0DC7   1D03 28BD      00053                                 bnz             parseRxE                ; not us
0DC9   0835           00054                                 movfw   rxByte1
0DCA   390F           00055                                 andlw   0x0f                    ; get output number
0DCB   00C4           00056                                 movwf   funcUber
0DCC   1644           00057                                 bsf             funcUber,4              ; use the output
0DCD   2DDE           00058                                 goto    fOff2
                      00059 
0DCE   0836           00060 fOff1                   movfw   rxByte2
0DCF   3901           00061                                 andlw   0x01
0DD0   1D03           00062                                 skpz
0DD1   14C3           00063                                 bsf             funcSemaphore,1 ; lights off global
0DD2   0836           00064                                 movfw   rxByte2
0DD3   3902           00065                                 andlw   0x02
0DD4   1D03           00066                                 skpz
0DD5   1543           00067                                 bsf             funcSemaphore,2 ; blinds up global
0DD6   0836           00068                                 movfw   rxByte2
0DD7   3904           00069                                 andlw   0x04
0DD8   1D03           00070                                 skpz
0DD9   1643           00071                                 bsf             funcSemaphore,4 ; window close global
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 135


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0DDA   0836           00072                                 movfw   rxByte2
0DDB   3908           00073                                 andlw   0x08
0DDC   1D03           00074                                 skpz
0DDD   1743           00075                                 bsf             funcSemaphore,6 ; awning close global
                      00076 
0DDE   13C4           00077 fOff2                   bcf             funcUber,7              ; set off mode
0DDF   1744           00078                                 bsf             funcUber,6              ; set service mode
                      00079                                 pcall   dispatch
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(dispatch)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0DE0   2124               M                                         call    dispatch
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", dispat
                            ch
                          M                                                 call    dispatch ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", dispatch
                          M                                                 call    dispatch
                          M                                         endif
                          M                                 endif
0DE1   01C3           00080                                 clrf    funcSemaphore
0DE2   01C4           00081                                 clrf    funcUber                ; set non service mode
0DE3   28BD           00082                                 goto    parseRxE
                      00083                                 ;}
                      00084 
0DE4                  00085 fOn                             ;{
0DE4   0835           00086                                 movfw   rxByte1
0DE5   39F0           00087                                 andlw   0xf0
0DE6   3A60           00088                                 xorlw   CMDSON                  ; dedicated output on our device
0DE7   1D03 2DF2      00089                                 bnz             fOn1
0DE9   0836           00090                                 movfw   rxByte2
0DEA   0620           00091                                 xorwf   deviceID,w              ; only this device
0DEB   1D03 28BD      00092                                 bnz             parseRxE                ; not us
0DED   0835           00093                                 movfw   rxByte1
0DEE   390F           00094                                 andlw   0x0f                    ; get output number
0DEF   00C4           00095                                 movwf   funcUber
0DF0   1644           00096                                 bsf             funcUber,4              ; use the output
0DF1   2E02           00097                                 goto    fOn2
                      00098                                 
0DF2   0836           00099 fOn1                    movfw   rxByte2
0DF3   3901           00100                                 andlw   0x01
0DF4   1D03           00101                                 skpz
0DF5   1443           00102                                 bsf             funcSemaphore,0 ; lights on global
0DF6   0836           00103                                 movfw   rxByte2
0DF7   3902           00104                                 andlw   0x02
0DF8   1D03           00105                                 skpz
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 136


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0DF9   15C3           00106                                 bsf             funcSemaphore,3 ; blinds down global
0DFA   0836           00107                                 movfw   rxByte2
0DFB   3904           00108                                 andlw   0x04
0DFC   1D03           00109                                 skpz
0DFD   16C3           00110                                 bsf             funcSemaphore,5 ; window open global
0DFE   0836           00111                                 movfw   rxByte2
0DFF   3908           00112                                 andlw   0x08
0E00   1D03           00113                                 skpz
0E01   17C3           00114                                 bsf             funcSemaphore,7 ; awning open global
                      00115 
0E02   17C4           00116 fOn2                    bsf             funcUber,7              ; set on mode
0E03   1744           00117                                 bsf             funcUber,6              ; set service mode
                      00118                                 pcall   dispatch
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(dispatch)&0x18)                   ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E04   2124               M                                         call    dispatch
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", dispat
                            ch
                          M                                                 call    dispatch ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", dispatch
                          M                                                 call    dispatch
                          M                                         endif
                          M                                 endif
0E05   01C3           00119                                 clrf    funcSemaphore
0E06   01C4           00120                                 clrf    funcUber                ; set non service mode
0E07   28BD           00121                                 goto    parseRxE
                      00122                                 ;}
                      00123                                 
0E08                  00124 fRdTime                 ;{
0E08   0836           00125                                 movfw   rxByte2
0E09   0620           00126                                 xorwf   deviceID,w              ; only this device
0E0A   1D03 28BD      00127                                 bnz             parseRxE                ; not us
                      00128                                 
0E0C   3000           00129                                 movlw   STARTBYTE               ; startByte
                      00130                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E0D   2704               M                                         call    putTx
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 137


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E0E   300B           00131                                 movlw   CMDTGACK                ; send ACK
                      00132                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E0F   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E10   0820           00133                                 movfw   deviceID                ; send Device ID
                      00134                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E11   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E12   0874           00135                                 movfw   time                    ; send time
                      00136                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 138


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E13   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E14   0875           00137                                 movfw   time+1                  ; send time
                      00138                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E15   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E16   0876           00139                                 movfw   time+2                  ; send time
                      00140                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E17   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 139


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E18   0877           00141                                 movfw   time+3                  ; send time
                      00142                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E19   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E1A   0878           00143                                 movfw   time+4                  ; send time
                      00144                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E1B   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
                      00145 
0E1C   28BD           00146                                 goto    parseRxE
                      00147                                 ;}
                      00148 
0E1D                  00149 fWrTime                 ;{
0E1D   0836           00150                                 movfw   rxByte2
0E1E   3AFF           00151                                 xorlw   0xff                    ; global write time
0E1F   1903 2E25      00152                                 bz              fWrTime1
                      00153 
0E21   0836           00154                                 movfw   rxByte2
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 140


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0E22   0620           00155                                 xorwf   deviceID,w              ; only this device
0E23   1D03 28BD      00156                                 bnz             parseRxE                ; not us
                      00157                                 
                      00158 fWrTime1                pcall   getRx                   ; receive time
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E25   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E26   1903 2E25      00159                                 bz              fWrTime1
0E28   00F4           00160                                 movwf   time
                      00161 fWrTime2                pcall   getRx                   ; receive time
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E29   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E2A   1903 2E29      00162                                 bz              fWrTime2
0E2C   00F5           00163                                 movwf   time+1
                      00164 fWrTime3                pcall   getRx                   ; receive time
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 141


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E2D   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E2E   1903 2E2D      00165                                 bz              fWrTime3
0E30   00F6           00166                                 movwf   time+2
                      00167 fWrTime4                pcall   getRx                   ; receive time
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E31   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E32   1903 2E31      00168                                 bz              fWrTime4
0E34   00F7           00169                                 movwf   time+3
                      00170 fWrTime5                pcall   getRx                   ; receive time
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E35   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 142


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0E36   1903 2E35      00171                                 bz              fWrTime5
0E38   00F8           00172                                 movwf   time+4
0E39   28BD           00173                                 goto    parseRxE
                      00174 
0E3A   3005           00175 fWrTime6                movlw   0x05
0E3B   00D3           00176                                 movwf   skipRxCnt               ; 5 bytes to skip
0E3C   28BD           00177                                 goto    parseRxE
                      00178                                 ;}
                      00179 
0E3D                  00180 fRdConfig               ;{
0E3D   0836           00181                                 movfw   rxByte2
0E3E   0620           00182                                 xorwf   deviceID,w              ; only this device
0E3F   1D03 28BD      00183                                 bnz             parseRxE                ; not us
                      00184 
0E41   3000           00185                                 movlw   STARTBYTE               ; startByte
                      00186                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E42   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E43   300D           00187                                 movlw   CMDCGACK                ; send ACK
                      00188                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E44   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 143


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 endif
0E45   0820           00189                                 movfw   deviceID                ; send Device ID (this is also the first
                             byte in the eeprom)
                      00190                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E46   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E47   3001           00191                                 movlw   0x01
0E48   00D2           00192                                 movwf   cfgTxCnt                ; init config transmit counter
                      00193 
0E49   28BD           00194                                 goto    parseRxE
                      00195                                 ;}
                      00196 
0E4A                  00197 fWrConfig               ;{
0E4A   0836           00198                                 movfw   rxByte2
0E4B   0620           00199                                 xorwf   deviceID,w              ; only this device
0E4C   1D03 2E70      00200                                 bnz             fWrConfig7              ; not us
                      00201 
0E4E   01D1           00202                                 clrf    cfgRxCnt
                      00203 fWrConfig1              pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E4F   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 144


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0E50   1903 2E4F      00204                                 bz              fWrConfig1
0E52   00D8           00205                                 movwf   eeByte
0E53   0851           00206                                 movfw   cfgRxCnt
0E54   00E2           00207                                 movwf   displayram+7
                      00208                                 pcall   eeWrite
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(eeWrite)&0x18)                    ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E55   27F4               M                                         call    eeWrite
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", eeWrit
                            e
                          M                                                 call    eeWrite ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", eeWrite
                          M                                                 call    eeWrite
                          M                                         endif
                          M                                 endif
0E56   1283 1303      00209                                 banksel cfgRxCnt
0E58   0AD1           00210                                 incf    cfgRxCnt,f
0E59   0851           00211                                 movfw   cfgRxCnt
0E5A   390F           00212                                 andlw   0x0f
0E5B   1D03 2E4F      00213                                 bnz             fWrConfig1
                      00214 
0E5D   3000           00215                                 movlw   STARTBYTE               ; startByte
                      00216                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E5E   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E5F   3003           00217                                 movlw   CMDACK                  ; send ACK
                      00218                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 145


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E60   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0E61   0820           00219                                 movfw   deviceID                ; send Device ID
                      00220                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E62   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
                      00221 
                      00222 fWrConfig3              pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E63   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 146


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E64   1903 2E63      00223                                 bz              fWrConfig3
                      00224 fWrConfig4              pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E66   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E67   1903 2E66      00225                                 bz              fWrConfig4
                      00226 fWrConfig5              pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E69   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E6A   1903 2E69      00227                                 bz              fWrConfig5
0E6C   0851           00228                                 movfw   cfgRxCnt
0E6D   1D03 2E4F      00229                                 bnz             fWrConfig1
0E6F   2800           00230                                 goto    main
                      00231 
                      00232 
0E70   3010           00233 fWrConfig7              movlw   0x10
0E71   00D1           00234                                 movwf   cfgRxCnt
0E72   0851           00235 fWrConfig8              movfw   cfgRxCnt
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 147


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0E73   00E2           00236                                 movwf   displayram+7
0E74   3013           00237                                 movlw   0x13
0E75   00D3           00238                                 movwf   skipRxCnt
0E76   08D3           00239 fWrConfig9              tstf    skipRxCnt               ; wait until chunk and ack read
0E77   1D03 2E76      00240                                 bnz             fWrConfig9
0E79   0BD1           00241                                 decfsz  cfgRxCnt,f
0E7A   2E72           00242                                 goto    fWrConfig8
0E7B   28BD           00243                                 goto    parseRxE
                      00244                                 ;}
                      00245 
0E7C                  00246 fCOutput                ;{
0E7C   0836           00247                                 movfw   rxByte2
0E7D   0620           00248                                 xorwf   deviceID,w              ; only this device
0E7E   1D03 28BD      00249                                 bnz             parseRxE                ; not us
                      00250                                 
0E80   0835           00251                                 movfw   rxByte1
0E81   390F           00252                                 andlw   0x0f
                      00253                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E82   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00254                                 outputOff
0E83   0930               M                                 comf    bitmaskLo,w
0E84   05B2               M                                 andwf   outputLo,f
0E85   0931               M                                 comf    bitmaskHi,w
0E86   05B3               M                                 andwf   outputHi,f
                      00255 
0E87   28BD           00256                                 goto    parseRxE
                      00257                                 ;}
                      00258                                 
0E88                  00259 fSOutput                ;{
0E88   0836           00260                                 movfw   rxByte2
0E89   0620           00261                                 xorwf   deviceID,w              ; only this device
0E8A   1D03 28BD      00262                                 bnz             parseRxE                ; not us
                      00263                                 
0E8C   0835           00264                                 movfw   rxByte1
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 148


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0E8D   390F           00265                                 andlw   0x0f
                      00266                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E8E   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00267                                 outputOn
0E8F   0830               M                                 movfw   bitmaskLo
0E90   04B2               M                                 iorwf   outputLo,f
0E91   0831               M                                 movfw   bitmaskHi
0E92   04B3               M                                 iorwf   outputHi,f
                      00268 
0E93   28BD           00269                                 goto    parseRxE
                      00270                                 ;}
                      00271                                 
0E94                  00272 fWrOutputs              ;{
0E94   0836           00273                                 movfw   rxByte2
0E95   0620           00274                                 xorwf   deviceID,w              ; only this device
0E96   1D03 2EA1      00275                                 bnz             fWrOutputs3             ; not us
                      00276                                 
                      00277 fWrOutputs1             pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E98   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 149


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         endif
                          M                                 endif
0E99   1903 2E98      00278                                 bz              fWrOutputs1
0E9B   00B2           00279                                 movwf   outputLo
                      00280 fWrOutputs2             pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0E9C   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0E9D   1903 2E9C      00281                                 bz              fWrOutputs2
0E9F   00B3           00282                                 movwf   outputHi
0EA0   28BD           00283                                 goto    parseRxE
                      00284 
                      00285 fWrOutputs3             pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EA1   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0EA2   1903 2EA1      00286                                 bz              fWrOutputs3
                      00287 fWrOutputs4             pcall   getRx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(getRx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 150


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EA4   2719               M                                         call    getRx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", getRx
                          M                                                 call    getRx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", getRx
                          M                                                 call    getRx
                          M                                         endif
                          M                                 endif
0EA5   1903 2EA4      00288                                 bz              fWrOutputs4
                      00289 
0EA7   28BD           00290                                 goto    parseRxE
                      00291                                 ;}
                      00292 
0EA8                  00293 fRdInput                ;{
0EA8   0836           00294                                 movfw   rxByte2
0EA9   0620           00295                                 xorwf   deviceID,w              ; only this device
0EAA   1D03 28BD      00296                                 bnz             parseRxE                ; not us
                      00297                                 
0EAC   3000           00298                                 movlw   STARTBYTE               ; startByte
                      00299                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EAD   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EAE   3008           00300                                 movlw   CMDIOANS                ; send answer
                      00301                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 151


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0EAF   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EB0   0820           00302                                 movfw   deviceID                ; send Device ID
                      00303                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EB1   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
                      00304 
0EB2   0835           00305                                 movfw   rxByte1
0EB3   390F           00306                                 andlw   0x0f
                      00307                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EB4   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 152


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 endif
                      00308 
0EB5   0824           00309                                 movfw   iInputLo                ; check lo input
0EB6   0530           00310                                 andwf   bitmaskLo,w
0EB7   1D03 2EC2      00311                                 bnz             fRdInput1
                      00312                                 
0EB9   0825           00313                                 movfw   iInputHi                ; check hi input
0EBA   0531           00314                                 andwf   bitmaskHi,w
0EBB   1D03 2EC2      00315                                 bnz             fRdInput1
                      00316 
0EBD   0103           00317                                 clrw
                      00318                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EBE   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EBF   0103           00319                                 clrw
                      00320                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EC0   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EC1   28BD           00321                                 goto    parseRxE
                      00322 
0EC2   30FF           00323 fRdInput1               movlw   0xff
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 153


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00324                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EC3   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EC4   30FF           00325                                 movlw   0xff
                      00326                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EC5   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EC6   28BD           00327                                 goto    parseRxE
                      00328                                 ;}
                      00329 
0EC7                  00330 fRdInputs               ;{
0EC7   0836           00331                                 movfw   rxByte2
0EC8   0620           00332                                 xorwf   deviceID,w              ; only this device
0EC9   1D03 28BD      00333                                 bnz             parseRxE                ; not us
                      00334                                 
0ECB   3000           00335                                 movlw   STARTBYTE               ; startByte
                      00336                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 154


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0ECC   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0ECD   3008           00337                                 movlw   CMDIOANS                ; send answer
                      00338                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0ECE   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0ECF   0820           00339                                 movfw   deviceID                ; send Device ID
                      00340                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0ED0   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 155


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 endif
0ED1   0824           00341                                 movfw   iInputLo                ; send Lo Input
                      00342                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0ED2   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0ED3   0825           00343                                 movfw   iInputHi                ; send Hi Input
                      00344                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0ED4   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
                      00345 
0ED5   28BD           00346                                 goto    parseRxE
                      00347                                 ;}
                      00348 
0ED6                  00349 fRdOutput               ;{
0ED6   0836           00350                                 movfw   rxByte2
0ED7   0620           00351                                 xorwf   deviceID,w              ; only this device
0ED8   1D03 28BD      00352                                 bnz             parseRxE                ; not us
                      00353                                 
0EDA   3000           00354                                 movlw   STARTBYTE               ; startByte
                      00355                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 156


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EDB   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EDC   3008           00356                                 movlw   CMDIOANS                ; send answer
                      00357                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EDD   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EDE   0820           00358                                 movfw   deviceID                ; send Device ID
                      00359                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EDF   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 157


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
                      00360 
0EE0   0835           00361                                 movfw   rxByte1
0EE1   390F           00362                                 andlw   0x0f
                      00363                                 pcall   genBitmask              ; generate bitmask for output
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(genBitmask)&0x18)                 ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EE2   2730               M                                         call    genBitmask
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", genBit
                            mask
                          M                                                 call    genBitmask ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", genBitmas
                            k
                          M                                                 call    genBitmask
                          M                                         endif
                          M                                 endif
                      00364 
0EE3   0832           00365                                 movfw   outputLo                ; check lo output
0EE4   0530           00366                                 andwf   bitmaskLo,w
0EE5   1D03 2EF0      00367                                 bnz             fRdOutput1
                      00368                                 
0EE7   0833           00369                                 movfw   outputHi                ; check hi output
0EE8   0531           00370                                 andwf   bitmaskHi,w
0EE9   1D03 2EF0      00371                                 bnz             fRdOutput1
                      00372 
0EEB   0103           00373                                 clrw
                      00374                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EEC   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 158


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EED   0103           00375                                 clrw
                      00376                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EEE   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EEF   28BD           00377                                 goto    parseRxE
                      00378 
0EF0   30FF           00379 fRdOutput1              movlw   0xff
                      00380                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EF1   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EF2   30FF           00381                                 movlw   0xff
                      00382                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 159


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EF3   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EF4   28BD           00383                                 goto    parseRxE
                      00384                                 ;}
                      00385 
0EF5                  00386 fRdOutputs              ;{
0EF5   0836           00387                                 movfw   rxByte2
0EF6   0620           00388                                 xorwf   deviceID,w              ; only this device
0EF7   1D03 28BD      00389                                 bnz             parseRxE                ; not us
                      00390                                 
0EF9   3000           00391                                 movlw   STARTBYTE               ; startByte
                      00392                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EFA   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EFB   3008           00393                                 movlw   CMDIOANS                ; send answer
                      00394                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EFC   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 160


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EFD   0820           00395                                 movfw   deviceID                ; send Device ID
                      00396                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0EFE   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0EFF   0832           00397                                 movfw   outputLo                ; send Lo Output
                      00398                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0F00   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
0F01   0833           00399                                 movfw   outputHi                ; send Hi Output
                      00400                                 pcall   putTx
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 161


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M DEST_HIGH               set     (HIGH(putTx)&0x18)                      ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0F02   2704               M                                         call    putTx
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", putTx
                          M                                                 call    putTx   ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", putTx
                          M                                                 call    putTx
                          M                                         endif
                          M                                 endif
                      00401 
0F03   28BD           00402                                 goto    parseRxE
                      00403                                 ;}
                      00330 #include                <serial.asm>
0F04                  00001 putTx                   ;{      
0F04   00FB           00002                                 movwf   temp1                   ; temporarily save the char to be sent
0F05   1283 1303      00003                                 banksel txNum
0F07   0847           00004 putTx1                  movfw   txNum                   
0F08   3A20           00005                                 xorlw   BUFSIZE                 ; check if there is free space in the ri
                            ngbuffer
0F09   1903 2F07      00006                                 bz              putTx1                  ; wait for free space
                      00007                                 
0F0B   0845           00008                                 movfw   txPutPtr                ; current write pointer
0F0C   3EC0           00009                                 addlw   LOW(txBuf)              ; base adress of tx buffer
0F0D   0084           00010                                 movwf   FSR                             ; set FSR to current write posit
                            ion
0F0E   1383           00011                                 bankisel        txBuf
                      00012                                 movff   temp1,INDF              ; store char into ringbuffer
                          M ; ---------------------------
                          M ; Macro: MOV FileReg to FileReg
                          M ; ---------------------------
0F0F   087B               M                                 movfw   temp1
0F10   0080               M                                 movwf   INDF
0F11   0AC5           00013                                 incf    txPutPtr,f              ; increment write pointer
0F12   301F           00014                                 movlw   (BUFSIZE)-1             ; BUFSIZE must be to the power of 2
0F13   05C5           00015                                 andwf   txPutPtr,f              ; mask write pointer to get easy wrap ar
                            ound
0F14   0AC7           00016                                 incf    txNum,f                 ; increment number of bytes in ringbuffe
                            r
0F15   308C           00017                                 movlw   PIE1                    ; get adress for periphial irq
0F16   0084           00018                                 movwf   FSR                             ; setup fsr
0F17   1600           00019                                 bsf             INDF,TXIE               ; and enable tx irq
0F18   0008           00020                                 return  ;}
                      00021 
                      00022         
0F19                  00023 getRx                   ;{
                      00024                                 disableirq
                          M ;       disableirq disable global irq 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 162


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000                    M                                 local   STOP_INT
0F19   138B               M STOP_INT                bcf             INTCON,GIE              ; disable global interrupt
0F1A   1B8B               M                                 btfsc   INTCON,GIE              ; check if disabled 
0F1B   2F19               M                                 goto    STOP_INT                ; nope, try again
0F1C   1283 1303      00025                                 banksel rxNum
0F1E   084A           00026                                 movfw   rxNum                   ; check if there is a character in the r
                            ingbuffer
0F1F   1903 2F2D      00027                                 bz              getRx1
                      00028                                 
0F21   0849           00029                                 movfw   rxGetPtr                ; curret read pointer
0F22   3EA0           00030                                 addlw   LOW(rxBuf)              ; base adress of rx buffer
0F23   0084           00031                                 movwf   FSR                             ; set FSR to current read positi
                            on
0F24   1383           00032                                 bankisel        rxBuf
0F25   0AC9           00033                                 incf    rxGetPtr,f              ; increment read pointer
0F26   301F           00034                                 movlw   (BUFSIZE)-1             ; BUFSIZE must be to the power of 2
0F27   05C9           00035                                 andwf   rxGetPtr,f              ; mask read pointer to get easy wrap aro
                            und
0F28   0800           00036                                 movfw   INDF                    ; get char from ringbuffer
0F29   03CA           00037                                 decf    rxNum,f                 ; decrement number of bytes in ringbuffe
                            r
                      00038                                 enableirq
0F2A   178B               M                                 bsf             INTCON,GIE              ; enable global interrupt
0F2B   1103           00039                                 clrz                                    ; clear zero flag
0F2C   0008           00040                                 return
                      00041                                 
                      00042 getRx1                  enableirq
0F2D   178B               M                                 bsf             INTCON,GIE              ; enable global interrupt
0F2E   1503           00043                                 setz                                    ; set zero flag
0F2F   0008           00044                                 return  ;}
                      00045 
                      00046 
                      00331 #include                <utils.asm>
0F30                  00001 genBitmask              ;{
0F30   390F           00002                                 andlw   0x0f
0F31   3EF8           00003                                 addlw   -8
0F32   1803 2F38      00004                                 bc              genBitmask1
0F34   273C           00005                                 call    bitTable
0F35   00B0           00006                                 movwf   bitmaskLo
0F36   01B1           00007                                 clrf    bitmaskHi
0F37   0008           00008                                 return
0F38   273C           00009 genBitmask1             call    bitTable
0F39   00B1           00010                                 movwf   bitmaskHi
0F3A   01B0           00011                                 clrf    bitmaskLo
0F3B   0008           00012 genBitmask2             return  ;}
                      00013 
0F3C                  00014 bitTable                ;{
0F3C   3907           00015                                 andlw   0x07
                      00016                                 tabj
                          M ;{
                          M ;       TABLE_JUMP Calculates an eventual table boundary crossing  
                          M ;       sets up the PCLATH register correctly
                          M ;       Offset must be in w-reg, offset 0 jumps to the next instr. 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 163


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0F3D   00F9               M                                 movwf   tabTemp                 ; save wanted offset
0F3E   3046               M                                 movlw   LOW($+8)                ; get low adress ( of first instr. after
                             macro )
0F3F   07F9               M                                 addwf   tabTemp,f               ; add offset
0F40   300F               M                                 movlw   HIGH($+6)               ; get highest 5 bits ( of first instr. a
                            fter macro )
0F41   1803               M                                 skpnc                                   ; page crossed ? ( 256 byte )
0F42   3E01               M                                 addlw   0x01                    ; Yes add one to high adress
0F43   008A               M                                 movwf   PCLATH                  ; load high adress in latch
0F44   0879               M                                 movf    tabTemp,w               ; get computed adress
0F45   0082               M                                 movwf   PCL                             ; And jump
0F46   3401           00017 bitTable1               retlw   0x01
0F47   3402           00018                                 retlw   0x02
0F48   3404           00019                                 retlw   0x04
0F49   3408           00020                                 retlw   0x08
0F4A   3410           00021                                 retlw   0x10
0F4B   3420           00022                                 retlw   0x20
0F4C   3440           00023                                 retlw   0x40
0F4D   3480           00024                                 retlw   0x80    ;}
                      00025                         
0F4E                  00026 checkOutput             ;{
                      00027 ; compares outputs to bitmask
                      00028 ; in: outputLo/Hi
                      00029 ; in: bitmaskLo/Hi
                      00030 ; out: status-Z
0F4E   0832           00031                                 movfw   outputLo
0F4F   0530           00032                                 andwf   bitmaskLo,w
0F50   1D03           00033                                 skpz
0F51   0008           00034                                 return
0F52   0833           00035                                 movfw   outputHi
0F53   0531           00036                                 andwf   bitmaskHi,w
0F54   0008           00037                                 return  ;}
                      00038 
0F55                  00039 clrDelay                ;{
                      00040 ; zero out all delay bytes
                      00041 ; in: W pointer to delay bytes
0F55   0084           00042                                 movwf   FSR
0F56   1783           00043                                 bsf             STATUS,IRP
0F57   0180           00044                                 clrf    INDF
0F58   0A84           00045                                 incf    FSR,f
0F59   0180           00046                                 clrf    INDF
0F5A   0A84           00047                                 incf    FSR,f
0F5B   0180           00048                                 clrf    INDF
0F5C   0A84           00049                                 incf    FSR,f
0F5D   0180           00050                                 clrf    INDF
0F5E   0A84           00051                                 incf    FSR,f
0F5F   0180           00052                                 clrf    INDF
0F60   0A84           00053                                 incf    FSR,f
0F61   0008           00054                                 return  ;}
                      00055 
0F62                  00056 chkDelay                ;{
                      00057 ; check if all delay bytes are zero
                      00058 ; in: W pointer to delay bytes
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 164


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00059 ; out: status-Z
0F62   0084           00060                                 movwf   FSR
0F63   1783           00061                                 bsf             STATUS,IRP
0F64   0800           00062                                 movf    INDF,w
0F65   0A84           00063                                 incf    FSR,f
0F66   0400           00064                                 iorwf   INDF,w                          
0F67   0A84           00065                                 incf    FSR,f
0F68   0400           00066                                 iorwf   INDF,w                          
0F69   0A84           00067                                 incf    FSR,f
0F6A   0400           00068                                 iorwf   INDF,w                          
0F6B   0A84           00069                                 incf    FSR,f
0F6C   0400           00070                                 iorwf   INDF,w                          
0F6D   0008           00071                                 return  ;}
                      00072                                 
0F6E                  00073 genDelayF               ;{
0F6E   0084           00074                                 movwf   FSR                             ; entry point for fast delays
0F6F   0841           00075                                 movfw   funcDelay
0F70   00FB           00076                                 movwf   temp1
0F71   0E3C           00077                                 swapf   funcPrescMode,w
0F72   390F           00078                                 andlw   0x0f
0F73   3E02           00079                                 addlw   2                               ; smallest interval 1/250 second
0F74   2F7B           00080                                 goto    genDelay0
                      00081 
0F75   0084           00082 genDelay:               movwf   FSR                             ; normal entry point
0F76   0841           00083                                 movfw   funcDelay
0F77   00FB           00084                                 movwf   temp1
0F78   0E3C           00085                                 swapf   funcPrescMode,w
0F79   390F           00086                                 andlw   0x0f
0F7A   3E04           00087                                 addlw   4                               ; smallest interval 1/62.5 secon
                            d
0F7B   01FC           00088 genDelay0:              clrf    temp2
0F7C   01FD           00089                                 clrf    temp3
0F7D   01FE           00090                                 clrf    temp4
0F7E   01FF           00091                                 clrf    temp5
0F7F   1003           00092 genDelay1               clrc
0F80   0DFB           00093                                 rlf             temp1,f
0F81   0DFC           00094                                 rlf             temp2,f
0F82   0DFD           00095                                 rlf             temp3,f
0F83   3EFF           00096                                 addlw   -1
0F84   1D03 2F7F      00097                                 bnz             genDelay1
                      00098                                 
0F86   0874           00099                                 movf    time+0,w                ; add delay to current time
0F87   07FB           00100                                 addwf   temp1,f
                      00101         
0F88   0875           00102                                 movf    time+1,w
0F89   1803           00103                                 skpnc
0F8A   0F75           00104                                 incfsz  time+1,w
0F8B   07FC           00105                                 addwf   temp2,f
                      00106         
0F8C   0876           00107                                 movf    time+2,w
0F8D   1803           00108                                 skpnc
0F8E   0F76           00109                                 incfsz  time+2,w
0F8F   07FD           00110                                 addwf   temp3,f
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 165


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00111         
0F90   0877           00112                                 movf    time+3,w
0F91   1803           00113                                 skpnc
0F92   0F77           00114                                 incfsz  time+3,w
0F93   07FE           00115                                 addwf   temp4,f
                      00116         
0F94   0878           00117                                 movf    time+4,w
0F95   1803           00118                                 skpnc
0F96   0F78           00119                                 incfsz  time+4,w
0F97   07FF           00120                                 addwf   temp5,f
                      00121         
0F98   1783           00122                                 bsf             STATUS,IRP              ; store the result
0F99   087B           00123                                 movfw   temp1
0F9A   0080           00124                                 movwf   INDF
0F9B   0A84           00125                                 incf    FSR,f
0F9C   087C           00126                                 movfw   temp2
0F9D   0080           00127                                 movwf   INDF
0F9E   0A84           00128                                 incf    FSR,f
0F9F   087D           00129                                 movfw   temp3
0FA0   0080           00130                                 movwf   INDF
0FA1   0A84           00131                                 incf    FSR,f
0FA2   087E           00132                                 movfw   temp4
0FA3   0080           00133                                 movwf   INDF
0FA4   0A84           00134                                 incf    FSR,f
0FA5   087F           00135                                 movfw   temp5
0FA6   0080           00136                                 movwf   INDF
                      00137                                 
0FA7   0008           00138                                 return  ;}
                      00139         
0FA8                  00140 compareTime             ;{
0FA8   3E04           00141                                 addlw   4
0FA9   0084           00142                                 movwf   FSR
0FAA   1783           00143                                 bsf             STATUS,IRP              ; upper ram
0FAB   0878           00144                                 movfw   time+4
0FAC   0200           00145                                 subwf   INDF,w                  ; X>Y..zc,X<Y..zC,X=Y..ZC -
0FAD   1C03 2FCF      00146                                 bnc             TIMEisgreater   ; result: TIME>DELAY
0FAF   1D03 2FCE      00147                                 bnz             TIMEislower             ; result: TIME<DELAY
0FB1   0384           00148                                 decf    FSR,f
0FB2   0877           00149                                 movfw   time+3
0FB3   0200           00150                                 subwf   INDF,w                  ; X>Y..zc,X<Y..zC,X=Y..ZC
0FB4   1C03 2FCF      00151                                 bnc             TIMEisgreater   ; result: TIME>DELAY
0FB6   1D03 2FCE      00152                                 bnz             TIMEislower             ; result: TIME<DELAY
0FB8   0384           00153                                 decf    FSR,f
0FB9   0876           00154                                 movfw   time+2
0FBA   0200           00155                                 subwf   INDF,w                  ; X>Y..zc,X<Y..zC,X=Y..ZC
0FBB   1C03 2FCF      00156                                 bnc             TIMEisgreater   ; result: TIME>DELAY
0FBD   1D03 2FCE      00157                                 bnz             TIMEislower             ; result: TIME<DELAY
0FBF   0384           00158                                 decf    FSR,f
0FC0   0875           00159                                 movfw   time+1
0FC1   0200           00160                                 subwf   INDF,w                  ; X>Y..zc,X<Y..zC,X=Y..ZC
0FC2   1C03 2FCF      00161                                 bnc             TIMEisgreater   ; result: TIME>DELAY
0FC4   1D03 2FCE      00162                                 bnz             TIMEislower             ; result: TIME<DELAY
0FC6   0384           00163                                 decf    FSR,f
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 166


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0FC7   0874           00164                                 movfw   time+0
0FC8   0200           00165                                 subwf   INDF,w                  ; X>Y..zc,X<Y..zC,X=Y..ZC
0FC9   1C03 2FCF      00166                                 bnc             TIMEisgreater   ; result: TIME>DELAY
0FCB   1D03 2FCE      00167                                 bnz             TIMEislower             ; result: TIME<DELAY
0FCD   0008           00168 TIMEisequal             return                                  ; Z=1;C=0
0FCE   0008           00169 TIMEislower             return                                  ; Z=0;C=1
0FCF   0008           00170 TIMEisgreater   return                                  ; Z=O;C=0
                      00171                                 ;}
                      00172 
0FD0                  00173 safeOutput              ;{
0FD0   1283 1303      00174                                 banksel outputLo
0FD2   0832           00175                                 movfw   outputLo
0FD3   1283 1303      00176                                 banksel eeByte
0FD5   00D8           00177                                 movwf   eeByte
0FD6   3001           00178                                 movlw   eeOutputLo
                      00179                                 pcall   eeWrite
                          M ;       Pcall page call, code for calling on same page
                          M ;       outputs messages if LONG/SHORT call could/must be used
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000008                M DEST_HIGH               set     (HIGH(eeWrite)&0x18)                    ; save bits 4:5 of dest adress
  00000008                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000000                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, call ok
0FD7   27F4               M                                         call    eeWrite
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace pcall with longcall", eeWrit
                            e
                          M                                                 call    eeWrite ; INCORRECT Call !!!
                          M                                         else
                          M                                                 messg   " WARNING ! Replace pcall with scall", eeWrite
                          M                                                 call    eeWrite
                          M                                         endif
                          M                                 endif
                      00180 
0FD8   1283 1303      00181                                 banksel outputHi
0FDA   0833           00182                                 movfw   outputHi
0FDB   1283 1303      00183                                 banksel eeByte
0FDD   00D8           00184                                 movwf   eeByte
0FDE   3002           00185                                 movlw   eeOutputHi
0FDF   2FF4           00186                                 goto    eeWrite
                      00187                                 ;}
                      00188 
0FE0                  00189 CRC8                    ;{
0FE0   06D9           00190                                 xorwf   crc,f
0FE1   0103           00191                                 clrw
0FE2   1859           00192                                 btfsc   crc,0
0FE3   3A5E           00193                                 xorlw   0x5e
0FE4   18D9           00194                                 btfsc   crc,1
0FE5   3ABC           00195                                 xorlw   0xbc
0FE6   1959           00196                                 btfsc   crc,2
0FE7   3A61           00197                                 xorlw   0x61
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 167


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0FE8   19D9           00198                                 btfsc   crc,3
0FE9   3AC2           00199                                 xorlw   0xc2
0FEA   1A59           00200                                 btfsc   crc,4
0FEB   3A9D           00201                                 xorlw   0x9d
0FEC   1AD9           00202                                 btfsc   crc,5
0FED   3A23           00203                                 xorlw   0x23
0FEE   1B59           00204                                 btfsc   crc,6
0FEF   3A46           00205                                 xorlw   0x46
0FF0   1BD9           00206                                 btfsc   crc,7
0FF1   3A8C           00207                                 xorlw   0x8c
0FF2   00D9           00208                                 movwf   crc
0FF3   0008           00209                                 return
                      00210 ;}
                      00332 #include                <eeprom.asm>
0FF4                  00001 eeWrite ;{
                      00002 ; write a byte to eeprom
                      00003 ; in:   W               address pointer into eeprom
                      00004 ; in:   eeByte  data to be stored
                      00005 ; out:  -
                      00006 ; mod:  W
0FF4   1683 1703      00007                                 banksel EECON1                  ; select bank 3
0FF6   188C           00008 eeWrite_1:              btfsc   EECON1,WR               ; wait for last write to complete
0FF7   2FF6           00009                                 goto    eeWrite_1
0FF8   1283           00010                                 bcf             STATUS,RP0              ; select bank 2
0FF9   008D           00011                                 movwf   EEADR                   ; setup adress
0FFA   1283 1303      00012                                 banksel eeByte
0FFC   0858           00013                                 movfw   eeByte                  ; get byte
0FFD   1283 1703      00014                                 banksel EEDATA
0FFF   008C           00015                                 movwf   EEDATA                  ; setup byte to write
1000   1683           00016                                 bsf             STATUS,RP0              ; select bank 3
1001   138C           00017                                 bcf             EECON1,EEPGD    ; set to data eeprom
1002   150C           00018                                 bsf             EECON1,WREN             ; enable writes
                      00019                                 disableirq                              ; disable irqs
                          M ;       disableirq disable global irq 
  0000                    M                                 local   STOP_INT
1003   138B               M STOP_INT                bcf             INTCON,GIE              ; disable global interrupt
1004   1B8B               M                                 btfsc   INTCON,GIE              ; check if disabled 
1005   2803               M                                 goto    STOP_INT                ; nope, try again
                      00020                         
1006   3055           00021                                 movlw   0x55                    ; required sequence !!
1007   008D           00022                                 movwf   EECON2
1008   30AA           00023                                 movlw   0xAA
1009   008D           00024                                 movwf   EECON2
100A   148C           00025                                 bsf             EECON1,WR               ; begin write procedure
                      00026                         
                      00027                                 enableirq                               ; enable irqs again
100B   178B               M                                 bsf             INTCON,GIE              ; enable global interrupt
                      00028                         
100C   110C           00029                                 bcf             EECON1,WREN             ; disable writes (does not affec
                            t current write cycle)
                      00030                         
100D   0008           00031                                 return  ;}
                      00032 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 168


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

100E                  00033 eeRead  ;{
                      00034 ; read a byte from eeprom
                      00035 ; in:   W               address pointer into eeprom
                      00036 ; out:  W               read byte
100E   1683 1703      00037                                 banksel EECON1
1010   188C           00038 eeRead_1                btfsc   EECON1,WR
1011   2810           00039                                 goto    eeRead_1                ; wait for last write to complete
1012   1283           00040                                 bcf             STATUS,RP0              ; bank2 !!
1013   008D           00041                                 movwf   EEADR                   ; set up address reg.
1014   1683           00042                                 bsf             STATUS,RP0              ; bank3 !!
1015   138C           00043                                 bcf             EECON1,EEPGD    ; set to read eeprom
1016   140C           00044                                 bsf             EECON1,RD               ; set bit to read
1017   1283           00045                                 bcf             STATUS,RP0              ; bank2 !!
1018   080C           00046                                 movf    EEDATA,W                ; move data to W
1019   0008           00047                                 return  ;}
                      00048 
1800                  00333                                 org             0x1800                  ; third page
                      00334 #include                <init.asm>
                      00001 ;
                      00002 ;********** initialisation part of code ********************************
1800                  00003 initPorts               ;{
                      00004  if     revision >= 3
1800   1283 1303      00005                                 banksel PORTA                   ; Init PORTA
1802   3000           00006                                 movlw   0x00
1803   0085           00007                                 movwf   PORTA
                      00008                 
1804   1683 1303      00009                                 banksel CMCON0
1806   3007           00010                                 movlw   0x07
1807   009C           00011                                 movwf   CMCON0
                      00012                 
1808   1683 1303      00013                                 banksel ANSEL
180A   3000           00014                                 movlw   0x00
180B   0091           00015                                 movwf   ANSEL
                      00016                 
180C   1683 1303      00017                                 banksel TRISA
                      00018 ;//                             movlw   0xc0
180E   3040           00019                                 movlw   0x40                    ; #######
180F   0085           00020                                 movwf   TRISA                   ; RA0:O: O2.7
                      00021                                                                                 ; RA1:O: O2.6
                      00022                                                                                 ; RA2:O: O2.5
                      00023                                                                                 ; RA3:O: O2.4
                      00024                                                                                 ; RA4:O: COL8
                      00025                                                                                 ; RA5:O: COL9
                      00026                                                                                 ; RA6:I: STATUS1
                      00027                                                                                 ; RA7:I: STATUS2
                      00028                                 
                      00029                 
1810   1283 1303      00030                                 banksel PORTB                   ; Init PORTB
1812   3000           00031                                 movlw   0x00
1813   0086           00032                                 movwf   PORTB
                      00033                 
1814   1683 1303      00034                                 banksel TRISB
1816   3080           00035                                 movlw   0x80
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 169


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

1817   0086           00036                                 movwf   TRISB                   ; RB0:I: COL2
                      00037                                                                                 ; RB1:I: COL3
                      00038                                                                                 ; RB2:I: COL4
                      00039                                                                                 ; RB3:I: COL5
                      00040                                                                                 ; RB4:O: COL6
                      00041                                                                                 ; RB5:O: COL7
                      00042                                                                                 ; RB6:I: ICSPCLK
                      00043                                                                                 ; RB7:I: ICSPDAT
                      00044                 
1818   1283 1303      00045                                 banksel PORTC                   ; Init PORTC
181A   3000           00046                                 movlw   0x00
181B   0087           00047                                 movwf   PORTC
                      00048                 
181C   1283 1703      00049                                 banksel LCDCON
181E   3000           00050                                 movlw   0x00
181F   0087           00051                                 movwf   LCDCON
                      00052                 
1820   1683 1303      00053                                 banksel TRISC
1822   3080           00054                                 movlw   0x80
1823   0087           00055                                 movwf   TRISC                   ; RC0:O: O1.3
                      00056                                                                                 ; RC1:O: O1.2
                      00057                                                                                 ; RC2:0: O1.1
                      00058                                                                                 ; RC3:O: O1.0
                      00059                                                                                 ; RC4:O: DC
                      00060                                                                                 ; RC5:O: RS485TE
                      00061                                                                                 ; RC6:O: RS485TX
                      00062                                                                                 ; RC7:I: RS485RX
                      00063                 
1824   1283 1303      00064                                 banksel PORTD                   ; Init PORTD
1826   3000           00065                                 movlw   0x00
1827   0088           00066                                 movwf   PORTD
                      00067                 
1828   1683 1303      00068                                 banksel TRISD
182A   30FF           00069                                 movlw   0xFF
182B   0088           00070                                 movwf   TRISD                   ; RD0:I: I1.0
                      00071                                                                                 ; RD1:I: I1.1
                      00072                                                                                 ; RD2:I: I1.2
                      00073                                                                                 ; RD3:I: I1.3
                      00074                                                                                 ; RD4:I: I1.4
                      00075                                                                                 ; RD5:I: I1.5
                      00076                                                                                 ; RD6:I: I1.6
                      00077                                                                                 ; RD7:I: I1.7
                      00078                 
182C   1283 1303      00079                                 banksel PORTE                   ; Init PORTE
182E   3000           00080                                 movlw   0x00
182F   0089           00081                                 movwf   PORTE
                      00082                 
1830   1683 1303      00083                                 banksel TRISE
1832   300F           00084                                 movlw   0x0F
1833   0089           00085                                 movwf   TRISE                   ; RE0:I: MV1
                      00086                                                                                 ; RE1:I: MV2
                      00087                                                                                 ; RE2:I: MV3
                      00088                                                                                 ; RE3:I: /MCLR
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 170


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00089                                                                                 ; RE4:O: O2.3
                      00090                                                                                 ; RE5:O: O2.2
                      00091                                                                                 ; RE6:O: O2.1
                      00092                                                                                 ; RE7:O: O2.0
                      00093                 
1834   1683 1703      00094                                 banksel PORTF                   ; Init PORTF
1836   3000           00095                                 movlw   0x00
1837   0088           00096                                 movwf   PORTF
                      00097                 
1838   1683 1703      00098                                 banksel TRISF
183A   300F           00099                                 movlw   0x0F
183B   0085           00100                                 movwf   TRISF                   ; RF0:I: I2.4
                      00101                                                                                 ; RF1:I: I2.5
                      00102                                                                                 ; RF2:I: I2.6
                      00103                                                                                 ; RF3:I: I2.6
                      00104                                                                                 ; RF4:O: O1.7
                      00105                                                                                 ; RF5:O: O1.6
                      00106                                                                                 ; RF6:O: O1.5
                      00107                                                                                 ; RF7:O: O1.4
                      00108                 
183C   1683 1703      00109                                 banksel PORTG                   ; Init PORTG
183E   300F           00110                                 movlw   0x0F
183F   0089           00111                                 movwf   PORTG
                      00112                 
1840   1683 1703      00113                                 banksel TRISG
1842   300F           00114                                 movlw   0x0F
1843   0087           00115                                 movwf   TRISG                   ; RG0:I: I2.0
                      00116                                                                                 ; RG1:I: I2.1
                      00117                                                                                 ; RG2:I: I2.2
                      00118                                                                                 ; RG3:I: I2.3
                      00119                                                                                 ; RG4:O: COL0
                      00120                                                                                 ; RG5:O: COL1
                      00121  else   ; revision >= 3
                      00122                                 banksel PORTA                   ; Init PORTA
                      00123                                 movlw   0x00
                      00124                                 movwf   PORTA
                      00125                 
                      00126                                 banksel CMCON0
                      00127                                 movlw   0x07
                      00128                                 movwf   CMCON0
                      00129                 
                      00130                                 banksel ANSEL
                      00131                                 movlw   0x00
                      00132                                 movwf   ANSEL
                      00133                 
                      00134                                 banksel TRISA
                      00135                                 movlw   0x00
                      00136                                 movwf   TRISA                   ; RA0:O: O2.7
                      00137                                                                                 ; RA1:O: O2.6
                      00138                                                                                 ; RA2:O: O2.5
                      00139                                                                                 ; RA3:O: O2.4
                      00140                                                                                 ; RA4:O: LED1x
                      00141                                                                                 ; RA5:O: LED1y
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 171


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00142                                                                                 ; RA6:O: TP1
                      00143                                                                                 ; RA7:O: TP2
                      00144                                 
                      00145                 
                      00146                                 banksel PORTB                   ; Init PORTB
                      00147                                 movlw   0x00
                      00148                                 movwf   PORTB
                      00149                 
                      00150                                 banksel TRISB
                      00151                                 movlw   0xCF
                      00152                                 movwf   TRISB                   ; RB0:I: I1.3
                      00153                                                                                 ; RB1:I: I1.2
                      00154                                                                                 ; RB2:I: I1.1
                      00155                                                                                 ; RB3:I: I1.0
                      00156                                                                                 ; RB4:O: LED2x
                      00157                                                                                 ; RB5:O: LED2y
                      00158                                                                                 ; RB6:I: ICSPCLK
                      00159                                                                                 ; RB7:I: ICSPDAT
                      00160                 
                      00161                                 banksel PORTC                   ; Init PORTC
                      00162                                 movlw   0x00
                      00163                                 movwf   PORTC
                      00164                 
                      00165                                 banksel LCDCON
                      00166                                 movlw   0x00
                      00167                                 movwf   LCDCON
                      00168                 
                      00169                                 banksel TRISC
                      00170                                 movlw   0x90
                      00171                                 movwf   TRISC                   ; RC0:O: O1.3
                      00172                                                                                 ; RC1:O: O1.2
                      00173                                                                                 ; RC2:0: O1.1
                      00174                                                                                 ; RC3:O: O1.0
                      00175                                                                                 ; RC4:I: n.c.
                      00176                                                                                 ; RC5:O: RS485TE
                      00177                                                                                 ; RC6:O: RS485TX
                      00178                                                                                 ; RC7:I: RS485RX
                      00179                 
                      00180                                 banksel PORTD                   ; Init PORTD
                      00181                                 movlw   0x00
                      00182                                 movwf   PORTD
                      00183                 
                      00184                                 banksel TRISD
                      00185                                 movlw   0xFF
                      00186                                 movwf   TRISD                   ; RD0:I: ID0
                      00187                                                                                 ; RD1:I: ID1
                      00188                                                                                 ; RD2:I: ID2
                      00189                                                                                 ; RD3:I: ID3
                      00190                                                                                 ; RD4:I: I2.7
                      00191                                                                                 ; RD5:I: I2.6
                      00192                                                                                 ; RD6:I: I2.5
                      00193                                                                                 ; RD7:I: I2.4
                      00194                 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 172


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00195                                 banksel PORTE                   ; Init PORTE
                      00196                                 movlw   0x00
                      00197                                 movwf   PORTE
                      00198                 
                      00199                                 banksel TRISE
                      00200                                 movlw   0x0F
                      00201                                 movwf   TRISE                   ; RE0:I: 1WIRE
                      00202                                                                                 ; RE1:I: STATUS2
                      00203                                                                                 ; RE2:I: STATUS1
                      00204                                                                                 ; RE3:I: /MCLR
                      00205                                                                                 ; RE4:O: O2.3
                      00206                                                                                 ; RE5:O: O2.2
                      00207                                                                                 ; RE6:O: O2.1
                      00208                                                                                 ; RE7:O: O2.0
                      00209                 
                      00210                                 banksel PORTF                   ; Init PORTF
                      00211                                 movlw   0x00
                      00212                                 movwf   PORTF
                      00213                 
                      00214                                 banksel TRISF
                      00215                                 movlw   0x0F
                      00216                                 movwf   TRISF                   ; RF0:I: I1.7
                      00217                                                                                 ; RF1:I: I1.6
                      00218                                                                                 ; RF2:I: I1.5
                      00219                                                                                 ; RF3:I: I1.4
                      00220                                                                                 ; RF4:O: O1.7
                      00221                                                                                 ; RF5:O: O1.6
                      00222                                                                                 ; RF6:O: O1.5
                      00223                                                                                 ; RF7:O: O1.4
                      00224                 
                      00225                                 banksel PORTG                   ; Init PORTG
                      00226                                 movlw   0x0F
                      00227                                 movwf   PORTG
                      00228                 
                      00229                                 banksel TRISG
                      00230                                 movlw   0x0F
                      00231                                 movwf   TRISG                   ; RG0:I: I2.3
                      00232                                                                                 ; RG1:I: I2.2
                      00233                                                                                 ; RG2:I: I2.1
                      00234                                                                                 ; RG3:I: I2.0
                      00235                                                                                 ; RG4:O: LED3x
                      00236                                                                                 ; RG5:O: LED3y
                      00237  endif  ; revision >= 3
1844   0008           00238                                 return  ;}
                      00239 
1845                  00240 clearRam                ;{
                      00241 ;  clearRam - Reset all general purpose ram to 0s
                      00242 ;  Note ! does not clear watchdog, add CLRWDT where appropiate if enabled
1845   1283           00243                                 bcf             STATUS,RP0
1846   1303           00244                                 bcf             STATUS,RP1
1847   1383           00245                                 bcf             STATUS,IRP              ; select bank0/1 ( with indirect
                             adressing )
1848   3020           00246                                 movlw   0x20                    ; start ram bank0
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 173


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

1849   0084           00247                                 movwf   FSR
184A   0180           00248 clearBank0              clrf    INDF                    ; Clear a register pointed to be FSR
184B   0A84           00249                                 incf    FSR,F
184C   3080           00250                                 movlw   0x80                    ; Test if at top of memory bank0
184D   0204           00251                                 subwf   FSR,W
184E   1D03 284A      00252                                 bnz             clearBank0              ; Loop until all cleared
                      00253                         
1850   30A0           00254                                 movlw   0xa0                    ; start ram bank1
1851   0084           00255                                 movwf   FSR
1852   0180           00256 clearBank1              clrf    INDF                    ; Clear a register pointed to be FSR
1853   0A84           00257                                 incf    FSR,F
1854   30F0           00258                                 movlw   0xf0                    ; Test if at top of memory bank1
1855   0204           00259                                 subwf   FSR,W
1856   1D03 2852      00260                                 bnz             clearBank1              ; Loop until all cleared
                      00261                         
1858   1283           00262 clearRam2               bcf             STATUS,RP0
1859   1703           00263                                 bsf             STATUS,RP1
185A   1783           00264                                 bsf             STATUS,IRP              ; select bank2/3 ( with indirect
                             adressing )
                      00265                         
185B   3020           00266                                 movlw   0x20                    ; start ram bank2
185C   0084           00267                                 movwf   FSR
185D   0180           00268 clearBank2              clrf    INDF                    ; Clear a register pointed to be FSR
185E   0A84           00269                                 incf    FSR,F
185F   3070           00270                                 movlw   0x70                    ; Test if at top of memory bank2
1860   0204           00271                                 subwf   FSR,W
1861   1D03 285D      00272                                 bnz             clearBank2              ; Loop until all cleared
                      00273                         
1863   30A0           00274                                 movlw   0xa0                    ; start ram bank3
1864   0084           00275                                 movwf   FSR
1865   0180           00276 clearBank3              clrf    INDF                    ; Clear a register pointed to be FSR
1866   0A84           00277                                 incf    FSR,F
1867   30F0           00278                                 movlw   0xf0                    ; Test if at top of memory bank3
1868   0204           00279                                 subwf   FSR,W
1869   1D03 2865      00280                                 bnz             clearBank3              ; Loop until all cleared
                      00281                                 
186B   1283           00282                                 bcf             STATUS,RP0
186C   1303           00283                                 bcf             STATUS,RP1
186D   1383           00284                                 bcf             STATUS,IRP              ; select bank0/1 ( with indirect
                             adressing )
                      00285                         
186E   0008           00286                                 return  ;}
                      00287 
186F                  00288 initUart                ;{
                      00289 ;  INIT_UART - Initialises UART
                      00290 ;  enables receiver and transmitter
                      00291 ; make sure pins are setup before calling this routine
                      00292 ; TRISC:6 and TRISC:7 must be set ( as for OUTPUT, but operates as input/OUTPUT )
                      00293 ; furthermore its advised that interrupts are disabled during this routine
                      00294         
                      00295                                 ; setup baudrate
                      00296 ;                               movlw   CALC_HIGH_BAUD(57600)   ; BAUD_57600 ; get baudrate
                      00297 ;                               movlw   BAUD_57600
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 174


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

186F   300C           00298                                 movlw   BAUD_38400
                      00299 ;                               movlw   BAUD_19200
1870   1683 1303      00300                                 banksel SPBRG
1872   0099           00301                             movwf       SPBRG
                      00302                 
                      00303                                 ; enable transmitter
                      00304  if bits89 == 9
                      00305                                 movlw   (1<<TXEN)|(1<<BRGH)|(1<<TX9)    ; preset enable transmitter, hig
                            h speed, 9 bit
                      00306  else
1873   3024           00307                                 movlw   (1<<TXEN)|(1<<BRGH)                             ; preset enable 
                            transmitter, high speed, 8 bit
                      00308  endif
1874   1683 1303      00309                                 banksel TXSTA
1876   0098           00310                                 movwf   TXSTA
                      00311                 
                      00312                                 ; enable recevier
                      00313  if bits89 == 9
                      00314                                 movlw   (1<<SPEN)|(1<<CREN)|(1<<RX9)    ; enable serial receiver, contin
                            ous recevie, 9 bit
                      00315  else
1877   3090           00316                                 movlw   (1<<SPEN)|(1<<CREN)                             ; enable serial 
                            receiver, continous recevie, 8 bit
                      00317  endif
1878   1283 1303      00318                                 banksel RCSTA
187A   0098           00319                                 movwf   RCSTA                   ; set it
                      00320                 
                      00321                                 ; enable receiver interrupt
187B   1683 1303      00322                                 banksel PIE1
                      00323 ;                               bsf             PIE1,TXIE               ; enable transmitter irq
187D   168C           00324                                 bsf             PIE1,RCIE               ; enable receiver irq
187E   170B           00325                                 bsf             INTCON,PEIE             ; and peripheral irq must also b
                            e enabled
                      00326                 
187F   0008           00327                                 return  ;}
                      00328 
1880                  00329 initTimer0              ;{
                      00330 ;  initTimer0 - Initialises Timer1 module
1880   0064           00331                                 clrwdt
1881   1683 1303      00332                                 banksel OPTION_REG
1883   30D0           00333                                 movlw   b'11010000'             ; 1:2 prescale
1884   0081           00334                                 movwf   OPTION_REG
1885   0008           00335                                 return  ;}
                      00336 
1886                  00337 initTimer1              ;{
                      00338 ;  initTimer1 - Initialises Timer1 module
1886   1283 1303      00339                                 banksel T1CON
1888   3010           00340                                 movlw   T1CON                   ; get adress for timer1 control reg
1889   0084           00341                                 movwf   FSR                             ; setup fsr
188A   3030           00342                                 movlw   b'00110000'             ; 1:8 prescale, 100mS rollover
188B   0080           00343                                 movwf   INDF                    ; initialize Timer1
                      00344                 
188C   30BE           00345                                 movlw   LOW(CALC_TIMER(D'100'))
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 175


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

188D   008E           00346                                 movwf   TMR1L                   ; initialize Timer1 low
188E   30F0           00347                                 movlw   HIGH(CALC_TIMER(D'100'))
188F   008F           00348                                 movwf   TMR1H                   ; initialize Timer1 high
1890   100C           00349                                 bcf             PIR1,TMR1IF             ; ensure flag is reset
1891   1410           00350                                 bsf             T1CON,TMR1ON    ; turn on Timer1 module
                      00351                 
                      00352                                 ; enable TIMER1 interrupt
1892   308C           00353                                 movlw   PIE1                    ; get adress for periphial irqs
1893   0084           00354                                 movwf   FSR                             ; setup fsr
1894   1400           00355                                 bsf             INDF,TMR1IE             ; enable TIMER1 irq
1895   170B           00356                                 bsf             INTCON,PEIE             ; and peripheral irq must also b
                            e enabled
1896   0008           00357                                 return  ;}
                      00358 
1897                  00359 initTimer2              ;{
                      00360 ;  initTimer2 - Initialises timer2 module
                      00361 ;  prescaler and timer2 set to 500s => 2kHz
                      00362 ;  postscaler 1:4 => 500Hz
1897   1683 1303      00363                                 banksel PR2
1899   30F9           00364                                 movlw   0xf9                    ; 249 => 1:250
189A   0092           00365                                 movwf   PR2
189B   1283 1303      00366                                 banksel T2CON
189D   3019           00367                                 movlw   0x19                    ; 1:4 prescale ; 1:5 postscale; timer2 o
                            ff
189E   0092           00368                                 movwf   T2CON
189F   1283 1303      00369                                 banksel PIR1
18A1   108C           00370                                 bcf             PIR1,TMR2IF             ; clear timer2 interrupt flag
18A2   1512           00371                                 bsf             T2CON,TMR2ON    ; turn on timer2 module
18A3   308C           00372                                 movlw   PIE1
18A4   0084           00373                                 movwf   FSR
18A5   1480           00374                                 bsf             INDF,TMR2IE             ; enable timer2 interrupt
18A6   170B           00375                                 bsf             INTCON,PEIE             ; peripheral interrupt enabled
18A7   0008           00376                                 return  ;}
                      00377 
                      00378 
18A8                  00379 initPlvd                ;{
18A8   1283 1703      00380                                 banksel LVDCON
18AA   3017           00381                                 movlw   0x17
18AB   0089           00382                                 movwf   LVDCON
18AC   110D           00383                                 bcf             PIR2,LVDIF              ; clear low voltage detection bi
                            t
18AD   0008           00384                                 return  ;}
                      00385                                  
18AE                  00386 initParams              ;{
                      00387 ;  INIT_PARAMS - Initialises user ram with parameters stored in EEPROM
18AE   3000           00388                                 movlw   eeDeviceID
                      00389                                 scall   eeRead                  ; get device id byte from eeprom
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)                     ; save bits 4:5 of dest adress
  00000018                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 176


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000008                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", eeRead
                          M                                         nop             ; redundant nops
                          M                                         call    eeRead
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", eeRead
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M                                                 call    eeRead
                          M                                                 setpclath4      SOURCE_HIGH
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M ;       setpclath3 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 3 according to 
                          M ;       'variable' PCLATH_3
                          M                                 if(_333DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
18AF   118A               M                                         bcf     PCLATH,3
                          M                                 endif
18B0   200E               M                                                 call    eeRead
                          M                                                 setpclath3      SOURCE_HIGH
                          M ;       setpclath3 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 3 according to 
                          M ;       'variable' PCLATH_3
                          M                                 if(_333SOURCE_HIGH&0x08)
18B1   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         endif
                          M                                 endif
18B2   1283 1303      00390                                 banksel deviceID
18B4   00A0           00391                                 movwf   deviceID
                      00392 
18B5   3001           00393                                 movlw   eeOutputLo
                      00394                                 scall   eeRead                  ; get low byte of output from eeprom
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)                     ; save bits 4:5 of dest adress
  00000018                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000008                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 177


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
                          M                                         messg   "Call on same page, replace scall with pcall", eeRead
                          M                                         nop             ; redundant nops
                          M                                         call    eeRead
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", eeRead
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M                                                 call    eeRead
                          M                                                 setpclath4      SOURCE_HIGH
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M ;       setpclath3 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 3 according to 
                          M ;       'variable' PCLATH_3
                          M                                 if(_336DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
18B6   118A               M                                         bcf     PCLATH,3
                          M                                 endif
18B7   200E               M                                                 call    eeRead
                          M                                                 setpclath3      SOURCE_HIGH
                          M ;       setpclath3 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 3 according to 
                          M ;       'variable' PCLATH_3
                          M                                 if(_336SOURCE_HIGH&0x08)
18B8   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         endif
                          M                                 endif
18B9   1283 1303      00395                                 banksel outputLo
18BB   00B2           00396                                 movwf   outputLo
                      00397                                 
18BC   3002           00398                                 movlw   eeOutputHi
                      00399                                 scall   eeRead                  ; get high byte of output from eeprom
                          M ;       SHORT_call short call, code for calling between page0<->1 or page2<->3
                          M ;       Resets PCLATH after call.
                          M ;       w-reg is left untouched.
  0000                    M                                 local   DEST_HIGH, SOURCE_HIGH, DIFF_HIGH
  00000010                M DEST_HIGH               set     (HIGH(eeRead)&0x18)                     ; save bits 4:5 of dest adress
  00000018                M SOURCE_HIGH             set     (HIGH($)&0x18)                          ; --- || ---  source adress
  00000008                M DIFF_HIGH               set     DEST_HIGH ^ SOURCE_HIGH         ; get difference ( XOR )
                          M 
                          M                                 if      (DIFF_HIGH == 0) ; same page, SHOULD generate no extra code, del
                            ta 0 pages
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 178


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M                                         messg   "Call on same page, replace scall with pcall", eeRead
                          M                                         nop             ; redundant nops
                          M                                         call    eeRead
                          M                                         nop
                          M                                 else    ; for safety check so we do not require LONG_call
                          M                                         if      ((DIFF_HIGH&0x18)==0x18)
                          M                                                 messg   " WARNING ! Replace scall with longcall", eeRead
                          M                                         endif
                          M 
                          M                                         ;messg  "Setting page bits for short page crossing call"
                          M                                         if      (DIFF_HIGH == 0x10) ; diff in high bit
                          M                                                 setpclath4      DEST_HIGH ; set high(4) bit of PCLATH
                          M                                                 call    eeRead
                          M                                                 setpclath4      SOURCE_HIGH
                          M                                         else    ; lowest bit only
                          M                                                 setpclath3      DEST_HIGH ; set low(3) bit of PCLATH
                          M ;       setpclath3 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 3 according to 
                          M ;       'variable' PCLATH_3
                          M                                 if(_339DEST_HIGH&0x08)
                          M                                         bsf     PCLATH,3        
                          M                                 else
18BD   118A               M                                         bcf     PCLATH,3
                          M                                 endif
18BE   200E               M                                                 call    eeRead
                          M                                                 setpclath3      SOURCE_HIGH
                          M ;       setpclath3 'help' macro for LONG/SHORT_call
                          M ;       sets/clears PCLATH bit 3 according to 
                          M ;       'variable' PCLATH_3
                          M                                 if(_339SOURCE_HIGH&0x08)
18BF   158A               M                                         bsf     PCLATH,3        
                          M                                 else
                          M                                         bcf     PCLATH,3
                          M                                 endif
                          M                                         endif
                          M                                 endif
18C0   1283 1303      00400                                 banksel outputHi
18C2   00B3           00401                                 movwf   outputHi
                      00402 
                      00403  if revision >= 4                               
18C3   1706           00404                                 bsf             PORTB,6                 ; reset display counter
18C4   1306           00405                                 bcf             PORTB,6
                      00406  else
                      00407                                 bsf             PORTA,7                 ; reset display counter
                      00408                                 bcf             PORTA,7
                      00409  endif
18C5   1283 1303      00410                                 banksel iDisplayCount
18C7   3007           00411                                 movlw   0x07
18C8   00DA           00412                                 movwf   iDisplayCount   ; reset our internal counter
18C9   0008           00413                                 return  ;}
                      00335 #include                <parameter.asm>
2100                  00001                                 org             0x2100                  ; 256 bytes of eeprom
  00002100            00002 PARAMBASE               equ             $       ;{
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 179


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00003         
  00000000            00004 eeDeviceID              equ             $-PARAMBASE
2100   000D           00005                                 de              device
  00000001            00006 eeOutputLo              equ             $-PARAMBASE
2101   0000           00007                                 de              0x00
  00000002            00008 eeOutputHi              equ             $-PARAMBASE     
2102   0000           00009                                 de              0x00    ;}
                      00010                                 
  00000003            00011 actionbase              equ             $-PARAMBASE
                      00012 
                      00013 ; mode 0 - 1 exit
                      00014 ; mode 1 - 4 passthrough
                      00015 ; mode 2 - 2 always off
                      00016 ; mode 3 - 2 always on
                      00017 ; mode 4 - 4 toggle light
                      00018 ; mode 5 - 4 light toogle dual outputs
                      00019 ; mode 6 - 5 two stage light (output1: 1st stage output2 2nd stage)
                      00020 ; mode 7 - 1 nop
                      00021 ; mode 8 - 5 retriggerable timer
                      00022 ; mode 9 - 5 stopable timer
                      00023 ; mode a - 1 nop
                      00024 ; mode b - 1 nop
                      00025 ; mode c - 1 nop
                      00026 ; mode d - 6 awning (output1: on/off output2: open/close)
                      00027 ; mode e - 6 blind (output1: on/off output2: up/down
                      00028 ; mode f - 6 window (output1: down output2: close)
                      00029 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00030 
                      00031 
                      00032  if device == 0x01
                      00033 ;Input  Raum Position           Output  Relais  Raum Position
                      00034 ;I01.0  Technik Tr A           O01.0   Ra01    Technik Decke 1
                      00035 ;I01.1  Technik Tr B           O01.1   Ra02    Technik Decke 2
                      00036 ;I01.2  Treppe UG West A        O01.2   Ra03    Treppe UG Downlights
                      00037 ;I01.3  Treppe UG West B        O01.3   Ra04    Treppe UG Unter Podest
                      00038 ;I01.4  Treppe UG Ost A         O01.4   Ra05    Treppe UG Wand West
                      00039 ;I01.5  Treppe UG Ost B         O01.5   Ra06    Treppe UG Wand Ost
                      00040 ;I01.6  Vorrat Tr A            O01.6   Ra07    Vorrat Decke 1
                      00041 ;I01.7  Hobby Tr A                     O01.7   Ra08    Vorrat Decke 2
                      00042 ;I01.8  Hobby Tr B                     O01.8   Ra09    Hobby Downlights 1
                      00043 ;I01.9  Hobby Tr C                     O01.9   Ra10    Hobby Downlights 2
                      00044 ;I01.A  Hobby Tr D                     O01.A   Ra11    Hobby  reserve 
                      00045 ;I01.B  Werkstatt Tr A         O01.B   Ra12    Werken Decke 1 (L1)
                      00046 ;I01.C  Werkstatt Tr B         O01.C   Ra13    Werken Decke 2 (L2)
                      00047 ;I01.D  Arbeiten Tr A          O01.D   Ra14    Werken Decke 3 (L3)
                      00048 ;I01.E  Arbeiten Tr B          O01.E   Ra15    Arbeiten Downlights 1
                      00049 ;I01.F  Arbeiten Tr C          O01.F   Ra16    Arbeiten Downlights 2
                      00050 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00051         de      0x56,0x10,0x00,0x01,0x28                ; Technik Decke 1&2
                      00052 
                      00053         de      0xa4,0x02,0x01,0x01,0xe1                ; Treppe UG Downlights - Technik Tr B
                      00054         de      0xa4,0x02,0x02,0x01,0xe1                ; Treppe UG Downlights - Treppe UG West A
                      00055         de      0xa4,0x02,0x05,0x01,0xe1                ; Treppe UG Downlights - Treppe UG Ost B
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 180


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00056         de      0xa4,0x02,0x0a,0x01,0xe1                ; Treppe UG Downlights - Hobby Tr D
                      00057         de      0xa4,0x02,0x0d,0x01,0xe1                ; Treppe UG Downlights - Arbeiten Tr A
                      00058         de      0xa4,0x02,0x02,0x02,0xe1                ; Treppe UG Downlights - Garderobe Tr B
                      00059         de      0xa4,0x02,0x04,0x02,0xe1                ; Treppe UG Downlights - Treppe EG Ost B
                      00060         de      0xa4,0x02,0x08,0x02,0xe1                ; Treppe UG Downlights - Treppe EG Sd B
                      00061         de      0xa4,0x02,0x02,0x03,0xe1                ; Treppe UG Downlights - Treppe EG West H
                      00062 
                      00063         de      0xa4,0x03,0x03,0x01,0xe1                ; Treppe UG Unter Podest - Treppe UG West B - 30
                            min
                      00064         de      0xa4,0x03,0x04,0x01,0xe1                ; Treppe UG Unter Podest - Treppe UG Ost A - 30m
                            in
                      00065 
                      00066         de      0xa5,0x54,0x01,0x01,0xe1                ; Treppe UG Wand West/Ost - Technik Tr B
                      00067         de      0xa5,0x54,0x02,0x01,0xe1                ; Treppe UG Wand West/Ost - Treppe UG West A
                      00068         de      0xa5,0x54,0x05,0x01,0xe1                ; Treppe UG Wand West/Ost - Treppe UG Ost B
                      00069         de      0xa5,0x54,0x0a,0x01,0xe1                ; Treppe UG Wand West/Ost - Hobby Tr D
                      00070         de      0xa5,0x54,0x0d,0x01,0xe1                ; Treppe UG Wand West/Ost - Arbeiten Tr A
                      00071         de      0xa5,0x54,0x02,0x02,0xe1                ; Treppe UG Wand West/Ost - Garderobe Tr B
                      00072         de      0xa5,0x54,0x04,0x02,0xe1                ; Treppe UG Wand West/Ost - Treppe EG Ost B
                      00073         de      0xa5,0x54,0x08,0x02,0xe1                ; Treppe UG Wand West/Ost - Treppe EG Sd B
                      00074         de      0xa5,0x54,0x02,0x03,0xe1                ; Treppe UG Wand West/Ost - Treppe EG West H
                      00075 
                      00076         de      0x56,0x76,0x06,0x01,0x28                ; Vorrat Decke 1&2
                      00077         de      0x56,0x98,0x08,0x01,0x28                ; Hobby Downlights 1&2
                      00078         de      0x56,0x89,0x07,0x01,0x28                ; Hobby Downlights 2&1
                      00079         de      0x56,0x98,0x0c,0x01,0x28                ; Hobby Downlights 1&2
                      00080         de      0x02,0x0a                                               ; Hobby  reserve 
                      00081         de      0x56,0xcb,0x0b,0x01,0x28                ; Werken Decke 1&2 (L1&2)
                      00082         de      0x04,0x0d,0x0b,0x01                             ; Werken Decke 3 (L3)
                      00083         de      0x04,0x0e,0x0f,0x01                             ; Arbeiten Downlights 1
                      00084         de      0x04,0x0f,0x00,0x02                             ; Arbeiten Downlights 2
                      00085  endif
                      00086 
                      00087  if device == 0x02
                      00088 ;Input  Raum    Position        Output  Relais  Raum Position
                      00089 ;I02.0  Arbeiten Tr D          O02.0   Ra17    Arbeiten Downlights 3           
                      00090 ;I02.1  Garderobe Tr A         O02.1   Ra18    Arbeiten  reserve             
                      00091 ;I02.2  Garderobe Tr B         O02.2   Ra19    Garderobe Decke         
                      00092 ;I02.3  Treppe EG Ost A         O02.3   Ra20    WC Spiegel              
                      00093 ;I02.4  Treppe EG Ost B         O02.4   Ra21    WC Decke                
                      00094 ;I02.5  Treppe EG Ost C         O02.5   Ra22    Windfang Downlights             
                      00095 ;I02.6  Treppe EG Ost D         O02.6   Ra23    Kche Downlights 1              
                      00096 ;I02.7  Treppe EG Sd A         O02.7   Ra24    Kche Downlights 2              
                      00097 ;I02.8  Treppe EG Sd B         O02.8   Ra25    Kche Downlights 3              
                      00098 ;I02.9  Treppe EG Sd C         O02.9   Ra26    Kche  reserve                
                      00099 ;I02.A  Treppe EG Sd D         O02.A   Ra27    Kche  reserve                
                      00100 ;I02.B  Treppe EG West A        O02.B                   Treppe EG West LED      2       
                      00101 ;I02.C  Treppe EG West B        O02.C   Ra28    Essen Decke Tisch       
                      00102 ;I02.D  Treppe EG West C        O02.D   Ra29    Essen Downlights Tisch          
                      00103 ;I02.E  Treppe EG West D        O02.E   Ra30    Essen Downlights Nord   
                      00104 ;I02.F  Treppe EG West E        O02.F   Rb01    Treppe EG Downlights
                      00105 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00106         de      0x04,0x00,0x0e,0x01
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 181


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00107         de      0x02,0x01
                      00108         de      0x04,0x02,0x01,0x02
                      00109         de      0x04,0x03,0x04,0x03
                      00110         de      0x02,0x04
                      00111         de      0x04,0x05,0x03,0x03
                      00112         de      0x04,0x05,0x0a,0x03
                      00113         de      0x04,0x05,0x06,0x02
                      00114         de      0x04,0x06,0x04,0x04
                      00115         de      0x56,0x76,0x0d,0x04,0x28
                      00116         de      0x04,0x07,0x03,0x04
                      00117         de      0x56,0x78,0x0c,0x04,0x28
                      00118         de      0x04,0x08,0x02,0x04
                      00119         de      0x02,0x09
                      00120         de      0x02,0x0a
                      00121         de      0x03,0x0b
                      00122         de      0x04,0xdc,0x0b,0x02                             ; Essen Decke 1 & Downlights 1 - Treppe 
                            West A
                      00123 ;       de      0x04,0xdc,0x05,0x04                             ; Essen Decke 1 & Downlights 1 - Kche O
                            st H
                      00124         de      0x04,0xdc,0x0d,0x05                             ; Essen Decke 1 & Downlights 1 - Essen W
                            est N
                      00125         de      0x04,0x0c,0x0e,0x04
                      00126         de      0x56,0xed,0x0f,0x04,0x28
                      00127         de      0x04,0x0e,0x0a,0x02
                      00128         de      0x04,0x0f,0x05,0x02
                      00129         de      0x04,0x0f,0x09,0x02
                      00130  endif
                      00131 
                      00132 
                      00133  if device == 0x03
                      00134 ;Input  Raum Position           Output  Relais  Raum Position
                      00135 ;I03.0  Treppe EG West F        O03.0   Rb02    Essen Steckdose Nord 
                      00136 ;I03.1  Treppe EG West G        O03.1   Rb03    Essen  reserve        
                      00137 ;I03.2  Treppe EG West H        O03.2   Rb04    Wohnen Downlights 1
                      00138 ;I03.3  WC Tr A                        O03.3   Rb05    Wohnen Downlights 2
                      00139 ;I03.4  WC Tr B                        O03.4   Rb06    Wohnen Steckdose West
                      00140 ;I03.5  WC Fenster                      O03.5   Rb07    Wohnen Wand Nord
                      00141 ;I03.6  Windfang Tr A          O03.6                   Winddfang Tr LED 1
                      00142 ;I03.7  Windfang Tr B          O03.7                   Winddfang Tr LED 2
                      00143 ;I03.8  Windfang Tr C          O03.8                   Winddfang Tr LED 3
                      00144 ;I03.9  Windfang Tr D          O03.9                   Winddfang Tr LED 4
                      00145 ;I03.A  Windfang Tr E          O03.A   Rb08    Wohnen Wand Ost-Nord
                      00146 ;I03.B  Windfang Tr F          O03.B   Rb09    Wohnen Wand Ost-Sd
                      00147 ;I03.C  Windfang Tr G          O03.C   Rb10    Schrank Downlights
                      00148 ;I03.D  Windfang Tr H          O03.D   Rb11    Elternbad Spiegel
                      00149 ;I03.E  Kche Ost A                     O03.E   Rb12    Elternbad Decke 1
                      00150 ;I03.F  Kche Ost B                     O03.F   Rb13    Elternbad Decke 2
                      00151 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00152         de      0x04,0x00,0x0c,0x05                             ; Essen Steckdose Nord - Essen West M
                      00153         de      0x04,0x00,0x0c,0x02                             ; Essen Steckdose Nord - Treppe EG West 
                            B
                      00154         de      0x02,0x01                                               ; Essen  reserve  - Dauer aus
                      00155         de      0x56,0x32,0x02,0x0f,0x28                ; Wohnen DL 1/2 - Wohnen Sd B
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 182


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00156         de      0x56,0x32,0x07,0x05,0x28                ; Wohnen DL 1/2 - Essen West H
                      00157         de      0x04,0x04,0x03,0x0f                             ; Wohnen Steckdose West - Wohnen Sd D
                      00158         de      0x04,0x04,0x08,0x06                             ; Wohnen Steckdose West - Wohnen Nord A
                      00159         de  0x04,0x04,0x06,0x05                         ; Wohnen Steckdose West - Essen West G
                      00160         de      0x56,0x5a,0x09,0x06,0x28                ; Wohnen Wand Nord/Ost-Nord - Wohnen Nord B
                      00161         de      0x04,0x05,0x0a,0x0f                             ; Wohnen Wand Nord - Wohnen Sd I
                      00162         de      0xb4,0x06,0x05,0x0e,0x96                ; Windfang Tr LED 1 - Garage Decke 1 - Garage C
                             - 80min
                      00163         de      0x74,0x06,0x04,0x0e,0x96                ; Windfang Tr LED 1 - Garage Decke 1 - Garage B
                             - 5min
                      00164         de      0x74,0x06,0x06,0x03,0x96                ; Windfang Tr LED 1 - Garage Decke 1 - Windfang
                             Tr B - 5min
                      00165         de      0x03,0x07                                               ; Windfang Tr LED 2 - Dauer ein
                      00166         de      0xb4,0x08,0x08,0x03,0xe1                ; Windfang Tr LED 3 - Windfang Tr C - Kontroll
                            e Auen NO - 120min
                      00167         de      0xb4,0x09,0x09,0x03,0xe1                ; Windfang Tr LED 4 - Windfang Tr D - Kontroll
                            e Auen Eingang - 120min
                      00168     de  0x04,0x0a,0x09,0x0f                             ; Wohnen Wand Ost-Nord - Wohnen Sd J
                      00169     de  0x04,0x0b,0x08,0x0f                             ; Wohnen Wand Ost-Sd - Wohnen Sd K
                      00170         de      0xa4,0x0c,0x07,0x07,0xe1                ; Schrank Downlights - Schrank Tr A 1h
                      00171         de      0x04,0x0d,0x0c,0x07                             ; Elternbad Spiegel
                      00172         de      0x02,0x0e                                               ; Elternbad Decke 1
                      00173         de      0x02,0x0f                                               ; Elternbad Decke 2
                      00174  endif
                      00175  
                      00176 
                      00177  if device == 0x04
                      00178 ;Input  Raum Position           Output  Relais  Raum Position
                      00179 ;I04.0  Kche Ost C                     O04.0                   Kche Ost LED 1
                      00180 ;I04.1  Kche Ost D                     O04.1                   Kche Ost LED 2
                      00181 ;I04.2  Kche Ost E                     O04.2                   Kche Ost LED 3
                      00182 ;I04.3  Kche Ost F                     O04.3                   Kche Ost LED 4
                      00183 ;I04.4  Kche Ost G                     O04.4   Rb14    Eltern Decke 1  
                      00184 ;I04.5  Kche Ost H                     O04.5   Rb15    Eltern Decke 2  
                      00185 ;I04.6  Kche Fenster           O04.6   Rb16    Eltern Wand Nordwest
                      00186 ;I04.7  Essen Fenster           O04.7   Rb17    Eltern Wand Nordost     
                      00187 ;I04.8  Essen Ost A                     O04.8                   Essen Ost LED 1
                      00188 ;I04.9  Essen Ost B                     O04.9                   Essen Ost LED 2
                      00189 ;I04.A  Essen Ost C                     O04.A                   Essen Ost LED 3
                      00190 ;I04.B  Essen Ost D                     O04.B                   Essen Ost LED 4
                      00191 ;I04.C  Essen Ost E                     O04.C   Rb18    Treppe OG Wand West
                      00192 ;I04.D  Essen Ost F                     O04.D   Rb19    Treppe OG Wand Ost      
                      00193 ;I04.E  Essen Ost G                     O04.E   Rb20    Flur OG Wand Sd 1      
                      00194 ;I04.F  Essen Ost H                     O04.F   Rb21    Flur OG Wand Sd 2      
                      00195 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00196         de      0x02,0x00                                               ; Kche Ost LED 1 - Dauer aus
                      00197         de      0x03,0x01                                               ; Kche Ost LED 2 - Dauer ein
                      00198         de      0x02,0x02                                               ; Kche Ost LED 3 - Dauer aus
                      00199         de      0x39,0x03,0x09,0x0e,0x01,0x40   ; Kche Ost LED 4 - Garagentor offen blink
                      00200         de      0x05,0x54,0x00,0x08                             ; Eltern Decke 1&2 - Eltern Tr A
                      00201         de      0x56,0x54,0x0d,0x08,0x28                ; Eltern Decke 1&2 - Eltern NW F
                      00202         de      0x56,0x54,0x01,0x09,0x28                ; Eltern Decke 1&2 - Eltern NO B
                      00203         de      0x56,0x54,0x0d,0x07,0x28                ; Eltern Decke 1&2 - Elternbad B
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 183


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00204         de      0x04,0x06,0x02,0x08                             ; Eltern Wand NW - Eltern Tr C
                      00205         de      0x04,0x06,0x0c,0x08                             ; Eltern Wand NW - Eltern NW E
                      00206         de      0x04,0x06,0x0e,0x07                             ; Eltern Wand NW - Elternbad Tr G
                      00207         de      0x04,0x07,0x03,0x08                             ; Eltern Wand NO - Eltern Tr D
                      00208         de      0x04,0x07,0x00,0x09                             ; Eltern Wand NO - Eltern NW E
                      00209         de      0x04,0x07,0x0f,0x07                             ; Eltern Wand NO - Elternbad Tr H
                      00210         de      0x02,0x08                                               ; Essen Ost LED 1 - Dauer aus
                      00211         de      0x03,0x09                                               ; Essen Ost LED 2 - Dauer ein
                      00212         de      0x02,0x0a                                               ; Essen Ost LED 3 - Dauer aus
                      00213         de      0x02,0x0b                                               ; Essen Ost LED 4 - Dauer aus
                      00214         de      0x05,0xdc,0x03,0x02                             ; Podest Eltern Ost&West - Treppe EG Ost
                             A
                      00215         de      0x05,0xdc,0x00,0x03                             ; Podest Eltern Ost&West - Treppe EG Wes
                            t F
                      00216         de      0x05,0xdc,0x07,0x02                             ; Podest Eltern Ost&West - Treppe EG Sd
                             A
                      00217         de      0x05,0xdc,0x01,0x08                             ; Podest Eltern Ost&West - Eltern Tr B
                      00218         de      0x05,0xdc,0x0b,0x09                             ; Podest Eltern Ost&West - Flur OG Ost D
                      00219         de      0x05,0xdc,0x0d,0x09                             ; Podest Eltern Ost&West - Flur OG Sd B
                      00220         de      0xa5,0xfe,0x0a,0x09,0xe1                ; Flur OG Wand Sd 1/2 - Flur OG Ost C - 60min
                      00221         de      0xa5,0xfe,0x0c,0x09,0xe1                ; Flur OG Wand Sd 1/2 - Flur OG Sd A -60min
                      00222         de      0xa5,0xfe,0x03,0x0a,0xe1                ; Flur OG Wand Sd 1/2 - Kinderbad D - 60min
                      00223         de      0xa5,0xfe,0x03,0x0b,0xe1                ; Flur OG Wand Sd 1/2 - Kind 1 Tr D - 60min
                      00224         de      0xa5,0xfe,0x07,0x0c,0xe1                ; Flur OG Wand Sd 1/2 - Kind 2 Tr H - 60min
                      00225         de      0xa5,0xfe,0x0f,0x02,0xe1                ; Flur OG Wand Sd 1/2 - Treppe EG West E - 60mi
                            n
                      00226  endif
                      00227 
                      00228 
                      00229  if device == 0x05
                      00230 ;Input  Raum Position           Output  Relais  Raum Position
                      00231 ;I05.0  Essen West A            O05.0                   Essen West LED 1
                      00232 ;I05.1  Essen West B            O05.1                   Essen West LED 2
                      00233 ;I05.2  Essen West C            O05.2                   Essen West LED 3
                      00234 ;I05.3  Essen West D            O05.3                   Essen West LED 4
                      00235 ;I05.4  Essen West E            O05.4                   Essen West LED 9
                      00236 ;I05.5  Essen West F            O05.5                   Essen West LED A
                      00237 ;I05.6  Essen West G            O05.6                   Essen West LED B
                      00238 ;I05.7  Essen West H            O05.7                   Essen West LED C
                      00239 ;I05.8  Essen West I            O05.8   Rb22    Flur  reserve         
                      00240 ;I05.9  Essen West J            O05.9   Rb23    Kinderbad Spiegel       
                      00241 ;I05.A  Essen West K            O05.A   Rb24    Kinderbad Wand  
                      00242 ;I05.B  Essen West L            O05.B   Rb25    Kinderbad Decke
                      00243 ;I05.C  Essen West M            O05.C   Rb26    Kind 1 Decke    
                      00244 ;I05.D  Essen West N            O05.D   Rb27    Kind 1 Wand Sdost      
                      00245 ;I05.E  Essen West O            O05.E   Rb28    Kind 1 Wand Bett        
                      00246 ;I05.F  Essen West P            O05.F   Rb29    Kind 1 Steckdose Ost
                      00247 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00248         de      0x02,0x00                                               ; Essen West LED 1 - Dauer aus
                      00249         de      0x03,0x01                                               ; Essen West LED 2 - Dauer ein
                      00250         de      0x02,0x02                                               ; Essen West LED 3 - Dauer aus
                      00251         de      0x02,0x03                                               ; Essen West LED 4 - Dauer aus
                      00252         de      0x02,0x04                                               ; Essen West LED 9 - Dauer aus
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 184


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00253         de      0xb4,0x05,0x09,0x05,0xe1                ; Essen West LED A - Essen West J - Kontrolle Au
                            en Wa Sd - 120min
                      00254         de      0xc4,0x06,0x0a,0x05,0xe1                ; Essen West LED B - Essen West K - Kontrolle Au
                            en Wa Sdterrasse - 240min
                      00255         de      0xc4,0x07,0x0b,0x05,0xe1                ; Essen West LED C - Essen West L - Kontrolle Au
                            en St Sdterrasse - 240min
                      00256         de      0x02,0x08                                               ; Flur  reserve  Dauer aus
                      00257         de      0xa4,0x09,0x00,0x0a,0xe1                ; Kinderbad Spiegel - Kinderbad Tr A - 60min
                      00258         de      0xa4,0x0a,0x01,0x0a,0xe1                ; Kinderbad Wand    - Kinderbad Tr B - 60min
                      00259         de      0xa4,0x0b,0x02,0x0a,0xe1                ; Kinderbad Decke   - Kinderbad Tr C - 60min
                      00260         de      0x04,0x0c,0x00,0x0b                             ; Kind 1 Decke - Kind 1 Tr A
                      00261         de      0x04,0x0c,0x08,0x0b                             ; Kind 1 Decke - Kind 1 Bett E
                      00262         de      0x02,0x0d                                               ; Kind 1 Wand Sdost - Dauer aus
                      00263         de      0xc4,0x0e,0x01,0x0b,0xe1                ; Kind 1 Wand Bett - Kind 1 Tr B - 240min
                      00264         de      0xc4,0x0e,0x09,0x0b,0xe1                ; Kind 1 Wand Bett - Kind 1 Tr B - 240min
                      00265         de      0xc4,0x0f,0x02,0x0b,0xe1                ; Kind 1 Steckdoese Ost - Kind 1 Tr C - 240min
                      00266         de      0xc4,0x0f,0x0a,0x0b,0xe1                ; Kind 1 Steckdoese Ost - Kind 1 Tr C - 240min
                      00267 
                      00268  endif
                      00269  
                      00270 
                      00271  if device == 0x06
                      00272 ;Input  Raum Position           Output  Relais  Raum Position
                      00273 ;I06.0   reserve                      O06.0                   Wohnen Sd LED 1
                      00274 ;I06.1   reserve                      O06.1                   Wohnen Sd LED 2
                      00275 ;I06.2   reserve                      O06.2                   Wohnen Sd LED 2
                      00276 ;I06.3   reserve                      O06.3                   Wohnen Sd LED 4
                      00277 ;I06.4   reserve                      O06.4   Rb30    Kind 1  reserve       
                      00278 ;I06.5   reserve                      O06.5   Rc01    Kind 2 Decke    
                      00279 ;I06.6   reserve                      O06.6   Rc02    Kind 2 Wand Sdwest     
                      00280 ;I06.7   reserve                      O06.7   Rc03    Kind 2 Wand Bett        
                      00281 ;I06.8  Wohnen Nord A           O06.8                   Wohnen Nord LED 1
                      00282 ;I06.9  Wohnen Nord B           O06.9                   Wohnen Nord LED 2
                      00283 ;I06.A  Wohnen Nord C           O06.A                   Wohnen Nord LED 3
                      00284 ;I06.B  Wohnen Nord D           O06.B                   Wohnen Nord LED 4
                      00285 ;I06.C  Wohnen Nord E           O06.C   Rc04    Kind 2 Steckdose West
                      00286 ;I06.D  Wohnen Nord F           O06.D   Rc05    Kind 2  reserve       
                      00287 ;I06.E  Wohnen Nord G           O06.E   Rc06    Kind 3 Downlights 1     
                      00288 ;I06.F  Wohnen Nord H           O06.F   Rc07    Kind 3 Downlights 2
                      00289 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00290         de      0x02,0x00                                               ; Wohnen Sd LED 1 - aus
                      00291         de      0x03,0x01                                               ; Wohnen Sd LED 2 - ein
                      00292         de      0x02,0x02                                               ; Wohnen Sd LED 3 - aus
                      00293         de      0x02,0x03                                               ; Wohnen Sd LED 4 - aus
                      00294         de      0x02,0x04                                               ; Kind 1  reserve  aus
                      00295         de      0x04,0x05,0x04,0x0c                             ; Kind 2 Decke - Kind2 Tr E
                      00296         de      0x04,0x05,0x08,0x0c                             ; Kind 2 Decke - Kind2 Bett E
                      00297         de      0x04,0x05,0x0d,0x0c                             ; Kind 2 Decke - Kind2 Bett J
                      00298         de      0x02,0x06                                               ; Kind 2 Wand Sdwest  aus
                      00299         de      0x04,0x07,0x05,0x0c                             ; Kind 2 Wand Bett - Kind2 Tr G
                      00300         de      0x04,0x07,0x09,0x0c                             ; Kind 2 Wand Bett - Kind2 Bett G
                      00301         de      0x04,0x07,0x0e,0x0c                             ; Kind 2 Wand Bett - Kind2 Bett L
                      00302         de      0x02,0x08                                               ; Wohnen Nord LED 1 - aus
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 185


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00303         de      0x03,0x09                                               ; Wohnen Nord LED 2 - ein
                      00304         de      0xc4,0x0a,0x0a,0x06,0xe1                ; Wohnen Nord LED 3 - Wohnen Nord C - Kontrolle 
                            Auen Wa Nordterrasse - 240min
                      00305         de      0xc4,0x0b,0x0b,0x06,0xe1                ; Wohnen Nord LED 4 - Wohnen Nord D - Kontrolle 
                            Auen St Nordterrasse - 240min
                      00306         de      0xc4,0x0c,0x06,0x0c,0xe1                ; Kind 2 Steckdose West - Kind2 Tr F
                      00307         de      0xc4,0x0c,0x0a,0x0c,0xe1                ; Kind 2 Steckdose West - Kind2 Bett F
                      00308         de      0xc4,0x0c,0x0f,0x0c,0xe1                ; Kind 2 Steckdose West - Kind2 Bett Ks
                      00309         de      0x02,0x0d                                               ; Kind 2  reserve  aus
                      00310         de      0x04,0x0e,0x04,0x0d                             ; Kind 3 Downlights 1
                      00311         de      0x04,0x0e,0x0c,0x0d                             ; Kind 3 Downlights 1
                      00312         de      0x04,0x0f,0x05,0x0d                             ; Kind 3 Downlights 2
                      00313         de      0x04,0x0f,0x0d,0x0d                             ; Kind 3 Downlights 2
                      00314  endif
                      00315  
                      00316 
                      00317  if device == 0x07
                      00318 ;Input  Raum Position           Output  Relais  Raum Position
                      00319 ;I07.0  Wohnen Fenster Sd      O07.0   Rc08    Kind 3  Downlights 3    
                      00320 ;I07.1  Wohnen Fenster Nord     O07.1   Rc09    Kind 3  Wand Bett       
                      00321 ;I07.2  Elternbad Fenster       O07.2   Rc10    Kind 3   reserve      
                      00322 ;I07.3  Arbeiten Fenster        O07.3   Rc11    Abstellkammer Decke
                      00323 ;I07.4  Garderobe Fenster       O07.4   Rc12    untere Bhne Decke
                      00324 ;I07.5  Eltern Fenster          O07.5   Rc13    obere Bhne Decke
                      00325 ;I07.6  Eltern Fenster          O07.6   Rc14    Aussen  Eingang
                      00326 ;I07.7  Schrank Tr A           O07.7   Rc15    Aussen  Wand Sd
                      00327 ;I07.8  Elternbad Tr A         O07.8                   Elternbad       Tr LED 2       
                      00328 ;I07.9  Elternbad Tr B         O07.9   Rc16    Sdterrasse     Wand Sd        
                      00329 ;I07.A  Elternbad Tr C         O07.A   Rc17    Sdterrasse Steckdose
                      00330 ;I07.B  Elternbad Tr D         O07.B   Rc18    Nordterrase     Wand N/O        
                      00331 ;I07.C  Elternbad Tr E         O07.C   Rc19    Nordterrase     Steckdose       
                      00332 ;I07.D  Elternbad Tr F         O07.D   Rc20    Aussen  Nord
                      00333 ;I07.E  Elternbad Tr G         O07.E   Rc21    Aussen  Nordost
                      00334 ;I07.F  Elternbad Tr H         O07.F   Rc22    Aussen  Garage
                      00335 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00336         de      0x04,0x00,0x06,0x0d
                      00337         de      0x04,0x00,0x0e,0x0d
                      00338         de      0x04,0x01,0x07,0x0d
                      00339         de      0x04,0x01,0x0f,0x0d
                      00340         de      0x02,0x02
                      00341         de      0x04,0x03,0x00,0x0e
                      00342         de      0x04,0x04,0x01,0x0e
                      00343         de      0x04,0x05,0x02,0x0e
                      00344         de      0xb4,0x06,0x09,0x03,0xe1                ; Auen Wa Eingang - Windfang Tr D - 120min
                      00345         de      0xb4,0x07,0x09,0x05,0xe1                ; Auen Wa Sd - Essen West J - 120min
                      00346         de      0x03,0x08                                               ; Elternbad     Tr LED 2 - ein
                      00347         de      0xc4,0x09,0x0a,0x05,0xe1                ; Auen Wa Sdterrasse - Essen West K - 240min
                      00348         de      0xc4,0x0a,0x0b,0x05,0xe1                ; Auen St Sdterrasse - Essen West L - 240min
                      00349         de      0xc4,0x0b,0x0a,0x06,0xe1                ; Auen Wa Nordterrasse - Wohnen Nord C - 240min
                      00350         de      0xc4,0x0c,0x0b,0x06,0xe1                ; Auen St Nordterrasse - Wohnen Nord D - 240min
                      00351         de      0xb4,0x0d,0x08,0x03,0xe1                ; Auen Wa Nord - Windfang C - 120min
                      00352         de      0xb4,0x0e,0x08,0x03,0xe1                ; Auen Wa NO - Windfang C - 120min
                      00353         de      0x02,0x0f                                               ; Auen Garage
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 186


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00354  endif
                      00355  
                      00356 
                      00357  if device == 0x08
                      00358 ;Input  Raum Position           Output  Relais  Raum Position
                      00359 ;I08.0  Eltern Tr A            O08.0                   Eltern Tr LED 1
                      00360 ;I08.1  Eltern Tr B            O08.1                   Eltern Tr LED 2
                      00361 ;I08.2  Eltern Tr C            O08.2                   Eltern Tr LED 3
                      00362 ;I08.3  Eltern Tr D            O08.3                   Eltern Tr LED 4
                      00363 ;I08.4  Eltern Tr E            O08.4                   Eltern Tr LED 5
                      00364 ;I08.5  Eltern Tr F            O08.5                   Eltern Tr LED 6
                      00365 ;I08.6  Eltern Tr G            O08.6                   Eltern Tr LED 7
                      00366 ;I08.7  Eltern Tr H            O08.7                   Eltern Tr LED 8
                      00367 ;I08.8  Eltern Bett NW A        O08.8                   Eltern Bett NW LED 1
                      00368 ;I08.9  Eltern Bett NW B        O08.9                   Eltern Bett NW LED 2
                      00369 ;I08.A  Eltern Bett NW C        O08.A                   Eltern Bett NW LED 3
                      00370 ;I08.B  Eltern Bett NW D        O08.B                   Eltern Bett NW LED 4
                      00371 ;I08.C  Eltern Bett NW E        O08.C   Rc23    Garage  Decke 1
                      00372 ;I08.D  Eltern Bett NW F        O08.D   Rc24    Garage  Decke 2
                      00373 ;I08.E  Eltern Bett NW G        O08.E   Rc25    Zysterne Pumpe  
                      00374 ;I08.F  Eltern Bett NW H        O08.F   Rc26     reserve      
                      00375 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00376         de      0x02,0x00                                               ; Eltern Tr LED 1 - Dauer aus
                      00377         de      0x03,0x01                                               ; Eltern Tr LED 2 - Dauer ein
                      00378         de      0x02,0x02                                               ; Eltern Tr LED 3 - Dauer aus
                      00379         de      0x02,0x03                                               ; Eltern Tr LED 4 - Dauer aus
                      00380         de      0x02,0x04                                               ; Eltern Tr LED 5 - Dauer aus
                      00381         de      0x02,0x05                                               ; Eltern Tr LED 6 - Dauer aus
                      00382         de      0x02,0x06                                               ; Eltern Tr LED 7 - Dauer aus
                      00383         de      0x02,0x07                                               ; Eltern Tr LED 8 - Dauer aus
                      00384         de      0x02,0x08                                               ; Eltern Bett NW LED 1 - Dauer a
                            us
                      00385         de      0x03,0x09                                               ; Eltern Bett NW LED 2 - Dauer e
                            in
                      00386         de      0x02,0x0a                                               ; Eltern Bett NW LED 3 - Dauer a
                            us
                      00387         de      0x02,0x0b                                               ; Eltern Bett NW LED 4 _ Dauer a
                            us
                      00388         de      0xb4,0x0c,0x05,0x0e,0x96                ; Garage Decke 1 - Garage C - 80min
                      00389         de      0x74,0x0c,0x04,0x0e,0x96                ; Garage Decke 1 - Garage B - 5min
                      00390         de      0x74,0x0c,0x06,0x03,0x96                ; Garage Decke 1 - Windfang Tr B - 5min
                      00391         de      0x04,0x0d,0x05,0x0e                             ; Garage Decke 2 - Garage C - toggle
                      00392         de      0x74,0x0d,0x04,0x0e,0x81                ; Garage Decke 2 - Garage B - 4.5min
                      00393         de      0x74,0x0d,0x06,0x03,0x81                ; Garage Decke 2 - Windfang Tr B - 4.5min
                      00394         de      0x64,0x0d,0x0A,0x0e,0x96                ; Garage Decke 2 - Antrieb Licht - 2.5min
                      00395         de      0xb4,0x0e,0x06,0x0e,0xa9                ; Pumpe Zysterne - Garage D (oben) - 90min
                      00396         de      0x02,0x0f                                               ; Rc26   reserve       -  Daue
                            r aus
                      00397  endif
                      00398  
                      00399 
                      00400  if device == 0x09
                      00401 ;Input  Raum Position           Output  Relais  Raum Position
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 187


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00402 ;I09.0  Eltern Bett NO A        O09.0                   Eltern Bett NO LED 1
                      00403 ;I09.1  Eltern Bett NO B        O09.1                   Eltern Bett NO LED 2
                      00404 ;I09.2  Eltern Bett NO C        O09.2                   Eltern Bett NO LED 3
                      00405 ;I09.3  Eltern Bett NO D        O09.3                   Eltern Bett NO LED 4
                      00406 ;I09.4  Eltern Bett NO E        O09.4   Rc27     reserve      
                      00407 ;I09.5  Eltern Bett NO F        O09.5   Rc28     reserve      
                      00408 ;I09.6  Eltern Bett NO G        O09.6   Rc29     reserve      
                      00409 ;I09.7  Eltern Bett NO H        O09.7   Rc30     reserve      
                      00410 ;I09.8  Treppe OG Ost A         O09.8   Oc01    Garagentor Up/Stop/Down                 
                      00411 ;I09.9  Treppe OG Ost B         O09.9   Oc02    Garagentor Reversieren          
                      00412 ;I09.A  Treppe OG Ost C         O09.A                   
                      00413 ;I09.B  Treppe OG Ost D         O09.B                           
                      00414 ;I09.C  Flur OG Sd A           O09.C   Rd01    J Kche Ost Power               
                      00415 ;I09.D  Flur OG Sd B           O09.D   Re01    J Kche Ost D/U         
                      00416 ;I09.E  Flur OG Sd C           O09.E   Rd02    J Kche Sd Power               
                      00417 ;I09.F  Flur OG Sd D           O09.F   Re02    J Kche Sd D/U         
                      00418 ; prescale+mode | output | input | device1 | delay(opt) | device2/delay2
                      00419         de      0x02,0x00                                               ; Eltern Bett NO LED 1 - Dauer a
                            us
                      00420         de      0x03,0x01                                               ; Eltern Bett NO LED 2 - Dauer e
                            in
                      00421         de      0x02,0x02                                               ; Eltern Bett NO LED 3 - Dauer a
                            us
                      00422         de      0x02,0x03                                               ; Eltern Bett NO LED 4 - Dauer a
                            us
                      00423         de      0x02,0x04                                               ; Rc27   reserve  - Dauer aus
                      00424         de      0x02,0x05                                               ; Rc28   reserve  - Dauer aus
                      00425         de      0x02,0x06                                               ; Rc29   reserve  - Dauer aus
                      00426         de      0x02,0x07                                               ; Rc30   reserve  - Dauer aus
                      00427         de      0x01,0x08,0x05,0x04                             ; Garagentor U/S/D - Kche Ost H
                      00428         de      0x01,0x08,0x03,0x0e                             ; Garagentor U/S/D - Garage A
                      00429         de      0x01,0x08,0x07,0x0e                             ; Garagentor U/S/D - Schlsselschalter
                      00430         de      0x09,0x09,0x08,0x0e,0x01,0x0d   ; Garagentor Lichtschranke
                      00431         de      0x02,0x0a                                               ; Dauer aus
                      00432         de      0x02,0x0b                                               ; Dauer aus
                      00433         de      0x5e,0xdc,0x98,0x04,0x81,0x04   ; J Kche O
                      00434         de      0x5e,0xdc,0xfe,0x03,0x81,0x03   ; J Kche O
                      00435         de      0x5e,0xdc,0xed,0x02,0x81,0x02   ; J Kche O
                      00436         de      0x5e,0xdc,0x76,0x09,0x81,0x09   ; J Kche O - Eltern Bett NO GH
                      00437         de      0x5e,0xdc,0x0e,0x0e,0x81,0xf0   ; J Kche O - Wind auf
                      00438         de      0x5e,0xfe,0x98,0x04,0x81,0x04   ; J Kche S
                      00439         de      0x5e,0xfe,0x10,0x04,0x81,0x04   ; J Kche S
                      00440         de      0x5e,0xfe,0xed,0x02,0x81,0x02   ; J Kche S
                      00441         de      0x5e,0xfe,0x76,0x09,0x81,0x09   ; J Kche S - Eltern Bett NO GH
                      00442         de      0x5e,0xfe,0x0e,0x0e,0x81,0xf0   ; J Kche S - Wind auf
                      00443  endif
                      00444  
                      00445 
                      00446  if device == 0x0a
                      00447 ;Input  Raum Position           Output  Relais  Raum Position
                      00448 ;I0A.0  Kinderbad Tr A         O0A.0                   Kinderbad Tr LED 1
                      00449 ;I0A.1  Kinderbad Tr B         O0A.1                   Kinderbad Tr LED 2
                      00450 ;I0A.2  Kinderbad Tr C         O0A.2                   Kinderbad Tr LED 3
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 188


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00451 ;I0A.3  Kinderbad Tr D         O0A.3                   Kinderbad Tr LED 4
                      00452 ;I0A.4  Kinderbad Tr E         O0A.4   Rd03    J Essen Sd Power       
                      00453 ;I0A.5  Kinderbad Tr F         O0A.5   Re03    J Essen Sd D/U 
                      00454 ;I0A.6  Kinderbad Tr G         O0A.6   Rd04    J Essen SW Power        
                      00455 ;I0A.7  Kinderbad Tr H         O0A.7   Re04    J Essen SW D/U  
                      00456 ;I0A.8  Kinderbad Fenster       O0A.8   Rd05    J Essen NW Power        
                      00457 ;I0A.9  Kind1 Fenster O         O0A.9   Re05    J Essen NW D/U  
                      00458 ;I0A.A  Kind1 Fenster S         O0A.A   Rd06    J Wohnen SO Power       
                      00459 ;I0A.B  Kind2 Fenster S         O0A.B   Re06    J Wohnen SO D/U 
                      00460 ;I0A.C  Kind2 Fenster W         O0A.C   Rd07    J Wohnen SW Power       
                      00461 ;I0A.D  Kind3 Fenster S         O0A.D   Re07    J Wohnen SW D/U 
                      00462 ;I0A.E  Kind3 Fenster W         O0A.E   Rd08    J Wohnen NW D/U 
                      00463 ;I0A.F  Fenster Sabotage        O0A.F   Re08    J Wohnen NW Power       
                      00464 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00465         de      0x02,0x00
                      00466         de      0x03,0x01
                      00467         de      0x02,0x02
                      00468         de      0x02,0x03
                      00469         de      0x5e,0x54,0xba,0x04,0x81,0x04   ; J Essen S
                      00470         de      0x5e,0x54,0x32,0x05,0x81,0x05   ; J Essen S
                      00471         de      0x5e,0x54,0xed,0x02,0x81,0x02   ; J Essen S
                      00472         de      0x5e,0x54,0x76,0x09,0x81,0x09   ; J Essen S - Eltern Bett NO GH
                      00473         de      0x5e,0x54,0x0e,0x0e,0x81,0xf0   ; J Essen S - Wind auf*
                      00474         de      0x5e,0x76,0xba,0x04,0x81,0x04   ; J Essen SW
                      00475         de      0x5e,0x76,0xed,0x02,0x81,0x02   ; J Essen SW
                      00476         de      0x5e,0x76,0x10,0x05,0x81,0x05   ; J Essen SW
                      00477         de      0x5e,0x76,0x76,0x09,0x81,0x09   ; J Essen SW - Eltern Bett NO GH
                      00478         de      0x5e,0x76,0x0e,0x0e,0x81,0xf0   ; J Essen SW - Wind auf*
                      00479         de      0x5e,0x98,0xba,0x04,0x81,0x04   ; J Essen NW
                      00480         de      0x5e,0x98,0x54,0x05,0x81,0x05   ; J Essen NW
                      00481         de      0x5e,0x98,0xed,0x02,0x81,0x02   ; J Essen NW
                      00482         de      0x5e,0x98,0x76,0x09,0x81,0x09   ; J Essen NW - Eltern Bett NO GH
                      00483         de      0x5e,0x98,0x0e,0x0e,0x81,0xf0   ; J Essen NW - Wind auf*
                      00484         de      0x5e,0xba,0x10,0x0f,0x81,0x0f   ; J Wohnen SO
                      00485         de      0x5e,0xba,0xed,0x02,0x81,0x02   ; J Wohnen SO
                      00486         de      0x5e,0xba,0x76,0x0f,0x81,0x0f   ; J Wohnen SO
                      00487         de      0x5e,0xba,0x76,0x09,0x81,0x09   ; J Wohnen SO - Eltern Bett NO GH
                      00488         de      0x5e,0xba,0x0e,0x0e,0x81,0xf0   ; J Wohnen SO - Wind auf*
                      00489         de      0x5e,0xdc,0x54,0x0f,0x81,0x0f   ; J Wohnen SW
                      00490         de      0x5e,0xdc,0x76,0x0f,0x81,0x0f   ; J Wohnen SW
                      00491         de      0x5e,0xdc,0xed,0x02,0x81,0x02   ; J Wohnen SW
                      00492         de      0x5e,0xdc,0x76,0x09,0x81,0x09   ; J Wohnen SW - Eltern Bett NO GH
                      00493         de      0x5e,0xdc,0x0e,0x0e,0x81,0xf0   ; J Wohnen SW - Wind auf*
                      00494         de      0x5e,0xfe,0x76,0x0f,0x81,0x0f   ; J Wohnen NW
                      00495         de      0x5e,0xfe,0xdc,0x06,0x81,0x06   ; J Wohnen NW
                      00496         de      0x5e,0xfe,0xed,0x02,0x81,0x02   ; J Wohnen NW
                      00497         de      0x5e,0xfe,0x76,0x09,0x81,0x09   ; J Wohnen NW - Eltern Bett NO GH
                      00498         de      0x5e,0xfe,0x0e,0x0e,0x81,0xf0   ; J Wohnen NW - Wind auf*
                      00499  endif
                      00500 
                      00501 
                      00502  if device == 0x0b
                      00503 ;Input  Raum Position           Output  Relais  Raum Position
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 189


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00504 ;I0B.0  Kind1 Tr A                     O0B.0                   Kind1 Tr LED 1
                      00505 ;I0B.1  Kind1 Tr B                     O0B.1                   Kind1 Tr LED 2
                      00506 ;I0B.2  Kind1 Tr C                     O0B.2                   Kind1 Tr LED 3
                      00507 ;I0B.3  Kind1 Tr D                     O0B.3                   Kind1 Tr LED 4
                      00508 ;I0B.4  Kind1 Tr E                     O0B.4   Rd09    J Wohnen Nord Power     
                      00509 ;I0B.5  Kind1 Tr F                     O0B.5   Re09    J Wohnen Nord D/U       
                      00510 ;I0B.6  Kind1 Tr G                     O0B.6   Rd10    J Elternbad Power       
                      00511 ;I0B.7  Kind1 Tr H                     O0B.7   Re10    J Elternbad D/U 
                      00512 ;I0B.8  Kind1 Bett E            O0B.8                   Kind1 Bett LED 1
                      00513 ;I0B.9  Kind1 Bett F            O0B.9                   Kind1 Bett LED 2
                      00514 ;I0B.A  Kind1 Bett G            O0B.A                   Kind1 Bett LED 3
                      00515 ;I0B.B  Kind1 Bett H            O0B.B                   Kind1 Bett LED 4
                      00516 ;I0B.C  Kind1 Bett I            O0B.C   Rd11    J Eltern Power  
                      00517 ;I0B.D  Kind1 Bett J            O0B.D   Re11    J Eltern D/U    
                      00518 ;I0B.E  Kind1 Bett K            O0B.E   Rd12    J Kinderbad Power       
                      00519 ;I0B.F  Kind1 Bett L            O0B.F   Re12    J Kinderbad D/U 
                      00520 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00521         de      0x02,0x00
                      00522         de      0x03,0x01
                      00523         de      0x02,0x02
                      00524         de      0x02,0x03
                      00525         de      0x5e,0x54,0x76,0x0f,0x81,0x0f   ; J Wohnen Nord
                      00526         de      0x5e,0x54,0xfe,0x06,0x81,0x06   ; J Wohnen Nord
                      00527         de      0x5e,0x54,0xed,0x02,0x81,0x02   ; J Wohnen Nord
                      00528         de      0x5e,0x54,0x76,0x09,0x81,0x09   ; J Wohnen Nord - Eltern Bett NO GH
                      00529         de      0x5e,0x54,0x0e,0x0e,0x81,0xf0   ; J Wohnen Nord - Wind auf
                      00530         de      0x5e,0x76,0x98,0x07,0x81,0x07   ; J Elternbad
                      00531         de      0x5e,0x76,0x76,0x08,0x81,0x08   ; J Elternbad
                      00532         de      0x5e,0x76,0x76,0x09,0x81,0x09   ; J Elternbad - Eltern Bett NO GH
                      00533         de      0x5e,0x76,0x0e,0x0e,0x81,0xf0   ; J Elternbad - Wind auf
                      00534         de      0x02,0x08
                      00535         de      0x03,0x09
                      00536         de      0x02,0x0a
                      00537         de      0x02,0x0b
                      00538         de      0x5e,0xdc,0xba,0x07,0x81,0x07   ; J Eltern
                      00539         de      0x5e,0xdc,0x54,0x08,0x81,0x08   ; J Eltern
                      00540         de      0x5e,0xdc,0xfe,0x08,0x81,0x08   ; J Eltern
                      00541         de      0x5e,0xdc,0x32,0x09,0x81,0x09   ; J Eltern
                      00542         de      0x5e,0xdc,0x76,0x09,0x81,0x09   ; J Eltern - Eltern Bett NO GH
                      00543         de      0x5e,0xdc,0x0e,0x0e,0x81,0xf0   ; J Eltern - Wind auf
                      00544         de      0x5e,0xfe,0x54,0x0a,0x81,0x0a   ; J Kinderbad
                      00545         de      0x5e,0xfe,0x76,0x09,0x81,0x09   ; J Kinderbad - Eltern Bett NO GH
                      00546         de      0x5e,0xfe,0x0e,0x0e,0x81,0xf0   ; J Kinderbad - Wind auf
                      00547 
                      00548  endif
                      00549  
                      00550 
                      00551  if device == 0x0c
                      00552 ;Input  Raum Position           Output  Relais  Raum Position
                      00553 ;I0C.0  Kind2 Tr&Bett A        O0C.0                   Kind2 Tr LED 1
                      00554 ;I0C.1  Kind2 Tr&Bett B        O0C.1                   Kind2 Tr LED 2
                      00555 ;I0C.2  Kind2 Tr&Bett C        O0C.2                   Kind2 Tr LED 3
                      00556 ;I0C.3  Kind2 Tr&Bett D        O0C.3                   Kind2 Tr LED 4
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 190


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00557 ;I0C.4  Kind2 Tr E                     O0C.4   Rd13    J Kind1 Ost Power       
                      00558 ;I0C.5  Kind2 Tr F                     O0C.5   Re13    J Kind1 Ost D/U 
                      00559 ;I0C.6  Kind2 Tr G                     O0C.6   Rd14    J Kind1 Sd Power       
                      00560 ;I0C.7  Kind2 Tr H                     O0C.7   Re14    J Kind1 Sd D/U 
                      00561 ;I0C.8  Kind2 Bett E            O0C.8                   Kind2 Bett LED 1
                      00562 ;I0C.9  Kind2 Bett F            O0C.9                   Kind2 Bett LED 2
                      00563 ;I0C.A  Kind2 Bett G            O0C.A                   Kind2 Bett LED 3
                      00564 ;I0C.B  Kind2 Bett H            O0C.B                   Kind2 Bett LED 4
                      00565 ;I0C.C  Kind2 Bett I            O0C.C   Rd15    J Kind2 Sd Power       
                      00566 ;I0C.D  Kind2 Bett J            O0C.D   Re15    J Kind2 Sd D/U 
                      00567 ;I0C.E  Kind2 Bett K            O0C.E   Rd16    J Kind2 West Power      
                      00568 ;I0C.F  Kind2 Bett L            O0C.F   Re16    J Kind2 West D/U        
                      00569 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00570         de      0x02,0x00
                      00571         de      0x03,0x01
                      00572         de      0x02,0x02
                      00573         de      0x02,0x03
                      00574         de      0x5e,0x54,0x54,0x0b,0x81,0x0b   ; J Kind1 Ost
                      00575         de      0x5e,0x54,0xdc,0x0b,0x81,0x0b   ; J Kind1 Ost
                      00576         de      0x5e,0x54,0x76,0x09,0x81,0x09   ; J Kind1 Ost - Eltern Bett NO GH
                      00577         de      0x5e,0x54,0x0e,0x0e,0x81,0xf0   ; J Kind1 Ost - Wind auf
                      00578         de      0x5e,0x76,0x76,0x0b,0x81,0x0b   ; J Kind1 Sd
                      00579         de      0x5e,0x76,0xfe,0x0b,0x81,0x0b   ; J Kind1 Sd
                      00580         de      0x5e,0x76,0x76,0x09,0x81,0x09   ; J Kind1 Sd - Eltern Bett NO GH
                      00581         de      0x5e,0x76,0x0e,0x0e,0x81,0xf0   ; J Kind1 Sd - Wind auf
                      00582         de      0x02,0x08
                      00583         de      0x03,0x09
                      00584         de      0x02,0x0a
                      00585         de      0x02,0x0b
                      00586         de      0x5e,0xdc,0x10,0x0c,0x81,0x0c   ; J Kind2 Sd
                      00587         de      0x5e,0xdc,0x76,0x09,0x81,0x09   ; J Kind2 Sd - Eltern Bett NO GH
                      00588         de      0x5e,0xdc,0x0e,0x0e,0x81,0xf0   ; J Kind2 Sd - Wind auf
                      00589         de      0x5e,0xfe,0x32,0x0c,0x81,0x0c   ; J Kind2 West
                      00590         de      0x5e,0xfe,0x76,0x09,0x81,0x09   ; J Kind2 West - Eltern Bett NO GH
                      00591         de      0x5e,0xfe,0x0e,0x0e,0x81,0xf0   ; J Kind2 West - Wind auf
                      00592  endif
                      00593  
                      00594 
                      00595  if device == 0x0d
                      00596 ;Input  Raum Position           Output  Relais  Raum Position
                      00597 ;I0D.0  Kind3 Tr A                     O0D.0                   Kind3 Tr LED 1
                      00598 ;I0D.1  Kind3 Tr B                     O0D.1                   Kind3 Tr LED 2
                      00599 ;I0D.2  Kind3 Tr C                     O0D.2                   Kind3 Tr LED 3
                      00600 ;I0D.3  Kind3 Tr D                     O0D.3                   Kind3 Tr LED 4
                      00601 ;I0D.4  Kind3 Tr E                     O0D.4   Rd17    J Kind3 Sd Power       
                      00602 ;I0D.5  Kind3 Tr F                     O0D.5   Re17    J Kind3 Sd D/U 
                      00603 ;I0D.6  Kind3 Tr G                     O0D.6   Re18    J Kind3 West Power      
                      00604 ;I0D.7  Kind3 Tr H                     O0D.7   Re18    J Kind3 West D/U        
                      00605 ;I0D.8  Kind3 Bett A            O0D.8                   Kind3 Bett LED 1
                      00606 ;I0D.9  Kind3 Bett B            O0D.9                   Kind3 Bett LED 2
                      00607 ;I0D.A  Kind3 Bett C            O0D.A                   Kind3 Bett LED 3
                      00608 ;I0D.B  Kind3 Bett D            O0D.B                   Kind3 Bett LED 4
                      00609 ;I0D.C  Kind3 Bett E            O0D.C   Rd19    Sonnensegel     Power   
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 191


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00610 ;I0D.D  Kind3 Bett F            O0D.D   Re19    Sonnensegel     O/C     
                      00611 ;I0D.E  Kind3 Bett G            O0D.E   Rd20    F Kinderbad     zu      
                      00612 ;I0D.F  Kind3 Bett H            O0D.F   Re20    F Kinderbad     auf     
                      00613 ; prescale+mode | output | input | device1 | delay(opt) | device2
2103   0002 0000      00614         de      0x02,0x00
2105   0003 0001      00615         de      0x03,0x01
2107   0002 0002      00616         de      0x02,0x02
2109   0002 0003      00617         de      0x02,0x03
210B   005E 0054 0010 00618         de      0x5e,0x54,0x10,0x0d,0x81,0x0d   ; J Kind3 Sd
       000D 0081 000D 
2111   005E 0054 0098 00619         de      0x5e,0x54,0x98,0x0d,0x81,0x0d   ; J Kind3 Sd
       000D 0081 000D 
2117   005E 0054 0076 00620         de      0x5e,0x54,0x76,0x09,0x81,0x09   ; J Kind3 Sd - Eltern Bett NO GH
       0009 0081 0009 
211D   005E 0054 000E 00621         de      0x5e,0x54,0x0e,0x0e,0x81,0xf0   ; J Kind3 Sd - Wind auf
       000E 0081 00F0 
2123   005E 0076 0032 00622         de      0x5e,0x76,0x32,0x0d,0x81,0x0d   ; J Kind3 West
       000D 0081 000D 
2129   005E 0076 00BA 00623         de      0x5e,0x76,0xba,0x0d,0x81,0x0d   ; J Kind3 West
       000D 0081 000D 
212F   005E 0076 0076 00624         de      0x5e,0x76,0x76,0x09,0x81,0x09   ; J Kind3 West - Eltern Bett NO GH
       0009 0081 0009 
2135   005E 0076 000E 00625         de      0x5e,0x76,0x0e,0x0e,0x81,0xf0   ; J Kind3 West - Wind auf
       000E 0081 00F0 
213B   0002 0008      00626         de      0x02,0x08
213D   0003 0009      00627         de      0x03,0x09
213F   0002 000A      00628         de      0x02,0x0a
2141   0002 000B      00629         de      0x02,0x0b
2143   005D 00DC 00EF 00630         de      0x5d,0xdc,0xef,0x05,0x81,0x05   ; J Sonnensegel - Esszimmer P/O
       0005 0081 0005 
2149   005D 00DC 00E0 00631         de      0x5d,0xdc,0xe0,0xf0,0x81,0x0e   ; J Sonnensegel - Wind zu
       00F0 0081 000E 
                      00632 ;       de      0x5f,0xef,0x76,0x0a,0x81,0x0a   ; F Kinderbad - Tr Kinderbad G/H
214F   005F 00EF 0098 00633         de      0x5f,0xef,0x98,0x08,0x81,0x08   ; F Kinderbad
       0008 0081 0008 
2155   005F 00EF 00D0 00634         de      0x5f,0xef,0xd0,0xf0,0x81,0x0e   ; F Kinderbad - Regen zu
       00F0 0081 000E 
215B   005F 00EF 00E0 00635         de      0x5f,0xef,0xe0,0xf0,0x81,0x0e   ; F Kinderbad - Wind zu
       00F0 0081 000E 
                      00636  endif
                      00637  
                      00638 
                      00639  if device == 0x0e
                      00640 ;Input  Raum Position           Output  Relais  Raum Position
                      00641 ;I0E.0  Abstellk. Tr A         O0E.0   Rd21    F Flur OG SO zu
                      00642 ;I0E.1  untere Bhne Tr A      O0E.1   Re21    F Flur OG SO auf
                      00643 ;I0E.2  obere Bhne Tr A       O0E.2   Rd22    F Flur OG S zu
                      00644 ;I0E.3  Garage Tr A            O0E.3   Rd23    F Flur OG S auf
                      00645 ;I0E.4  Garage Tr B            O0E.4   Rd23    F Flur OG SW zu
                      00646 ;I0E.5  Garage Tr C            O0E.5   Re23    F Flur OG SW auf
                      00647 ;I0E.6  Garage Tr D            O0E.6                   
                      00648 ;I0E.7  Garage Schlssel        O0E.7                   
                      00649 ;I0E.8  Garage Lichtschr.       O0E.8   Garage EinfahrLED               
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 192


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00650 ;I0E.9  Garage Endposition      O0E.9                   
                      00651 ;I0E.A  Garage Antriebsl.       O0E.A                   
                      00652 ;I0E.B  Wchter Sonne           O0E.B                   
                      00653 ;I0E.C  Wchter Dmmerung       O0E.C                   
                      00654 ;I0E.D  Wchter Regen           O0E.D                   
                      00655 ;I0E.E  Wchter Wind            O0E.E                   
                      00656 ;I0E.F  Wchter Frost           O0E.F                   
                      00657 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00658 ;       de      0x5f,0x01,0xa9,0x0c,0x81,0x0c
                      00659 ;       de      0x5f,0x23,0xa9,0x0c,0x81,0x0c
                      00660 ;       de      0x5f,0x45,0xa9,0x0c,0x81,0x0c
                      00661 ;       de      0x5f,0x01,0xfe,0x09,0x81,0x09
                      00662 ;       de      0x5f,0x23,0xfe,0x09,0x81,0x09
                      00663 ;       de      0x5f,0x45,0xfe,0x09,0x81,0x09
                      00664         de      0x5f,0x01,0xba,0x08,0x81,0x08   ; F Flur OG SO
                      00665         de      0x5f,0x01,0xd0,0xf0,0x81,0x0e   ; F Flur OG SO - Regen zu
                      00666         de      0x5f,0x01,0xe0,0xf0,0x81,0x0e   ; F Flur OG SO - Wind zu
                      00667         de      0x5f,0x23,0xba,0x08,0x81,0x08   ; F Flur OG S
                      00668         de      0x5f,0x23,0xd0,0xf0,0x81,0x0e   ; F Flur OG S - Regen zu
                      00669         de      0x5f,0x23,0xe0,0xf0,0x81,0x0e   ; F Flur OG S - Wind zu
                      00670         de      0x5f,0x45,0xba,0x08,0x81,0x08   ; F Flur OG SW
                      00671         de      0x5f,0x45,0xd0,0xf0,0x81,0x0e   ; F Flur OG SW - Regen zu
                      00672         de      0x5f,0x45,0xe0,0xf0,0x81,0x0e   ; F Flur OG SW - Wind zu
                      00673         de      0x02,0x06
                      00674         de      0x02,0x07
                      00675         de      0x49,0x08,0x08,0x0e,0x01,0x0d   ; Garage EinfahrLED - Garage Lichtschranke
                      00676         de      0x02,0x09
                      00677         de      0x02,0x0a
                      00678         de      0x02,0x0b
                      00679         de      0x02,0x0c
                      00680         de      0x02,0x0d
                      00681         de      0x02,0x0e
                      00682         de      0x02,0x0f
                      00683  endif
                      00684  
                      00685 
                      00686  if device == 0x0f
                      00687 ;Input  Raum Position           Output  Relais  Raum Position
                      00688 ;I0F.0  Wohnen Sd A            O0F.0                   Wohnen Sd LED 1
                      00689 ;I0F.1  Wohnen Sd B            O0F.1                   Wohnen Sd LED 2
                      00690 ;I0F.2  Wohnen Sd C            O0F.2                   Wohnen Sd LED 2
                      00691 ;I0F.3  Wohnen Sd D            O0F.3                   Wohnen Sd LED 4
                      00692 ;I0F.4  Wohnen Sd E            O0F.4                   Wohnen Sd LED 9
                      00693 ;I0F.5  Wohnen Sd F            O0F.5                   Wohnen Sd LED A
                      00694 ;I0F.6  Wohnen Sd G            O0F.6                   Wohnen Sd LED B
                      00695 ;I0F.7  Wohnen Sd H            O0F.7                   Wohnen Sd LED C        
                      00696 ;I0F.8  Wohnen Sd I            O0F.8
                      00697 ;I0F.9  Wohnen Sd J            O0F.9
                      00698 ;I0F.A  Wohnen Sd K            O0F.A
                      00699 ;I0F.B  Wohnen Sd L            O0F.B
                      00700 ;I0F.C  Wohnen Sd M            O0F.C
                      00701 ;I0F.D  Wohnen Sd N            O0F.D
                      00702 ;I0F.E  Wohnen Sd O            O0F.E
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 193


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00703 ;I0F.F  Wohnen Sd P            O0F.F
                      00704 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00705         de      0x02,0x00
                      00706         de      0x03,0x01
                      00707         de      0x02,0x02
                      00708         de      0x02,0x03
                      00709         de      0x02,0x04
                      00710         de      0x02,0x05
                      00711         de      0x02,0x06
                      00712         de      0x02,0x07
                      00713  endif
                      00714 
                      00715 
                      00716 
                      00717 ; mode 0 - 1 exit
                      00718 ; mode 1 - 4 passthrough
                      00719 ; mode 2 - 2 always off
                      00720 ; mode 3 - 2 always on
                      00721 ; mode 4 - 4 toggle light
                      00722 ; mode 5 - 4 light toogle dual outputs
                      00723 ; mode 6 - 5 two stage light (output1: 1st stage output1+2 2nd stage)
                      00724 ; mode 7 - 1 nop
                      00725 ; mode 8 - 5 retriggerable timer
                      00726 ; mode 9 - 5 blinker
                      00727 ; mode a - 1 nop
                      00728 ; mode b - 1 nop
                      00729 ; mode c - 1 nop
                      00730 ; mode d - 1 nop
                      00731 ; mode e - 6 blind (output1: on/off output2: up/down
                      00732 ; mode f - 6 window (output1: up output2: down)
                      00733 
                      00734  if device == 0x4d
                      00735 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00736         de      0x04,0x00,0x0c,0x05                             ; Essen Steckdose Nord - Essen West M
                      00737         de      0x02,0x01                                               ; Essen  reserve  - Dauer aus
                      00738         de      0x56,0x32,0x02,0x0f,0x28                ; Wohnen DL 1/2 - Wohnen Sd B
                      00739         de      0x56,0x32,0x07,0x05,0x28                ; Wohnen DL 1/2 - Essen West H
                      00740         de      0x04,0x04,0x03,0x0f                             ; Wohnen Steckdose West - Wohnen Sd D
                      00741         de      0x04,0x04,0x08,0x06                             ; Wohnen Steckdose West - Wohnen Nord A
                      00742         de  0x04,0x04,0x06,0x05                         ; Wohnen Steckdose West - Essen West G
                      00743         de      0x56,0x5a,0x00,0x4d,0x28                ; Wohnen Wand Nord/Ost-Nord - Wohnen Nord B
                      00744         de      0x56,0xa5,0x01,0x4d,0x28                ; Wohnen Wand Nord/Ost-Nord - Wohnen Nord B
                      00745         de      0x04,0x05,0x02,0x4d                             ; Wohnen Wand Nord - Wohnen Sd I
                      00746         de      0xb4,0x06,0x05,0x0e,0x96                ; Windfang Tr LED 1 - Garage Decke 1 - Garage C
                             - 80min
                      00747         de      0x74,0x06,0x04,0x0e,0x96                ; Windfang Tr LED 1 - Garage Decke 1 - Garage B
                             - 5min
                      00748         de      0x74,0x06,0x06,0x03,0x96                ; Windfang Tr LED 1 - Garage Decke 1 - Windfang
                             Tr B - 5min
                      00749         de      0x03,0x07                                               ; Windfang Tr LED 2 - Dauer ein
                      00750         de      0xb4,0x08,0x08,0x03,0xe1                ; Windfang Tr LED 3 - Windfang Tr C - Kontroll
                            e Auen NO - 120min
                      00751         de      0xb4,0x09,0x09,0x03,0xe1                ; Windfang Tr LED 4 - Windfang Tr D - Kontroll
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 194


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            e Auen Eingang - 120min
                      00752     de  0x04,0x0a,0x03,0x4d                             ; Wohnen Wand Ost-Nord - Wohnen Sd J
                      00753     de  0x04,0x0b,0x04,0x4d                             ; Wohnen Wand Ost-Sd - Wohnen Sd K
                      00754         de      0x56,0xed,0x05,0x4d,0x28                ; Wohnen Wand Nord/Ost-Nord - Wohnen Nord B
                      00755         de      0x56,0xef,0x06,0x4d,0x28                ; Wohnen Wand Nord/Ost-Nord - Wohnen Nord B
                      00756  endif
                      00757 
                      00758 
                      00759  if device == 0x4e
                      00760 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00761         de      0x04,0x0f,0x00,0x4f
                      00762         de      0x04,0x0e,0x01,0x4f
                      00763         de      0x04,0x0d,0x02,0x4f
                      00764         de      0x04,0x0c,0x03,0x4f
                      00765         de      0x04,0x0b,0x04,0x4f
                      00766         de      0x04,0x0a,0x05,0x4f
                      00767         de      0x04,0x09,0x06,0x4f
                      00768         de      0x04,0x08,0x07,0x4f
                      00769         de      0x04,0x07,0x08,0x4f
                      00770         de      0x04,0x06,0x09,0x4f
                      00771         de      0x04,0x05,0x0a,0x4f
                      00772         de      0x04,0x04,0x0b,0x4f
                      00773         de      0x04,0x03,0x0c,0x4f
                      00774         de      0x04,0x02,0x0d,0x4f
                      00775         de      0x04,0x01,0x0e,0x4f
                      00776         de      0x04,0x00,0x0f,0x4f
                      00777  endif
                      00778 
                      00779 
                      00780  if device == 0x4f
                      00781 ; prescale+mode | output | input | device1 | delay(opt) | device2
                      00782         de      0x01,0x00,0x00,0x4f
                      00783 ;       de      0x02,0x01
                      00784 ;       de      0x03,0x02
                      00785         de      0x58,0x01,0x01,0x4f,0x28
                      00786         de      0x59,0x02,0x02,0x4f,0x28
                      00787         de      0x54,0x03,0x01,0x4f,0x20
                      00788         de      0x04,0x04,0x02,0x4f
                      00789         de      0x04,0x05,0x03,0x4f
                      00790         de      0x05,0x54,0x04,0x4f
                      00791         de      0x55,0x54,0x05,0x4f,0x10
                      00792         de      0x56,0x76,0x06,0x4f,0x28
                      00793         de      0x5e,0x98,0x89,0x4f,0x81,0x4f
                      00794         de      0x5f,0xba,0xab,0x4f,0x81,0x4f
                      00795         de      0x54,0x0c,0x0c,0x4f,0x20
                      00796         de      0x54,0x0c,0x0d,0x4f,0x10
                      00797 ;       de      0x09,0x0e,0x0e,0x4f,0x01,0x0d
                      00798 ;       de      0x49,0x0f,0x0f,0x4f,0x01,0x0d
                      00799         de      0x5d,0xfe,0xef,0x4f,0x81,0x4f   ; J Sonnensegel - Esszimmer P/O
                      00800  endif
                      00801 
                      00802 
2161   0000           00803         de      0x00                                    ; termination
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 195


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00804  
                      00805  if             ($ > 0x21ff )
                      00806                                 error   "Action table is to long" 
                      00807  endif  ;}
                      00336                                 end
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 196


SYMBOL TABLE
  LABEL                             VALUE 

ADCON0                            0000001F
ADCON1                            0000009F
ADCS0                             00000004
ADCS1                             00000005
ADCS2                             00000006
ADDEN                             00000003
ADFM                              00000007
ADIE                              00000006
ADIF                              00000006
ADON                              00000000
ADRESH                            0000001E
ADRESL                            0000009E
AN0                               00000000
AN1                               00000001
AN2                               00000002
AN3                               00000003
AN4                               00000004
AN5                               00000005
AN6                               00000006
AN7                               00000007
ANS0                              00000000
ANS1                              00000001
ANS2                              00000002
ANS3                              00000003
ANS4                              00000004
ANS5                              00000005
ANS6                              00000006
ANS7                              00000007
ANSEL                             00000091
BAUD_19200                        .25
BAUD_38400                        .12
BAUD_57600                        .08
BAUD_9600                         .50
BF                                00000000
BIASMD                            00000006
BRGH                              00000002
BUFSIZE                           0x20
BYTE0                             0
BYTE1                             1
BYTE2                             2
BYTE3                             3
BYTE4                             4
C                                 00000000
C1IE                              00000005
C1IF                              00000005
C1INV                             00000004
C1OUT                             00000006
C2IE                              00000006
C2IF                              00000006
C2INV                             00000005
C2OUT                             00000007
C2SYNC                            00000000
CALC_HIGH_BAUD                    (XTAL_FREQ/(16*BaudRate))-.5
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 197


SYMBOL TABLE
  LABEL                             VALUE 

CALC_LOW_BAUD                     (((10*XTAL_FREQ/(64*BaudRate))+5)/10)-1
CALC_TIMER                        (0xFFFF-((TickTime*XTAL_FREQ)/32000))+1
CCP1CON                           00000017
CCP1IE                            00000002
CCP1IF                            00000002
CCP1M0                            00000000
CCP1M1                            00000001
CCP1M2                            00000002
CCP1M3                            00000003
CCP1X                             00000005
CCP1Y                             00000004
CCP2CON                           0000001D
CCP2IE                            00000000
CCP2IF                            00000000
CCP2M0                            00000000
CCP2M1                            00000001
CCP2M2                            00000002
CCP2M3                            00000003
CCP2X                             00000005
CCP2Y                             00000004
CCPR1                             00000015
CCPR1H                            00000016
CCPR1L                            00000015
CCPR2                             0000001B
CCPR2H                            0000001C
CCPR2L                            0000001B
CHS0                              00000002
CHS1                              00000003
CHS2                              00000004
CIS                               00000003
CKE                               00000006
CKP                               00000004
CM0                               00000000
CM1                               00000001
CM2                               00000002
CMCON0                            0000009C
CMCON1                            00000097
CMDACK                            0x03
CMDAOFF                           0x5F
CMDAON                            0x7F
CMDCGACK                          0x0D
CMDCGET                           0x0C
CMDCSET                           0x0E
CMDGOFF                           0x50
CMDGON                            0x70
CMDI                              0xB0
CMDID                             0x04
CMDIOANS                          0x08
CMDIRD                            0x06
CMDNEDGE                          0x20
CMDNEEDCFG                        0x0F
CMDO                              0xA0
CMDOC                             0x80
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 198


SYMBOL TABLE
  LABEL                             VALUE 

CMDOFF                            0x01
CMDORD                            0x07
CMDOS                             0x90
CMDOWR                            0x05
CMDPEDGE                          0x10
CMDRESET                          0x02
CMDSOFF                           0x40
CMDSON                            0x60
CMDTGACK                          0x0B
CMDTGET                           0x0A
CMDTSET                           0x09
CRC8                              00000FE0
CREN                              00000004
CS0                               00000002
CS1                               00000003
CSRC                              00000007
D                                 00000005
DATA_ADDRESS                      00000005
DC                                00000001
DEFINES                           00000000
D_A                               00000005
D_NOT_A                           00000005
EEADR                             0000010D
EEADRH                            0000010F
EEADRH0                           00000000
EEADRH1                           00000001
EEADRH2                           00000002
EEADRH3                           00000003
EEADRH4                           00000004
EEADRL                            0000010D
EEADRL0                           00000000
EEADRL1                           00000001
EEADRL2                           00000002
EEADRL3                           00000003
EEADRL4                           00000004
EEADRL5                           00000005
EEADRL6                           00000006
EEADRL7                           00000007
EECON1                            0000018C
EECON2                            0000018D
EEDATA                            0000010C
EEDATH                            0000010E
EEDATH0                           00000000
EEDATH1                           00000001
EEDATH2                           00000002
EEDATH3                           00000003
EEDATH4                           00000004
EEDATH5                           00000005
EEDATL                            0000010C
EEDATL0                           00000000
EEDATL1                           00000001
EEDATL2                           00000002
EEDATL3                           00000003
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 199


SYMBOL TABLE
  LABEL                             VALUE 

EEDATL4                           00000004
EEDATL5                           00000005
EEDATL6                           00000006
EEDATL7                           00000007
EEIE                              00000007
EEIF                              00000007
EEPGD                             00000007
EERD                              00000000
EEWR                              00000001
F                                 00000001
FERR                              00000002
FSR                               00000004
GIE                               00000007
GO                                00000001
GO_DONE                           00000001
GO_NOT_DONE                       00000001
HTS                               00000002
I2C_DATA                          00000005
I2C_READ                          00000002
I2C_START                         00000003
I2C_STOP                          00000004
INDF                              00000000
INT                               00000004
INTCON                            0000000B
INTE                              00000004
INTEDG                            00000006
INTF                              00000001
IOC                               00000096
IOC4                              00000004
IOC5                              00000005
IOC6                              00000006
IOC7                              00000007
IOCB                              00000096
IOCB4                             00000004
IOCB5                             00000005
IOCB6                             00000006
IOCB7                             00000007
IRCF0                             00000004
IRCF1                             00000005
IRCF2                             00000006
IRP                               00000007
IRVST                             00000005
LCDA                              00000005
LCDCON                            00000107
LCDDATA0                          00000110
LCDDATA1                          00000111
LCDDATA10                         0000011A
LCDDATA11                         0000011B
LCDDATA12                         00000190
LCDDATA13                         00000191
LCDDATA14                         00000192
LCDDATA15                         00000193
LCDDATA16                         00000194
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 200


SYMBOL TABLE
  LABEL                             VALUE 

LCDDATA17                         00000195
LCDDATA18                         00000196
LCDDATA19                         00000197
LCDDATA2                          00000112
LCDDATA20                         00000198
LCDDATA21                         00000199
LCDDATA22                         0000019A
LCDDATA23                         0000019B
LCDDATA3                          00000113
LCDDATA4                          00000114
LCDDATA5                          00000115
LCDDATA6                          00000116
LCDDATA7                          00000117
LCDDATA8                          00000118
LCDDATA9                          00000119
LCDEN                             00000007
LCDIE                             00000004
LCDIF                             00000004
LCDPS                             00000108
LCDSE0                            0000011C
LCDSE1                            0000011D
LCDSE2                            0000011E
LCDSE3                            0000019C
LCDSE4                            0000019D
LCDSE5                            0000019E
LMUX0                             00000000
LMUX1                             00000001
LP0                               00000000
LP1                               00000001
LP2                               00000002
LP3                               00000003
LTS                               00000001
LVDCON                            00000109
LVDEN                             00000004
LVDIE                             00000002
LVDIF                             00000002
LVDL0                             00000000
LVDL1                             00000001
LVDL2                             00000002
MSGBUFSIZE                        0x10
NOT_A                             00000005
NOT_ADDRESS                       00000005
NOT_BO                            00000000
NOT_BOR                           00000000
NOT_DONE                          00000001
NOT_PD                            00000003
NOT_POR                           00000001
NOT_RBPU                          00000007
NOT_RC8                           00000006
NOT_T1SYNC                        00000002
NOT_TO                            00000004
NOT_TX8                           00000006
NOT_W                             00000002
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 201


SYMBOL TABLE
  LABEL                             VALUE 

NOT_WRITE                         00000002
OERR                              00000001
OPTION_REG                        00000081
OSCCON                            0000008F
OSCTUNE                           00000090
OSFIE                             00000007
OSFIF                             00000007
OSTS                              00000003
P                                 00000004
PARAMBASE                         00002100
PCL                               00000002
PCLATH                            0000000A
PCON                              0000008E
PEIE                              00000006
PIE1                              0000008C
PIE2                              0000008D
PIR1                              0000000C
PIR2                              0000000D
PORTA                             00000005
PORTB                             00000006
PORTC                             00000007
PORTD                             00000008
PORTE                             00000009
PORTF                             00000188
PORTG                             00000189
PR2                               00000092
PS0                               00000000
PS1                               00000001
PS2                               00000002
PSA                               00000003
R                                 00000002
RA0                               00000000
RA1                               00000001
RA2                               00000002
RA3                               00000003
RA4                               00000004
RA5                               00000005
RA6                               00000006
RA7                               00000007
RB0                               00000000
RB1                               00000001
RB2                               00000002
RB3                               00000003
RB4                               00000004
RB5                               00000005
RB6                               00000006
RB7                               00000007
RBIE                              00000003
RBIF                              00000000
RC0                               00000000
RC1                               00000001
RC2                               00000002
RC3                               00000003
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 202


SYMBOL TABLE
  LABEL                             VALUE 

RC4                               00000004
RC5                               00000005
RC6                               00000006
RC7                               00000007
RC8_9                             00000006
RC9                               00000006
RCD8                              00000000
RCIE                              00000005
RCIF                              00000005
RCREG                             0000001A
RCSTA                             00000018
RD                                00000000
RD0                               00000000
RD1                               00000001
RD2                               00000002
RD3                               00000003
RD4                               00000004
RD5                               00000005
RD6                               00000006
RD7                               00000007
RE0                               00000000
RE1                               00000001
RE2                               00000002
RE3                               00000003
RE4                               00000004
RE5                               00000005
RE6                               00000006
RE7                               00000007
READ_WRITE                        00000002
RF0                               00000000
RF1                               00000001
RF2                               00000002
RF3                               00000003
RF4                               00000004
RF5                               00000005
RF6                               00000006
RF7                               00000007
RG0                               00000000
RG1                               00000001
RG2                               00000002
RG3                               00000003
RG4                               00000004
RG5                               00000005
RP0                               00000005
RP1                               00000006
RX9                               00000006
RX9D                              00000000
R_NOT_W                           00000002
R_W                               00000002
S                                 00000003
S0C0                              00000000
S0C1                              00000000
S0C2                              00000000
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 203


SYMBOL TABLE
  LABEL                             VALUE 

S0C3                              00000000
S10C0                             00000002
S10C1                             00000002
S10C2                             00000002
S10C3                             00000002
S11C0                             00000003
S11C1                             00000003
S11C2                             00000003
S11C3                             00000003
S12C0                             00000004
S12C1                             00000004
S12C2                             00000004
S12C3                             00000004
S13C0                             00000005
S13C1                             00000005
S13C2                             00000005
S13C3                             00000005
S14C0                             00000006
S14C1                             00000006
S14C2                             00000006
S14C3                             00000006
S15C0                             00000007
S15C1                             00000007
S15C2                             00000007
S15C3                             00000007
S16C0                             00000000
S16C1                             00000000
S16C2                             00000000
S16C3                             00000000
S17C0                             00000001
S17C1                             00000001
S17C2                             00000001
S17C3                             00000001
S18C0                             00000002
S18C1                             00000002
S18C2                             00000002
S18C3                             00000002
S19C0                             00000003
S19C1                             00000003
S19C2                             00000003
S19C3                             00000003
S1C0                              00000001
S1C1                              00000001
S1C2                              00000001
S1C3                              00000001
S20C0                             00000004
S20C1                             00000004
S20C2                             00000004
S20C3                             00000004
S21C0                             00000005
S21C1                             00000005
S21C2                             00000005
S21C3                             00000005
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 204


SYMBOL TABLE
  LABEL                             VALUE 

S22C0                             00000006
S22C1                             00000006
S22C2                             00000006
S22C3                             00000006
S23C0                             00000007
S23C1                             00000007
S23C2                             00000007
S23C3                             00000007
S24C0                             00000000
S24C1                             00000000
S24C2                             00000000
S24C3                             00000000
S25C0                             00000001
S25C1                             00000001
S25C2                             00000001
S25C3                             00000001
S26C0                             00000002
S26C1                             00000002
S26C2                             00000002
S26C3                             00000002
S27C0                             00000003
S27C1                             00000003
S27C2                             00000003
S27C3                             00000003
S28C0                             00000004
S28C1                             00000004
S28C2                             00000004
S28C3                             00000004
S29C0                             00000005
S29C1                             00000005
S29C2                             00000005
S29C3                             00000005
S2C0                              00000002
S2C1                              00000002
S2C2                              00000002
S2C3                              00000002
S30C0                             00000006
S30C1                             00000006
S30C2                             00000006
S30C3                             00000006
S31C0                             00000007
S31C1                             00000007
S31C2                             00000007
S31C3                             00000007
S32C0                             00000000
S32C1                             00000000
S32C2                             00000000
S32C3                             00000000
S33C0                             00000001
S33C1                             00000001
S33C2                             00000001
S33C3                             00000001
S34C0                             00000002
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 205


SYMBOL TABLE
  LABEL                             VALUE 

S34C1                             00000002
S34C2                             00000002
S34C3                             00000002
S35C0                             00000003
S35C1                             00000003
S35C2                             00000003
S35C3                             00000003
S36C0                             00000004
S36C1                             00000004
S36C2                             00000004
S36C3                             00000004
S37C0                             00000005
S37C1                             00000005
S37C2                             00000005
S37C3                             00000005
S38C0                             00000006
S38C1                             00000006
S38C2                             00000006
S38C3                             00000006
S39C0                             00000007
S39C1                             00000007
S39C2                             00000007
S39C3                             00000007
S3C0                              00000003
S3C1                              00000003
S3C2                              00000003
S3C3                              00000003
S40C0                             00000000
S40C1                             00000000
S40C2                             00000000
S40C3                             00000000
S41C0                             00000001
S41C1                             00000001
S41C2                             00000001
S41C3                             00000001
S4C0                              00000004
S4C1                              00000004
S4C2                              00000004
S4C3                              00000004
S5C0                              00000005
S5C1                              00000005
S5C2                              00000005
S5C3                              00000005
S6C0                              00000006
S6C1                              00000006
S6C2                              00000006
S6C3                              00000006
S7C0                              00000007
S7C1                              00000007
S7C2                              00000007
S7C3                              00000007
S8C0                              00000000
S8C1                              00000000
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 206


SYMBOL TABLE
  LABEL                             VALUE 

S8C2                              00000000
S8C3                              00000000
S9C0                              00000001
S9C1                              00000001
S9C2                              00000001
S9C3                              00000001
SBOREN                            00000004
SCS                               00000000
SE0                               00000000
SE1                               00000001
SE10                              00000002
SE11                              00000003
SE12                              00000004
SE13                              00000005
SE14                              00000006
SE15                              00000007
SE16                              00000000
SE17                              00000001
SE18                              00000002
SE19                              00000003
SE2                               00000002
SE20                              00000004
SE21                              00000005
SE22                              00000006
SE23                              00000007
SE24                              00000000
SE25                              00000001
SE26                              00000002
SE27                              00000003
SE28                              00000004
SE29                              00000005
SE3                               00000003
SE30                              00000006
SE31                              00000007
SE32                              00000000
SE33                              00000001
SE34                              00000002
SE35                              00000003
SE36                              00000004
SE37                              00000005
SE38                              00000006
SE39                              00000007
SE4                               00000004
SE40                              00000000
SE41                              00000001
SE5                               00000005
SE6                               00000006
SE7                               00000007
SE8                               00000000
SE9                               00000001
SEG0                              00000000
SEG0COM0                          00000000
SEG0COM1                          00000000
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 207


SYMBOL TABLE
  LABEL                             VALUE 

SEG0COM2                          00000000
SEG0COM3                          00000000
SEG1                              00000001
SEG10                             00000002
SEG10COM0                         00000002
SEG10COM1                         00000002
SEG10COM2                         00000002
SEG10COM3                         00000002
SEG11                             00000003
SEG11COM0                         00000003
SEG11COM1                         00000003
SEG11COM2                         00000003
SEG11COM3                         00000003
SEG12                             00000004
SEG12COM0                         00000004
SEG12COM1                         00000004
SEG12COM2                         00000004
SEG12COM3                         00000004
SEG13                             00000005
SEG13COM0                         00000005
SEG13COM1                         00000005
SEG13COM2                         00000005
SEG13COM3                         00000005
SEG14                             00000006
SEG14COM0                         00000006
SEG14COM1                         00000006
SEG14COM2                         00000006
SEG14COM3                         00000006
SEG15                             00000007
SEG15COM0                         00000007
SEG15COM1                         00000007
SEG15COM2                         00000007
SEG15COM3                         00000007
SEG16                             00000000
SEG16COM0                         00000000
SEG16COM1                         00000000
SEG16COM2                         00000000
SEG16COM3                         00000000
SEG17                             00000001
SEG17COM0                         00000001
SEG17COM1                         00000001
SEG17COM2                         00000001
SEG17COM3                         00000001
SEG18                             00000002
SEG18COM0                         00000002
SEG18COM1                         00000002
SEG18COM2                         00000002
SEG18COM3                         00000002
SEG19                             00000003
SEG19COM0                         00000003
SEG19COM1                         00000003
SEG19COM2                         00000003
SEG19COM3                         00000003
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 208


SYMBOL TABLE
  LABEL                             VALUE 

SEG1COM0                          00000001
SEG1COM1                          00000001
SEG1COM2                          00000001
SEG1COM3                          00000001
SEG2                              00000002
SEG20                             00000004
SEG20COM0                         00000004
SEG20COM1                         00000004
SEG20COM2                         00000004
SEG20COM3                         00000004
SEG21                             00000005
SEG21COM0                         00000005
SEG21COM1                         00000005
SEG21COM2                         00000005
SEG21COM3                         00000005
SEG22                             00000006
SEG22COM0                         00000006
SEG22COM1                         00000006
SEG22COM2                         00000006
SEG22COM3                         00000006
SEG23                             00000007
SEG23COM0                         00000007
SEG23COM1                         00000007
SEG23COM2                         00000007
SEG23COM3                         00000007
SEG24                             00000000
SEG24COM0                         00000000
SEG24COM1                         00000000
SEG24COM2                         00000000
SEG24COM3                         00000000
SEG25                             00000001
SEG25COM0                         00000001
SEG25COM1                         00000001
SEG25COM2                         00000001
SEG25COM3                         00000001
SEG26                             00000002
SEG26COM0                         00000002
SEG26COM1                         00000002
SEG26COM2                         00000002
SEG26COM3                         00000002
SEG27                             00000003
SEG27COM0                         00000003
SEG27COM1                         00000003
SEG27COM2                         00000003
SEG27COM3                         00000003
SEG28                             00000004
SEG28COM0                         00000004
SEG28COM1                         00000004
SEG28COM2                         00000004
SEG28COM3                         00000004
SEG29                             00000005
SEG29COM0                         00000005
SEG29COM1                         00000005
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 209


SYMBOL TABLE
  LABEL                             VALUE 

SEG29COM2                         00000005
SEG29COM3                         00000005
SEG2COM0                          00000002
SEG2COM1                          00000002
SEG2COM2                          00000002
SEG2COM3                          00000002
SEG3                              00000003
SEG30                             00000006
SEG30COM0                         00000006
SEG30COM1                         00000006
SEG30COM2                         00000006
SEG30COM3                         00000006
SEG31                             00000007
SEG31COM0                         00000007
SEG31COM1                         00000007
SEG31COM2                         00000007
SEG31COM3                         00000007
SEG32                             00000000
SEG32COM0                         00000000
SEG32COM1                         00000000
SEG32COM2                         00000000
SEG32COM3                         00000000
SEG33                             00000001
SEG33COM0                         00000001
SEG33COM1                         00000001
SEG33COM2                         00000001
SEG33COM3                         00000001
SEG34                             00000002
SEG34COM0                         00000002
SEG34COM1                         00000002
SEG34COM2                         00000002
SEG34COM3                         00000002
SEG35                             00000003
SEG35COM0                         00000003
SEG35COM1                         00000003
SEG35COM2                         00000003
SEG35COM3                         00000003
SEG36                             00000004
SEG36COM0                         00000004
SEG36COM1                         00000004
SEG36COM2                         00000004
SEG36COM3                         00000004
SEG37                             00000005
SEG37COM0                         00000005
SEG37COM1                         00000005
SEG37COM2                         00000005
SEG37COM3                         00000005
SEG38                             00000006
SEG38COM0                         00000006
SEG38COM1                         00000006
SEG38COM2                         00000006
SEG38COM3                         00000006
SEG39                             00000007
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 210


SYMBOL TABLE
  LABEL                             VALUE 

SEG39COM0                         00000007
SEG39COM1                         00000007
SEG39COM2                         00000007
SEG39COM3                         00000007
SEG3COM0                          00000003
SEG3COM1                          00000003
SEG3COM2                          00000003
SEG3COM3                          00000003
SEG4                              00000004
SEG40                             00000000
SEG40COM0                         00000000
SEG40COM1                         00000000
SEG40COM2                         00000000
SEG40COM3                         00000000
SEG41                             00000001
SEG41COM0                         00000001
SEG41COM1                         00000001
SEG41COM2                         00000001
SEG41COM3                         00000001
SEG4COM0                          00000004
SEG4COM1                          00000004
SEG4COM2                          00000004
SEG4COM3                          00000004
SEG5                              00000005
SEG5COM0                          00000005
SEG5COM1                          00000005
SEG5COM2                          00000005
SEG5COM3                          00000005
SEG6                              00000006
SEG6COM0                          00000006
SEG6COM1                          00000006
SEG6COM2                          00000006
SEG6COM3                          00000006
SEG7                              00000007
SEG7COM0                          00000007
SEG7COM1                          00000007
SEG7COM2                          00000007
SEG7COM3                          00000007
SEG8                              00000000
SEG8COM0                          00000000
SEG8COM1                          00000000
SEG8COM2                          00000000
SEG8COM3                          00000000
SEG9                              00000001
SEG9COM0                          00000001
SEG9COM1                          00000001
SEG9COM2                          00000001
SEG9COM3                          00000001
SEGEN0                            00000000
SEGEN1                            00000001
SEGEN10                           00000002
SEGEN11                           00000003
SEGEN12                           00000004
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 211


SYMBOL TABLE
  LABEL                             VALUE 

SEGEN13                           00000005
SEGEN14                           00000006
SEGEN15                           00000007
SEGEN16                           00000000
SEGEN17                           00000001
SEGEN18                           00000002
SEGEN19                           00000003
SEGEN2                            00000002
SEGEN20                           00000004
SEGEN21                           00000005
SEGEN22                           00000006
SEGEN23                           00000007
SEGEN24                           00000000
SEGEN25                           00000001
SEGEN26                           00000002
SEGEN27                           00000003
SEGEN28                           00000004
SEGEN29                           00000005
SEGEN3                            00000003
SEGEN30                           00000006
SEGEN31                           00000007
SEGEN32                           00000000
SEGEN33                           00000001
SEGEN34                           00000002
SEGEN35                           00000003
SEGEN36                           00000004
SEGEN37                           00000005
SEGEN38                           00000006
SEGEN39                           00000007
SEGEN4                            00000004
SEGEN40                           00000000
SEGEN41                           00000001
SEGEN5                            00000005
SEGEN6                            00000006
SEGEN7                            00000007
SEGEN8                            00000000
SEGEN9                            00000001
SLPEN                             00000006
SMP                               00000007
SPBRG                             00000099
SPEN                              00000007
SREN                              00000005
SSPADD                            00000093
SSPBUF                            00000013
SSPCON                            00000014
SSPEN                             00000005
SSPIE                             00000003
SSPIF                             00000003
SSPM0                             00000000
SSPM1                             00000001
SSPM2                             00000002
SSPM3                             00000003
SSPOV                             00000006
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 212


SYMBOL TABLE
  LABEL                             VALUE 

SSPSTAT                           00000094
STARTBYTE                         0x00
STATE                             5
STATUS                            00000003
SWDTE                             00000000
SWDTEN                            00000000
SYNC                              00000004
T0CS                              00000005
T0IE                              00000005
T0IF                              00000002
T0SE                              00000004
T1CKPS0                           00000004
T1CKPS1                           00000005
T1CON                             00000010
T1GE                              00000006
T1GINV                            00000007
T1GSS                             00000001
T1INSYNC                          00000002
T1OSCEN                           00000003
T1SYNC                            00000002
T2CKPS0                           00000000
T2CKPS1                           00000001
T2CON                             00000012
TIMEisequal                       00000FCD
TIMEisgreater                     00000FCF
TIMEislower                       00000FCE
TMR0                              00000001
TMR0IE                            00000005
TMR0IF                            00000002
TMR1CS                            00000001
TMR1GE                            00000006
TMR1H                             0000000F
TMR1IE                            00000000
TMR1IF                            00000000
TMR1L                             0000000E
TMR1ON                            00000000
TMR2                              00000011
TMR2IE                            00000001
TMR2IF                            00000001
TMR2ON                            00000002
TOUTPS0                           00000003
TOUTPS1                           00000004
TOUTPS2                           00000005
TOUTPS3                           00000006
TRISA                             00000085
TRISA0                            00000000
TRISA1                            00000001
TRISA2                            00000002
TRISA3                            00000003
TRISA4                            00000004
TRISA5                            00000005
TRISA6                            00000006
TRISA7                            00000007
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 213


SYMBOL TABLE
  LABEL                             VALUE 

TRISB                             00000086
TRISB0                            00000000
TRISB1                            00000001
TRISB2                            00000002
TRISB3                            00000003
TRISB4                            00000004
TRISB5                            00000005
TRISB6                            00000006
TRISB7                            00000007
TRISC                             00000087
TRISC0                            00000000
TRISC1                            00000001
TRISC2                            00000002
TRISC3                            00000003
TRISC4                            00000004
TRISC5                            00000005
TRISC6                            00000006
TRISC7                            00000007
TRISD                             00000088
TRISD0                            00000000
TRISD1                            00000001
TRISD2                            00000002
TRISD3                            00000003
TRISD4                            00000004
TRISD5                            00000005
TRISD6                            00000006
TRISD7                            00000007
TRISE                             00000089
TRISE0                            00000000
TRISE1                            00000001
TRISE2                            00000002
TRISE3                            00000003
TRISE4                            00000004
TRISE5                            00000005
TRISE6                            00000006
TRISE7                            00000007
TRISF                             00000185
TRISF0                            00000000
TRISF1                            00000001
TRISF2                            00000002
TRISF3                            00000003
TRISF4                            00000004
TRISF5                            00000005
TRISF6                            00000006
TRISF7                            00000007
TRISG                             00000187
TRISG0                            00000000
TRISG1                            00000001
TRISG2                            00000002
TRISG3                            00000003
TRISG4                            00000004
TRISG5                            00000005
TRMT                              00000001
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 214


SYMBOL TABLE
  LABEL                             VALUE 

TUN0                              00000000
TUN1                              00000001
TUN2                              00000002
TUN3                              00000003
TUN4                              00000004
TX8_9                             00000006
TX9                               00000006
TX9D                              00000000
TXD8                              00000000
TXEN                              00000005
TXIE                              00000004
TXIF                              00000004
TXREG                             00000019
TXSTA                             00000098
UA                                00000001
VARIABLES                         00000000
VCFG0                             00000005
VCFG1                             00000006
VLCDEN                            00000004
VR0                               00000000
VR1                               00000001
VR2                               00000002
VR3                               00000003
VRCON                             0000009D
VREN                              00000007
VRR                               00000005
W                                 00000000
WA                                00000004
WCOL                              00000007
WDTCON                            00000105
WDTPS0                            00000001
WDTPS1                            00000002
WDTPS2                            00000003
WDTPS3                            00000004
WERR                              00000005
WFT                               00000007
WPU                               00000095
WPU0                              00000000
WPU1                              00000001
WPU2                              00000002
WPU3                              00000003
WPU4                              00000004
WPU5                              00000005
WPU6                              00000006
WPU7                              00000007
WPUB                              00000095
WPUB0                             00000000
WPUB1                             00000001
WPUB2                             00000002
WPUB3                             00000003
WPUB4                             00000004
WPUB5                             00000005
WPUB6                             00000006
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 215


SYMBOL TABLE
  LABEL                             VALUE 

WPUB7                             00000007
WR                                00000001
WREN                              00000002
WRERR                             00000003
XTAL_FREQ                         .8000000
Z                                 00000002
_BOD_NSLEEP                       00003EFF
_BOD_OFF                          00003CFF
_BOD_ON                           00003FFF
_BOD_SBODEN                       00003DFF
_CONFIG                           00002007
_CPD_OFF                          00003FFF
_CPD_ON                           00003F7F
_CP_OFF                           00003FFF
_CP_ON                            00003FBF
_DEBUG_OFF                        00003FFF
_DEBUG_ON                         00002FFF
_DEVID1                           00002006
_EC_OSC                           00003FFB
_EXTRC                            00003FFF
_EXTRCIO                          00003FFE
_EXTRC_OSC_CLKOUT                 00003FFF
_EXTRC_OSC_NOCLKOUT               00003FFE
_FCMEN_OFF                        000037FF
_FCMEN_ON                         00003FFF
_HS_OSC                           00003FFA
_IDLOC0                           00002000
_IDLOC1                           00002001
_IDLOC2                           00002002
_IDLOC3                           00002003
_IESO_OFF                         00003BFF
_IESO_ON                          00003FFF
_INTOSC                           00003FFD
_INTOSCIO                         00003FFC
_INTRC_OSC_CLKOUT                 00003FFD
_INTRC_OSC_NOCLKOUT               00003FFC
_LP_OSC                           00003FF8
_MCLRE_OFF                        00003FDF
_MCLRE_ON                         00003FFF
_PWRTE_OFF                        00003FFF
_PWRTE_ON                         00003FEF
_WDT_OFF                          00003FF7
_WDT_ON                           00003FFF
_XT_OSC                           00003FF9
__16F946                          00000001
actionbase                        00000003
bitTable                          00000F3C
bitTable1                         00000F46
bitmaskHi                         00000031
bitmaskLo                         00000030
bits89                            8
bittog                            
cfgRxCnt                          00000051
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 216


SYMBOL TABLE
  LABEL                             VALUE 

cfgTxCnt                          00000052
checkOutput                       00000F4E
chkDelay                          00000F62
clearBank0                        0000184A
clearBank1                        00001852
clearBank2                        0000185D
clearBank3                        00001865
clearRam                          00001845
clearRam2                         00001858
clone70_7f_1                      000000F0
clone70_7f_2                      00000170
clone70_7f_3                      000001F0
clrDelay                          00000F55
compareTime                       00000FA8
crc                               00000059
delay                             4
devID1                            3
devID2                            5
device                            0x0d
deviceID                          00000020
disableirq                        
dispatch                          00000924
dispatchCont                      000009C4
dispatchLoop                      0000092F
dispatchLoop1                     00000955
dispatchLoop2                     00000963
dispatchLoop3                     00000984
dispatchLoop4                     0000099B
dispatchLoop5                     000009A9
displayram                        0000005B
eeByte                            00000058
eeDeviceID                        00000000
eeOutputHi                        00000002
eeOutputLo                        00000001
eeRead                            0000100E
eeRead_1                          00001010
eeWrite                           00000FF4
eeWrite_1                         00000FF6
enableirq                         
endless                           00000923
fAlwaysOff                        000009F8
fAlwaysOn                         000009FF
fAwning                           00000B90
fAwningA                          00000BA0
fAwningB                          00000B9D
fAwningC                          00000BF7
fAwningO                          00000BFE
fAwningS00                        00000BB2
fAwningS00a                       00000BBF
fAwningS00b                       00000BC3
fAwningS01                        00000BCC
fAwningS02                        00000BEB
fAwningStop                       00000BD2
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 217


SYMBOL TABLE
  LABEL                             VALUE 

fBlind                            00000C05
fBlindA                           00000C15
fBlindB                           00000C12
fBlindD                           00000CB1
fBlindS00                         00000C2F
fBlindS00a                        00000C3C
fBlindS00b                        00000C40
fBlindS01                         00000C4F
fBlindS01a                        00000C57
fBlindS02                         00000C6A
fBlindS02a                        00000C72
fBlindS03                         00000C7F
fBlindS04                         00000C9E
fBlindStop                        00000C85
fBlindU                           00000CAA
fBlinker                          00000B55
fBlinker1                         00000B5C
fBlinker2                         00000B68
fBlinker3                         00000B72
fBlinker4                         00000B7C
fCOutput                          00000E7C
fOff                              00000DC0
fOff1                             00000DCE
fOff2                             00000DDE
fOn                               00000DE4
fOn1                              00000DF2
fOn2                              00000E02
fPassThrough                      00000A06
fPassThrough1                     00000A11
fPoll                             00000DB5
fPowerOff                         00000D9D
fPowerOff1                        00000DA5
fRdConfig                         00000E3D
fRdInput                          00000EA8
fRdInput1                         00000EC2
fRdInputs                         00000EC7
fRdOutput                         00000ED6
fRdOutput1                        00000EF0
fRdOutputs                        00000EF5
fRdTime                           00000E08
fReset                            00000DAB
fReset1                           00000DB3
fSOutput                          00000E88
fTimerR                           00000B2A
fTimerR0                          00000B43
fTimerR1                          00000B4C
fTimerRa                          00000B35
fToggle                           00000A18
fToggleDual                       00000A52
fToggleDual0                      00000A62
fToggleDual1                      00000A76
fToggleDual2                      00000A83
fToggleDual3                      00000A8B
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 218


SYMBOL TABLE
  LABEL                             VALUE 

fToggleDual4                      00000A98
fToggleDual5                      00000AA8
fToggleDualA                      00000A5F
fToggleS1                         00000A23
fToggleS2                         00000A27
fToggleS3                         00000A36
fToggleS4                         00000A3D
fToggleS5                         00000A49
fTwoStage                         00000AB9
fTwoStage1                        00000AC6
fTwoStage2                        00000AC9
fTwoStage3                        00000AD7
fTwoStage4                        00000AE8
fTwoStage5                        00000AF3
fTwoStage6                        00000B0C
fTwoStage7                        00000B1B
fWindow                           00000CB8
fWindowA                          00000CC8
fWindowB                          00000CC5
fWindowC                          00000D1A
fWindowO                          00000D37
fWindowS00                        00000CEA
fWindowS00a                       00000D03
fWindowS01                        00000D12
fWindowS02                        00000D4C
fWindowS03                        00000D76
fWindowS04                        00000D91
fWindowS11                        00000D2F
fWindowS12                        00000D61
fWindowStop                       00000D7C
fWrConfig                         00000E4A
fWrConfig1                        00000E4F
fWrConfig3                        00000E63
fWrConfig4                        00000E66
fWrConfig5                        00000E69
fWrConfig7                        00000E70
fWrConfig8                        00000E72
fWrConfig9                        00000E76
fWrOutputs                        00000E94
fWrOutputs1                       00000E98
fWrOutputs2                       00000E9C
fWrOutputs3                       00000EA1
fWrOutputs4                       00000EA4
fWrTime                           00000E1D
fWrTime1                          00000E25
fWrTime2                          00000E29
fWrTime3                          00000E2D
fWrTime4                          00000E31
fWrTime5                          00000E35
fWrTime6                          00000E3A
funcDelay                         00000041
funcDevID1                        0000003F
funcDevID2                        00000040
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 219


SYMBOL TABLE
  LABEL                             VALUE 

funcNumParams                     00000042
funcOutBits                       0000003D
funcPrescMode                     0000003C
funcSemaphore                     00000043
funcTypeInput                     0000003E
funcUber                          00000044
functionRam                       00000120
functionRam2                      000001A0
genBitmask                        00000F30
genBitmask1                       00000F38
genBitmask2                       00000F3B
genDelay                          00000F75
genDelay0                         00000F7B
genDelay1                         00000F7F
genDelayF                         00000F6E
genMessage1                       000008DB
genMessage2                       000008EC
genMessage3                       00000901
genMessage4                       00000912
getRx                             00000F19
getRx1                            00000F2D
iCount                            00000054
iDebounce                         000000B7
iDebounceAuxA                     0000002C
iDebounceAuxB                     0000002F
iDebounceHiA                      0000002B
iDebounceHiB                      0000002E
iDebounceLoA                      0000002A
iDebounceLoB                      0000002D
iDisplay                          00000054
iDisplay1                         0000005D
iDisplay2                         0000009B
iDisplayCount                     0000005A
iEdgeAux                          00000029
iEdgeHi                           00000028
iEdgeLo                           00000027
iExit                             00000035
iExit1                            0000003C
iGetInput                         0000009C
iHeartBeat                        0000013A
iInSampleAux                      00000023
iInSampleHi                       00000022
iInSampleLo                       00000021
iInputAux                         00000026
iInputHi                          00000025
iInputLo                          00000024
iOutput                           000000E1
iQueueMsg                         0000013B
iReverseNibble                    0000015A
iRxHandler                        00000189
iShowState                        0000010C
iShowState2                       00000139
iSkipRx                           00000046
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 220


SYMBOL TABLE
  LABEL                             VALUE 

iTabTemp                          0000007A
iTemp1                            00000055
iTemp2                            00000056
iTemp3                            00000057
iTestRxIrq                        0000000D
iTestTimer2                       00000014
iTestTxIrq                        0000000F
iTimeEnd                          00000029
iTxHandler                        00000174
iTxHandler1                       00000185
initParams                        000018AE
initPlvd                          000018A8
initPorts                         00001800
initTimer0                        00001880
initTimer1                        00001886
initTimer2                        00001897
initUart                          0000186F
input                             2
itabj                             
longcall                          
main                              00000800
mainLoop1                         000008C2
mainLoop2                         00000918
movff                             
movlf                             
msgBuf                            000000E0
msgGetPtr                         0000004C
msgHi                             0000004F
msgID                             00000050
msgLo                             0000004E
msgNum                            0000004D
msgPutPtr                         0000004B
numParameter                      000009C7
output                            1
outputHi                          00000033
outputLo                          00000032
outputOff                         
outputOn                          
outputToggle                      
paramPtr1                         00000039
paramPtr2                         0000003A
paramPtr3                         0000003B
parseRx                           00000828
parseRx0                          0000083B
parseRx1                          00000849
parseRx2                          00000855
parseRx3                          00000861
parseRx4                          00000869
parseRx5                          00000884
parseRx6                          0000089F
parseRxE                          000008BD
parseRxX                          000008BE
pcall                             
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 221


SYMBOL TABLE
  LABEL                             VALUE 

powerDown                         00000919
prescale_Mode                     0
putTx                             00000F04
putTx1                            00000F07
ramOverFlow                       00000069
revision                          4
rxBuf                             000000A0
rxBufferFull                      000001A2
rxByte1                           00000035
rxByte2                           00000036
rxCheckBuffer                     00000193
rxCheckFraming                    00000191
rxCount                           00000034
rxDevID                           00000037
rxDiscardByte                     000001A2
rxGetPtr                          00000049
rxInput                           00000038
rxNum                             0000004A
rxPutPtr                          00000048
safeOutput                        00000FD0
safedFSR                          00000073
safedPCLATH                       00000072
safedSTATUS                       00000071
safedW                            00000070
scall                             
setpclath                         
setpclath3                        
setpclath4                        
skipRxCnt                         00000053
tabTemp                           00000079
tabj                              
temp1                             0000007B
temp2                             0000007C
temp3                             0000007D
temp4                             0000007E
temp5                             0000007F
time                              00000074
tstbnd                            
txBuf                             000000C0
txGetPtr                          00000046
txNum                             00000047
txPutPtr                          00000045
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 222


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXX------------ ----------------
0800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
08C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0900 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0940 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0980 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
09C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0A00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0A40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0A80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0AC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0B00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0B40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0B80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0BC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0C00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0C40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0C80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0CC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0D00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0D40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0D80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0DC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0E00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0E40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0E80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0EC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0F00 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0F40 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0F80 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0FC0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1000 : XXXXXXXXXXXXXXXX XXXXXXXXXX------ ---------------- ----------------
1800 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1840 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
1880 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
18C0 : XXXXXXXXXX------ ---------------- ---------------- ----------------
2000 : -------X-------- ---------------- ---------------- ----------------
2100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
MPASM  5.42                       MULTIIO.ASM   7-19-2011  0:50:38         PAGE 223


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


2140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XX-------------- ----------------

All other memory blocks unused.

Program Memory Words Used:  2696
Program Memory Words Free:  5496


Errors   :     0
Warnings :     0 reported,     0 suppressed
Messages :     1 reported,    62 suppressed

